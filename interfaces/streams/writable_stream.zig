// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! WritableStream class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#ws-class
//! IDL: specs/streams.idl lines 123-132
//!
//! Represents a destination for streaming data that can be written incrementally.

const std = @import("std");
const webidl = @import("webidl");
const common = @import("common");
const dict_parsing = @import("dict_parsing");
const event_loop = @import("event_loop");
const AsyncPromise = @import("async_promise").AsyncPromise;
const TestEventLoop = @import("test_event_loop").TestEventLoop;
const WritableStreamDefaultController = @import("writable_stream_default_controller").WritableStreamDefaultController;
const WritableStreamDefaultWriter = @import("writable_stream_default_writer").WritableStreamDefaultWriter;

/// Stream state enumeration
///
/// Spec: § 5.1 "Internal slots" - [[state]]
pub const StreamState = enum {
    writable,
    closed,
    erroring,
    errored,
};

/// Writer type for a writable stream (optional)
pub const Writer = union(enum) {
    none: void,
    default: *WritableStreamDefaultWriter,
};

/// Abort request record
const AbortRequest = struct {
    promise: common.Promise(void),
    reason: ?common.JSValue,
    was_already_erroring: bool,
};
/// WritableStream zoop class
/// 
/// IDL:
/// ```webidl
/// [Exposed=*, Transferable]
/// interface WritableStream {
/// constructor(optional object underlyingSink, optional QueuingStrategy strategy = {});
/// 
/// readonly attribute boolean locked;
/// 
/// Promise<undefined> abort(optional any reason);
/// Promise<undefined> close();
/// WritableStreamDefaultWriter getWriter();
/// };
/// ```
pub const WritableStream = struct {
    allocator: std.mem.Allocator,
    /// [[backpressure]]: boolean - whether backpressure is being applied
    backpressure: bool,
    /// [[closeRequest]]: undefined or promise
    close_request: ?common.Promise(void),
    /// [[controller]]: WritableStreamDefaultController
    controller: *WritableStreamDefaultController,
    /// [[detached]]: boolean - stream has been transferred via postMessage
    detached: bool,
    /// [[inFlightWriteRequest]]: undefined or promise
    in_flight_write_request: ?common.Promise(void),
    /// [[inFlightCloseRequest]]: undefined or promise
    in_flight_close_request: ?common.Promise(void),
    /// [[pendingAbortRequest]]: undefined or record
    pending_abort_request: ?AbortRequest,
    /// [[state]]: "writable", "closed", "erroring", or "errored"
    state: StreamState,
    /// [[storedError]]: JavaScript value (if state is "erroring" or "errored")
    stored_error: ?common.JSValue,
    /// [[writer]]: WritableStreamDefaultWriter or undefined
    writer: Writer,
    /// [[writeRequests]]: list of async promises
    write_requests: std.ArrayList(*AsyncPromise(void)),
    /// Event loop for async operations (borrowed reference)
    /// The stream does not own the event loop - it borrows it from the execution context.
    event_loop: event_loop.EventLoop,
    /// Optional owned event loop for backward compatibility
    /// Only set when using the deprecated init() method.
    /// New code should use initWithSink() and manage event loops externally.
    event_loop_storage: ?*TestEventLoop,

    /// Initialize a new WritableStream (internal - not exposed via WebIDL)
    /// DEPRECATED: Use initWithSink() and provide an event loop.
    /// This function is kept for backward compatibility.
    /// 
    /// NOTE: This creates an internal event loop that is owned by the stream.
    /// This is NOT recommended for new code - use initWithSink() instead.
    pub fn init(allocator: std.mem.Allocator) !WritableStream {
        // Create an owned event loop for backward compatibility
        const loop_ptr = try allocator.create(TestEventLoop);
        errdefer allocator.destroy(loop_ptr);

        loop_ptr.* = TestEventLoop.init(allocator);

        var stream = try initWithSink(allocator, loop_ptr.eventLoop(), null, null);

        // Mark that we own this event loop so deinit() will clean it up
        stream.event_loop_storage = loop_ptr;

        return stream;
    }
    pub fn deinit(self: *WritableStream) void {
        // IMPORTANT: We do NOT run microtasks during deinit.
        // Microtasks can reference promises and other objects that are being destroyed.
        // Running them during cleanup can cause use-after-free errors.
        //
        // If the event loop is owned by this stream (event_loop_storage != null),
        // all promises are allocated from the event loop's arena and will be freed
        // when the arena is destroyed.
        //
        // If the event loop is borrowed (event_loop_storage == null), the caller
        // is responsible for managing microtask execution in the shared event loop.

        self.controller.deinit();
        self.allocator.destroy(self.controller);

        // Clean up write requests list
        // Note: write_requests promises are owned by callers, just clear the list
        self.write_requests.deinit(self.allocator);

        switch (self.writer) {
            .default => |w| {
                w.deinit();
                self.allocator.destroy(w);
            },
            .none => {},
        }

        // Clean up owned event loop if we created one (backward compatibility)
        if (self.event_loop_storage) |loop_ptr| {
            loop_ptr.deinit();
            self.allocator.destroy(loop_ptr);
        }
        // Otherwise, we borrowed the event loop and don't destroy it
        // (matches browser semantics where streams don't own event loops)
    }
    /// Initialize with underlying sink and strategy
    /// 
    /// IDL: constructor(optional object underlyingSink, optional QueuingStrategy strategy = {});
    /// 
    /// Spec algorithm: § 5.1.3 "new WritableStream(underlyingSink, strategy)"
    pub fn initWithSink(
        allocator: std.mem.Allocator,
        loop: event_loop.EventLoop,
        underlying_sink: ?webidl.JSValue,
        strategy: ?webidl.JSValue,
    ) !WritableStream {
        // Step 1: If underlyingSink is missing, set it to null.
        // Step 2: Let underlyingSinkDict be underlyingSink, converted to an IDL value of type UnderlyingSink.
        const sink_dict = try dict_parsing.parseUnderlyingSink(allocator, underlying_sink);

        // Step 3: Let strategy be ? Get(strategy, "highWaterMark").
        // Step 4: Let size be ? Get(strategy, "size").
        const strategy_dict = try dict_parsing.parseQueuingStrategy(allocator, strategy);

        // Extract high water mark with default of 1.0
        const high_water_mark = strategy_dict.high_water_mark orelse 1.0;

        // Extract size algorithm with default
        const size_algorithm = if (strategy_dict.size) |size_fn|
            common.wrapSizeCallback(size_fn)
        else
            common.defaultSizeAlgorithm();

        // Wrap sink callbacks in algorithm structs
        const abort_algorithm = if (sink_dict.abort) |abort_fn|
            common.wrapAbortCallback(abort_fn)
        else
            common.defaultAbortAlgorithm();

        const close_algorithm = if (sink_dict.close) |close_fn|
            common.wrapCloseCallback(close_fn)
        else
            common.defaultCloseAlgorithm();

        const write_algorithm = if (sink_dict.write) |write_fn|
            common.wrapWriteCallback(write_fn)
        else
            common.defaultWriteAlgorithm();

        // Step 5: Let type be ? Get(underlyingSinkDict, "type").
        // Step 6: If type is not undefined, throw a RangeError (reserved for future use).

        // Create controller on heap
        const controller = try allocator.create(WritableStreamDefaultController);
        errdefer allocator.destroy(controller);

        controller.* = WritableStreamDefaultController.init(
            allocator,
            abort_algorithm,
            close_algorithm,
            write_algorithm,
            high_water_mark,
            size_algorithm,
            loop,
        );

        var stream = WritableStream{
            .allocator = allocator,
            .backpressure = false,
            .close_request = null,
            .controller = controller,
            .detached = false,
            .in_flight_write_request = null,
            .in_flight_close_request = null,
            .pending_abort_request = null,
            .state = .writable,
            .stored_error = null,
            .writer = .none,
            .write_requests = std.ArrayList(*AsyncPromise(void)).empty,
            .event_loop = loop,
            .event_loop_storage = null, // Borrowed event loop (not owned)
        };

        // Step 7: Set controller's stream reference
        stream.controller.stream = @ptrCast(&stream);

        // Step 8: Let startAlgorithm be an algorithm that returns undefined.
        // Step 9: Let writeAlgorithm be an algorithm that returns a promise resolved with undefined.
        // Step 10: Let closeAlgorithm be an algorithm that returns a promise resolved with undefined.
        // Step 11: Let abortAlgorithm be an algorithm that returns a promise resolved with undefined.

        // Step 12: If underlyingSinkDict["start"] exists:
        //    - Set startAlgorithm to call underlyingSinkDict["start"]
        // TODO: Extract and call start algorithm

        // Step 13: If underlyingSinkDict["write"] exists:
        //    - Set writeAlgorithm to call underlyingSinkDict["write"]
        // TODO: Extract write algorithm

        // Step 14: If underlyingSinkDict["close"] exists:
        //    - Set closeAlgorithm to call underlyingSinkDict["close"]
        // TODO: Extract close algorithm

        // Step 15: If underlyingSinkDict["abort"] exists:
        //    - Set abortAlgorithm to call underlyingSinkDict["abort"]
        // TODO: Extract abort algorithm

        // Step 16: Perform ! SetUpWritableStreamDefaultController(...)
        // (Already done by creating controller)

        // Step 17: Mark controller as started
        stream.controller.started = true;

        return stream;
    }
    /// Returns whether the stream is locked to a writer.
    /// 
    /// IDL: readonly attribute boolean locked;
    /// 
    /// Spec algorithm: § 5.1.3 "The locked getter steps are:"
    pub fn get_locked(self: *const WritableStream) webidl.boolean {
        // Step 1: Return ! IsWritableStreamLocked(this).
        return self.isLocked();
    }
    /// Aborts the stream, signaling that the producer can no longer write.
    /// 
    /// IDL: Promise<undefined> abort(optional any reason);
    /// 
    /// Spec algorithm: § 5.1.3 "The abort(reason) method steps are:"
    pub fn call_abort(self: *WritableStream, reason: webidl.Optional(webidl.JSValue)) webidl.Promise(void) {
        // Step 1: If ! IsWritableStreamLocked(this) is true,
        // return a promise rejected with a TypeError exception.
        if (self.isLocked()) {
            return webidl.Promise(void).rejected("Stream is locked");
        }

        const reason_value = if (reason.was_passed)
            common.JSValue.fromWebIDL(reason.value)
        else
            null;

        // Step 2: Return ! WritableStreamAbort(this, reason).
        const internal_promise = self.abortInternal(reason_value);

        // Convert internal promise to webidl promise
        if (internal_promise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else {
            // Convert internal JSValue error to string for webidl Promise
            const err_str = if (internal_promise.error_value) |ev| switch (ev) {
                .string => |s| s,
                else => "Unknown error",
            } else "Unknown error";
            return webidl.Promise(void).rejected(err_str);
        }
    }
    /// Closes the stream.
    /// 
    /// IDL: Promise<undefined> close();
    /// 
    /// Spec algorithm: § 5.1.3 "The close() method steps are:"
    pub fn call_close(self: *WritableStream) webidl.Promise(void) {
        // Step 1: If ! IsWritableStreamLocked(this) is true,
        // return a promise rejected with a TypeError exception.
        if (self.isLocked()) {
            return webidl.Promise(void).rejected("Stream is locked");
        }

        // Step 2: If ! WritableStreamCloseQueuedOrInFlight(this) is true,
        // return a promise rejected with a TypeError exception.
        if (self.closeQueuedOrInFlight()) {
            return webidl.Promise(void).rejected("Close already queued");
        }

        // Step 3: Return ! WritableStreamClose(this).
        const internal_promise = self.closeInternal();

        // Convert internal promise to webidl promise
        if (internal_promise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else {
            // Convert internal JSValue error to string for webidl Promise
            const err_str = if (internal_promise.error_value) |ev| switch (ev) {
                .string => |s| s,
                else => "Unknown error",
            } else "Unknown error";
            return webidl.Promise(void).rejected(err_str);
        }
    }
    /// Gets a writer for the stream.
    /// 
    /// IDL: WritableStreamDefaultWriter getWriter();
    /// 
    /// Spec algorithm: § 5.1.3 "The getWriter() method steps are:"
    pub fn call_getWriter(self: *WritableStream) !webidl.JSValue {
        // Use the stream's event loop (borrowed reference)
        const loop = self.event_loop;

        // Step 1: Return ? AcquireWritableStreamDefaultWriter(this).
        const writer = try self.acquireDefaultWriter(loop);

        // Return as JSValue (would be proper WebIDL type in full implementation)
        _ = writer;
        return webidl.JSValue{ .undefined = {} };
    }
    /// Check if stream is locked
    /// 
    /// Spec: § 5.1.4 "IsWritableStreamLocked(stream)"
    pub fn isLocked(self: *const WritableStream) bool {
        // Step 1: If stream.[[writer]] is undefined, return false.
        // Step 2: Return true.
        return switch (self.writer) {
            .none => false,
            else => true,
        };
    }
    /// Fix controller's stream pointer after stream is in final location
    /// 
    /// IMPORTANT: Must be called after init() since init returns by value
    /// which means the stream gets copied to its final location after init returns.
    pub fn fixControllerPointer(self: *WritableStream) void {
        self.controller.stream = @ptrCast(self);
    }
    /// Add a write request to the queue
    /// 
    /// Spec: § 5.1.4 "WritableStreamAddWriteRequest(stream)"
    pub fn addWriteRequest(self: *WritableStream, loop: event_loop.EventLoop) !*AsyncPromise(void) {
        // Step 1: Assert: ! IsWritableStreamLocked(stream) is true.
        // Step 2: Assert: stream.[[state]] is "writable".

        // Step 3: Let promise be a new promise.
        const promise = try AsyncPromise(void).init(self.allocator, loop);

        // Step 4: Append promise to stream.[[writeRequests]].
        try self.write_requests.append(self.allocator, promise);

        // Step 5: Return promise.
        return promise;
    }
    /// Check if close is queued or in flight
    /// 
    /// Spec: § 5.1.4 "WritableStreamCloseQueuedOrInFlight(stream)"
    pub fn closeQueuedOrInFlight(self: *const WritableStream) bool {
        // Step 1: If stream.[[closeRequest]] is undefined and
        // stream.[[inFlightCloseRequest]] is undefined, return false.
        // Step 2: Return true.
        return self.close_request != null or self.in_flight_close_request != null;
    }
    /// Internal abort implementation
    /// 
    /// Spec: § 5.1.4 "WritableStreamAbort(stream, reason)"
    pub fn abortInternal(self: *WritableStream, reason: ?common.JSValue) common.Promise(void) {
        // Step 1: If stream.[[state]] is "closed" or "errored", return a promise resolved with undefined.
        if (self.state == .closed or self.state == .errored) {
            return common.Promise(void).fulfilled({});
        }

        // Step 2: Signal abort to any underlying sink via the abort algorithm.
        // Step 3: Let state be stream.[[state]].
        // Step 4-8: Complex state management for aborting

        // Simplified: Just call controller's abort algorithm
        const abort_promise = self.controller.abortSteps(reason) catch {
            return common.Promise(void).rejected(common.JSValue{ .string = "Abort failed" });
        };
        defer abort_promise.deinit();

        // Mark as closed
        self.state = .closed;

        // Convert async promise to synchronous promise
        // In production, this would properly integrate with the event loop
        return switch (abort_promise.state) {
            .fulfilled => common.Promise(void).fulfilled({}),
            .rejected => |err_value| common.Promise(void).rejected(err_value),
            .pending => common.Promise(void).pending(),
        };
    }
    /// Internal close implementation
    /// 
    /// Spec: § 5.1.4 "WritableStreamClose(stream)"
    fn closeInternal(self: *WritableStream) common.Promise(void) {
        // Step 1: Let state be stream.[[state]].
        // Step 2: Assert: state is "writable" or "erroring".

        // Step 3: Return a new promise, and run the following steps:
        // (Simplified for now)

        // Mark close as requested
        self.close_request = common.Promise(void).pending();

        // In full implementation, would process queue and call close algorithm
        self.state = .closed;

        return common.Promise(void).fulfilled({});
    }
    /// Acquire a default writer
    /// 
    /// Spec: § 5.1.4 "AcquireWritableStreamDefaultWriter(stream)"
    pub fn acquireDefaultWriter(self: *WritableStream, loop: event_loop.EventLoop) !*WritableStreamDefaultWriter {
        // Step 1: Let writer be a new WritableStreamDefaultWriter.
        const writer = try self.allocator.create(WritableStreamDefaultWriter);
        errdefer self.allocator.destroy(writer);

        writer.* = try WritableStreamDefaultWriter.init(self.allocator, @ptrCast(self), loop);

        // Step 2: Set stream.[[writer]] to writer.
        self.writer = Writer{ .default = writer };

        // Step 3-5: Set up writer promises and state
        // (Already done in writer.init)

        // Step 6: Return writer.
        return writer;
    }
    /// Update backpressure state and writer's ready promise
    /// 
    /// Spec: § 5.1.4 "WritableStreamUpdateBackpressure(stream, backpressure)"
    /// 
    /// This algorithm is called when the stream's backpressure state changes,
    /// typically when the queue size crosses the high water mark threshold.
    /// 
    /// Arguments:
    /// - backpressure: true if applying backpressure, false if clearing it
    /// 
    /// Example usage:
    /// ```zig
    /// // When queue gets full:
    /// try stream.updateBackpressure(true);  // Writer's ready promise becomes pending
    /// 
    /// // When queue drains:
    /// try stream.updateBackpressure(false); // Writer's ready promise fulfills
    /// ```
    pub fn updateBackpressure(self: *WritableStream, backpressure: bool) !void {
        // Step 1: Assert: stream.[[state]] is "writable".
        // (In practice, we should only update backpressure when writable)

        // Step 2: Assert: ! WritableStreamCloseQueuedOrInFlight(stream) is false.
        // (Backpressure doesn't apply when closing)

        // Step 3: Let writer be stream.[[writer]].
        // Step 4: If writer is not undefined and backpressure is not stream.[[backpressure]]:
        if (self.backpressure != backpressure) {
            switch (self.writer) {
                .default => |writer| {
                    // Update the writer's ready promise based on new backpressure state
                    try writer.updateReadyPromise(backpressure);
                },
                .none => {
                    // No writer - just update backpressure flag
                },
            }

            // Step 5: Set stream.[[backpressure]] to backpressure.
            self.backpressure = backpressure;
        }
    }
    /// Check if a write or close operation is marked in flight
    /// 
    /// Spec: § 5.1.4 "WritableStreamHasOperationMarkedInFlight(stream)"
    pub fn hasOperationMarkedInFlight(self: *const WritableStream) bool {
        // Step 1: If stream.[[inFlightWriteRequest]] is undefined and
        // stream.[[inFlightCloseRequest]] is undefined, return false.
        // Step 2: Return true.
        return self.in_flight_write_request != null or self.in_flight_close_request != null;
    }
    /// Mark the first write request as in-flight
    /// 
    /// Spec: § 5.1.4 "WritableStreamMarkFirstWriteRequestInFlight(stream)"
    pub fn markFirstWriteRequestInFlight(self: *WritableStream) void {
        // Step 1: Assert: stream.[[inFlightWriteRequest]] is undefined.
        // Step 2: Assert: stream.[[writeRequests]] is not empty.

        // Step 3: Let writeRequest be the first element of stream.[[writeRequests]].
        // Step 4: Remove writeRequest from stream.[[writeRequests]].
        if (self.write_requests.items.len > 0) {
            const write_request = self.write_requests.orderedRemove(0);

            // Step 5: Set stream.[[inFlightWriteRequest]] to writeRequest.
            // Note: We store the promise in the in_flight slot
            // The promise itself will be fulfilled/rejected by the controller
            self.in_flight_write_request = common.Promise(void).pending();

            // Store reference to async promise for later fulfillment
            // In full implementation, we'd track the AsyncPromise pointer
            _ = write_request;
        }
    }
    /// Mark close request as in-flight
    /// 
    /// Spec: § 5.1.4 "WritableStreamMarkCloseRequestInFlight(stream)"
    pub fn markCloseRequestInFlight(self: *WritableStream) void {
        // Step 1: Assert: stream.[[inFlightCloseRequest]] is undefined.
        // Step 2: Assert: stream.[[closeRequest]] is not undefined.

        // Step 3: Set stream.[[inFlightCloseRequest]] to stream.[[closeRequest]].
        if (self.close_request) |close_req| {
            self.in_flight_close_request = close_req;

            // Step 4: Set stream.[[closeRequest]] to undefined.
            self.close_request = null;
        }
    }
    /// Finish in-flight write successfully
    /// 
    /// Spec: § 5.1.4 "WritableStreamFinishInFlightWrite(stream)"
    pub fn finishInFlightWrite(self: *WritableStream) void {
        // Step 1: Assert: stream.[[inFlightWriteRequest]] is not undefined.

        // Step 2: Resolve stream.[[inFlightWriteRequest]] with undefined.
        // (Promise already resolved by caller)

        // Step 3: Set stream.[[inFlightWriteRequest]] to undefined.
        self.in_flight_write_request = null;
    }
    /// Finish in-flight write with error
    /// 
    /// Spec: § 5.1.4 "WritableStreamFinishInFlightWriteWithError(stream, error)"
    pub fn finishInFlightWriteWithError(self: *WritableStream, error_value: common.JSValue) void {
        // Step 1: Assert: stream.[[inFlightWriteRequest]] is not undefined.

        // Step 2: Reject stream.[[inFlightWriteRequest]] with error.
        // (Promise already rejected by caller)

        // Step 3: Set stream.[[inFlightWriteRequest]] to undefined.
        self.in_flight_write_request = null;

        // Step 4: Assert: stream.[[state]] is "writable" or "erroring".

        // Step 5: Perform ! WritableStreamDealWithRejection(stream, error).
        self.dealWithRejection(error_value);
    }
    /// Finish in-flight close successfully
    /// 
    /// Spec: § 5.1.4 "WritableStreamFinishInFlightClose(stream)"
    pub fn finishInFlightClose(self: *WritableStream) void {
        // Step 1: Assert: stream.[[inFlightCloseRequest]] is not undefined.

        // Step 2: Resolve stream.[[inFlightCloseRequest]] with undefined.
        // (Promise already resolved by caller)

        // Step 3: Set stream.[[inFlightCloseRequest]] to undefined.
        self.in_flight_close_request = null;

        // Step 4: Let state be stream.[[state]].
        const state = self.state;

        // Step 5: Assert: stream.[[state]] is "writable" or "erroring".

        // Step 6: If state is "erroring",
        if (state == .erroring) {
            // Step 6.1: Set stream.[[storedError]] to undefined.
            self.stored_error = null;

            // Step 6.2: If stream.[[pendingAbortRequest]] is not undefined,
            if (self.pending_abort_request) |abort_req| {
                // Step 6.2.1: Resolve stream.[[pendingAbortRequest]].promise with undefined.
                // (Promise handled externally)

                // Step 6.2.2: Set stream.[[pendingAbortRequest]] to undefined.
                _ = abort_req;
                self.pending_abort_request = null;
            }
        }

        // Step 7: Set stream.[[state]] to "closed".
        self.state = .closed;

        // Step 8: Let writer be stream.[[writer]].
        // Step 9: If writer is not undefined, resolve writer.[[closedPromise]] with undefined.
        switch (self.writer) {
            .default => |writer| {
                writer.closed_promise.fulfill({});
            },
            .none => {},
        }
    }
    /// Finish in-flight close with error
    /// 
    /// Spec: § 5.1.4 "WritableStreamFinishInFlightCloseWithError(stream, error)"
    pub fn finishInFlightCloseWithError(self: *WritableStream, error_value: common.JSValue) void {
        // Step 1: Assert: stream.[[inFlightCloseRequest]] is not undefined.

        // Step 2: Reject stream.[[inFlightCloseRequest]] with error.
        // (Promise already rejected by caller)

        // Step 3: Set stream.[[inFlightCloseRequest]] to undefined.
        self.in_flight_close_request = null;

        // Step 4: Assert: stream.[[state]] is "writable" or "erroring".

        // Step 5: If stream.[[pendingAbortRequest]] is not undefined,
        if (self.pending_abort_request) |abort_req| {
            // Step 5.1: Reject stream.[[pendingAbortRequest]].promise with error.
            // (Promise handled externally)

            // Step 5.2: Set stream.[[pendingAbortRequest]] to undefined.
            _ = abort_req;
            self.pending_abort_request = null;
        }

        // Step 6: Perform ! WritableStreamDealWithRejection(stream, error).
        self.dealWithRejection(error_value);
    }
    /// Finish erroring state transition
    /// 
    /// Spec: § 5.1.4 "WritableStreamFinishErroring(stream)"
    pub fn finishErroring(self: *WritableStream) void {
        // Step 1: Assert: stream.[[state]] is "erroring".
        // Step 2: Assert: ! WritableStreamHasOperationMarkedInFlight(stream) is false.

        // Step 3: Set stream.[[state]] to "errored".
        self.state = .errored;

        // Step 4: Perform ! stream.[[controller]].[[ErrorSteps]]().
        // (Controller error steps - clear algorithms)
        // This is handled by WritableStreamDefaultControllerClearAlgorithms

        // Step 5: Let storedError be stream.[[storedError]].
        const stored_error = self.stored_error orelse common.JSValue{ .string = "Stream errored" };

        // Step 6: For each writeRequest of stream.[[writeRequests]]:
        while (self.write_requests.items.len > 0) {
            const write_request = self.write_requests.orderedRemove(0);

            // Step 6.1: Reject writeRequest with storedError.
            write_request.reject(stored_error);

            // Clean up the promise
            write_request.deinit();
        }

        // Step 7: Set stream.[[writeRequests]] to an empty list.
        // (Already done by removing all items)

        // Step 8: If stream.[[pendingAbortRequest]] is undefined,
        if (self.pending_abort_request == null) {
            // Step 8.1: Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).
            self.rejectCloseAndClosedPromiseIfNeeded();
            // Step 8.2: Return.
            return;
        }

        // Step 9: Let abortRequest be stream.[[pendingAbortRequest]].
        // Step 10: Set stream.[[pendingAbortRequest]] to undefined.
        if (self.pending_abort_request) |abort_req| {
            self.pending_abort_request = null;

            // Step 11: If abortRequest.wasAlreadyErroring is true,
            if (abort_req.was_already_erroring) {
                // Step 11.1: Reject abortRequest.promise with storedError.
                // (Promise handled externally)

                // Step 11.2: Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).
                self.rejectCloseAndClosedPromiseIfNeeded();
                // Step 11.3: Return.
                return;
            }

            // Step 12: Let promise be ! stream.[[controller]].[[AbortSteps]](abortRequest.reason).
            // Step 13: Upon fulfillment of promise,
            //     Step 13.1: Resolve abortRequest.promise with undefined.
            //     Step 13.2: Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).
            // Step 14: Upon rejection of promise with reason reason,
            //     Step 14.1: Reject abortRequest.promise with reason.
            //     Step 14.2: Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).

            // Simplified: Just reject close and closed promise
            self.rejectCloseAndClosedPromiseIfNeeded();
        }
    }
    /// Deal with rejection by transitioning to erroring/errored state
    /// 
    /// Spec: § 5.1.4 "WritableStreamDealWithRejection(stream, error)"
    fn dealWithRejection(self: *WritableStream, error_value: common.JSValue) void {
        // Step 1: Let state be stream.[[state]].
        const state = self.state;

        // Step 2: If state is "writable",
        if (state == .writable) {
            // Step 2.1: Perform ! WritableStreamStartErroring(stream, error).
            self.startErroring(error_value);
            // Step 2.2: Return.
            return;
        }

        // Step 3: Assert: state is "erroring".
        // Step 4: Perform ! WritableStreamFinishErroring(stream).
        self.finishErroring();
    }
    /// Start erroring state transition
    /// 
    /// Spec: § 5.1.4 "WritableStreamStartErroring(stream, reason)"
    fn startErroring(self: *WritableStream, reason: common.JSValue) void {
        // Step 1: Assert: stream.[[storedError]] is undefined.
        // Step 2: Assert: stream.[[state]] is "writable".

        // Step 3: Let controller be stream.[[controller]].
        // Step 4: Assert: controller is not undefined.

        // Step 5: Set stream.[[state]] to "erroring".
        self.state = .erroring;

        // Step 6: Set stream.[[storedError]] to reason.
        self.stored_error = reason;

        // Step 7: Let writer be stream.[[writer]].
        // Step 8: If writer is not undefined, perform ! WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason).
        switch (self.writer) {
            .default => |writer| {
                if (writer.ready_promise) |promise| {
                    promise.reject(reason);
                }
            },
            .none => {},
        }

        // Step 9: If ! WritableStreamHasOperationMarkedInFlight(stream) is false and
        // controller.[[started]] is true, perform ! WritableStreamFinishErroring(stream).
        if (!self.hasOperationMarkedInFlight() and self.controller.started) {
            self.finishErroring();
        }
    }
    /// Reject close and closed promises if needed
    /// 
    /// Spec: § 5.1.4 "WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream)"
    fn rejectCloseAndClosedPromiseIfNeeded(self: *WritableStream) void {
        // Step 1: Assert: stream.[[state]] is "errored".

        // Step 2: If stream.[[closeRequest]] is not undefined,
        if (self.close_request) |_| {
            // Step 2.1: Assert: stream.[[inFlightCloseRequest]] is undefined.

            // Step 2.2: Reject stream.[[closeRequest]] with stream.[[storedError]].
            // (Promise handled externally)

            // Step 2.3: Set stream.[[closeRequest]] to undefined.
            self.close_request = null;
        }

        // Step 3: Let writer be stream.[[writer]].
        // Step 4: If writer is not undefined,
        switch (self.writer) {
            .default => |writer| {
                // Step 4.1: Reject writer.[[closedPromise]] with stream.[[storedError]].
                const error_value = self.stored_error orelse common.JSValue{ .string = "Stream errored" };
                writer.closed_promise.reject(error_value);

                // Step 4.2: Set writer.[[closedPromise]].[[PromiseIsHandled]] to true.
                // (Not implemented - promise handling internal detail)
            },
            .none => {},
        }
    }
};


// ============================================================================
// WritableStream Tests
// ============================================================================

test "WritableStream - initialization creates writable state" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    try std.testing.expectEqual(StreamState.writable, stream.state);
    try std.testing.expect(!stream.get_locked());
}

test "WritableStream - getWriter acquires lock" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    // Not locked initially
    try std.testing.expect(!stream.get_locked());

    // Create event loop for writer
    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    // Acquire writer
    const writer = try stream.acquireDefaultWriter(loop.eventLoop());
    defer writer.call_releaseLock(); // releaseLock() frees the writer

    // Now locked
    try std.testing.expect(stream.get_locked());
}

test "WritableStream - multiple getWriter calls fail when locked" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    // First writer succeeds
    const writer1 = try stream.acquireDefaultWriter(loop.eventLoop());
    defer {
        writer1.call_releaseLock();
        writer1.deinit();
        allocator.destroy(writer1);
    }

    // Second writer should fail
    const result = stream.acquireDefaultWriter(loop.eventLoop());
    try std.testing.expectError(error.StreamLocked, result);
}

test "WritableStream - writer releaseLock unlocks stream" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    const writer = try stream.acquireDefaultWriter(loop.eventLoop());
    try std.testing.expect(stream.get_locked());

    writer.call_releaseLock(); // releaseLock() now frees the writer automatically
    try std.testing.expect(!stream.get_locked());
}

test "WritableStream - write queues chunk when not flowing" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    const writer = try stream.acquireDefaultWriter(loop.eventLoop());
    defer writer.call_releaseLock(); // releaseLock() frees the writer

    // Write a chunk
    const write_promise = try writer.call_write(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "test chunk" },
    });
    defer write_promise.deinit();

    // Write should be queued (controller processes it)
    // Note: In test mode, writes settle synchronously
    try std.testing.expect(!stream.controller.queue.isEmpty());
}

test "WritableStream - close transitions to closed state" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    const writer = try stream.acquireDefaultWriter(loop.eventLoop());
    defer writer.call_releaseLock(); // releaseLock() frees the writer

    // Close the stream
    const close_promise = writer.call_close();

    // Should be closed (or closing)
    // Note: In test mode, close settles synchronously
    // Sync promise doesn't need deinit
    _ = close_promise;
    try std.testing.expect(stream.state == StreamState.closed or stream.state == StreamState.writable);
}

test "WritableStream - abort transitions to errored state" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    // Abort with reason
    const abort_result = stream.call_abort(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "test abort" },
    });

    // Should transition to errored
    try std.testing.expect(stream.state == .errored or stream.state == .erroring);
    try std.testing.expect(abort_result.isFulfilled() or abort_result.isPending());
}

test "WritableStream - desiredSize reflects backpressure" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    const writer = try stream.acquireDefaultWriter(loop.eventLoop());
    defer writer.call_releaseLock(); // releaseLock() frees the writer

    // Get desired size
    const desired_size = writer.get_desiredSize();

    // Should have some capacity (placeholder always returns > 0)
    if (desired_size) |size| {
        try std.testing.expect(size > 0.0);
    } else {
        // null means closed/errored
        try std.testing.expect(false);
    }
}

test "WritableStream - write after close fails" {
    const allocator = std.testing.allocator;

    var stream = try WritableStream.init(allocator);
    stream.fixControllerPointer();
    defer stream.deinit();

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    const writer = try stream.acquireDefaultWriter(loop.eventLoop());
    defer writer.call_releaseLock(); // releaseLock() frees the writer

    // Close the stream
    _ = writer.call_close();

    // Try to write after close - should fail because stream is closing/closed
    // Note: call_write returns error union, not promise, when stream is not writable
    const result = writer.call_write(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "should fail" },
    });

    // Should either return error or return rejected promise
    if (result) |promise| {
        // Got a promise - it should be rejected
        // Sync promise doesn't need deinit
        try std.testing.expect(promise.isRejected() or promise.isPending());
    } else |err| {
        // Got an error directly - that's also acceptable
        try std.testing.expectEqual(error.StreamClosed, err);
    }
}
