// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! ReadableStreamDefaultController class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#rs-default-controller-class
//! IDL: specs/streams.idl lines 97-103
//!
//! Controls a ReadableStream's state and internal queue.

const std = @import("std");
const webidl = @import("webidl");
const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
const common = @import("common");
const event_loop = @import("event_loop");
const AsyncPromise = @import("async_promise").AsyncPromise;
/// ReadableStreamDefaultController zoop class
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface ReadableStreamDefaultController {
/// readonly attribute unrestricted double? desiredSize;
/// undefined close();
/// undefined enqueue(optional any chunk);
/// undefined error(optional any e);
/// };
/// ```
pub const ReadableStreamDefaultController = struct {
    allocator: std.mem.Allocator,
    /// [[cancelAlgorithm]]: Promise-returning algorithm for cancelation
    cancel_algorithm: common.CancelAlgorithm,
    /// [[closeRequested]]: boolean - stream closed by source but has queued chunks
    close_requested: bool,
    /// [[pullAgain]]: boolean - pull requested but previous pull still executing
    pull_again: bool,
    /// [[pullAlgorithm]]: Promise-returning algorithm for pulling data
    pull_algorithm: common.PullAlgorithm,
    /// [[pulling]]: boolean - pull algorithm currently executing
    pulling: bool,
    /// [[queue]]: Queue-with-sizes for internal chunk queue
    queue: QueueWithSizes,
    /// [[started]]: boolean - underlying source has finished starting
    started: bool,
    /// [[strategyHWM]]: High water mark for backpressure
    strategy_hwm: f64,
    /// [[strategySizeAlgorithm]]: Algorithm to calculate chunk size
    strategy_size_algorithm: common.SizeAlgorithm,
    /// [[stream]]: The ReadableStream instance controlled (will be a pointer in full implementation)
    stream: ?*anyopaque,
    /// Event loop for async operations
    event_loop: event_loop.EventLoop,

    /// Initialize a new controller (internal - not exposed via WebIDL)
    pub fn init(
        allocator: std.mem.Allocator,
        cancel_algorithm: common.CancelAlgorithm,
        pull_algorithm: common.PullAlgorithm,
        strategy_hwm: f64,
        strategy_size_algorithm: common.SizeAlgorithm,
        loop: event_loop.EventLoop,
    ) ReadableStreamDefaultController {
        return .{
            .allocator = allocator,
            .cancel_algorithm = cancel_algorithm,
            .close_requested = false,
            .pull_again = false,
            .pull_algorithm = pull_algorithm,
            .pulling = false,
            .queue = QueueWithSizes.init(allocator),
            .started = false,
            .strategy_hwm = strategy_hwm,
            .strategy_size_algorithm = strategy_size_algorithm,
            .stream = null,
            .event_loop = loop,
        };
    }
    pub fn deinit(self: *ReadableStreamDefaultController) void {
        self.queue.deinit();
    }
    /// Returns the desired size to fill the stream's internal queue.
    /// 
    /// IDL: readonly attribute unrestricted double? desiredSize;
    /// 
    /// Spec algorithm: § 4.6.3 "The desiredSize getter steps are:"
    pub fn get_desiredSize(self: *const ReadableStreamDefaultController) ?f64 {
        // Step 1: Return ! ReadableStreamDefaultControllerGetDesiredSize(this).
        return self.calculateDesiredSize();
    }
    /// Calculate desired size (internal helper)
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerGetDesiredSize(controller)"
    pub fn calculateDesiredSize(self: *const ReadableStreamDefaultController) ?f64 {
        // If stream is closed, return 0
        if (self.close_requested and self.queue.isEmpty()) {
            return 0.0;
        }

        // Return highWaterMark - queueTotalSize
        return self.strategy_hwm - self.queue.queue_total_size;
    }
    /// Closes the controlled readable stream.
    /// 
    /// IDL: undefined close();
    /// 
    /// Spec algorithm: § 4.6.3 "The close() method steps are:"
    pub fn call_close(self: *ReadableStreamDefaultController) !void {
        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false,
        // throw a TypeError exception.
        if (!self.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        // Step 2: Perform ! ReadableStreamDefaultControllerClose(this).
        self.closeInternal();
    }
    /// Enqueues the given chunk in the controlled readable stream.
    /// 
    /// IDL: undefined enqueue(optional any chunk);
    /// 
    /// Spec algorithm: § 4.6.3 "The enqueue(chunk) method steps are:"
    pub fn call_enqueue(self: *ReadableStreamDefaultController, chunk: webidl.Optional(webidl.JSValue)) !void {
        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false,
        // throw a TypeError exception.
        if (!self.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        const chunk_value = if (chunk.was_passed) chunk.value else webidl.JSValue{ .undefined = {} };

        // Step 2: Perform ? ReadableStreamDefaultControllerEnqueue(this, chunk).
        try self.enqueueInternal(chunk_value);
    }
    /// Errors the controlled readable stream.
    /// 
    /// IDL: undefined error(optional any e);
    /// 
    /// Spec algorithm: § 4.6.3 "The error(e) method steps are:"
    pub fn call_error(self: *ReadableStreamDefaultController, e: webidl.Optional(webidl.JSValue)) void {
        // Step 1: Perform ! ReadableStreamDefaultControllerError(this, e).
        const error_value = if (e.was_passed) e.value else webidl.JSValue{ .undefined = {} };
        self.errorInternal(error_value);
    }
    /// Check if controller can close or enqueue
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)"
    fn canCloseOrEnqueue(self: *const ReadableStreamDefaultController) bool {
        // Cannot close or enqueue if already close requested
        return !self.close_requested;
    }
    /// Close the controller
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerClose(controller)"
    fn closeInternal(self: *ReadableStreamDefaultController) void {
        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
        if (!self.canCloseOrEnqueue()) {
            return;
        }

        // Step 2: Set controller.[[closeRequested]] to true.
        self.close_requested = true;

        // Step 3: If controller.[[queue]] is empty,
        if (self.queue.isEmpty()) {
            // Step 3.1: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
            self.clearAlgorithms();

            // Step 3.2: Perform ! ReadableStreamClose(stream).
            if (self.stream) |stream_ptr| {
                const ReadableStream = @import("readable_stream").ReadableStream;
                const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

                // Fulfill all pending read requests with done=true
                switch (stream.reader) {
                    .none => {},
                    .default => |reader| {
                        while (reader.read_requests.items.len > 0) {
                            const promise = reader.read_requests.orderedRemove(0);
                            promise.fulfill(.{
                                .value = null,
                                .done = true,
                            });
                        }
                    },
                    .byob => {}, // TODO: BYOB reader fulfillment (Phase 3)
                }

                stream.closeInternal();
            }
        }
    }
    /// Enqueue a chunk
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerEnqueue(controller, chunk)"
    pub fn enqueueInternal(self: *ReadableStreamDefaultController, chunk: webidl.JSValue) !void {
        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
        if (!self.canCloseOrEnqueue()) {
            return;
        }

        // Step 2: Let stream be controller.[[stream]].
        const ReadableStream = @import("readable_stream").ReadableStream;

        // Step 3: If ! IsReadableStreamLocked(stream) is true and
        //         ! ReadableStreamGetNumReadRequests(stream) > 0,
        //         perform ! ReadableStreamFulfillReadRequest(stream, chunk, false).
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Check if stream has a reader with pending read requests
            if (stream.isLocked()) {
                const num_requests = stream.getNumReadRequests();
                if (num_requests > 0) {
                    // Fulfill the first pending read request immediately
                    stream.fulfillReadRequest(common.JSValue.fromWebIDL(chunk), false);
                    return;
                }
            }
        }

        // Step 4: Otherwise, enqueue the chunk
        // Step 4.1: Let result be the result of performing controller.[[strategySizeAlgorithm]]
        const chunk_value = common.JSValue.fromWebIDL(chunk);
        const chunk_size = self.strategy_size_algorithm.call(chunk_value);

        // Step 4.2-4.3: If result is an abrupt completion, error the controller
        // (In Zig, error handling is through the try mechanism)

        // Convert common.JSValue to queue Value for storage
        const QueueValue = @import("queue_with_sizes").Value;
        const queue_value: QueueValue = switch (chunk_value) {
            .undefined => .undefined,
            .null => .null,
            .boolean => |b| .{ .number = if (b) 1.0 else 0.0 }, // Convert boolean to number
            .number => |n| .{ .number = n },
            .string => |s| .{ .string = s },
            .bytes => |b| .{ .bytes = b },
            .object => .undefined, // Objects stored as undefined for now
            .close_sentinel => .close_sentinel, // Pass through close sentinel
        };

        // Step 4.4: Let enqueueResult be EnqueueValueWithSize(controller, chunk, chunkSize).
        self.queue.enqueueValueWithSize(queue_value, chunk_size) catch |err| {
            // Step 4.5: If enqueueResult is an abrupt completion,
            //           perform ! ReadableStreamDefaultControllerError(controller, enqueueResult.[[Value]]).
            self.errorInternal(webidl.JSValue{ .string = "Enqueue failed" });
            return err;
        };

        // Step 5: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
        self.callPullIfNeeded();
    }
    /// Error the controller
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerError(controller, e)"
    pub fn errorInternal(self: *ReadableStreamDefaultController, e: webidl.JSValue) void {
        // Step 1: Let stream be controller.[[stream]].
        if (self.stream == null) {
            return;
        }

        // Cast to ReadableStream to check state
        const ReadableStream = @import("readable_stream").ReadableStream;
        const stream: *ReadableStream = @ptrCast(@alignCast(self.stream.?));

        // Step 2: If stream.[[state]] is not "readable", return.
        if (stream.state != .readable) {
            return;
        }

        // Step 3: Perform ! ResetQueue(controller).
        self.queue.resetQueue();

        // Step 4: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
        self.clearAlgorithms();

        // Step 5: Perform ! ReadableStreamError(stream, e).
        stream.errorStream(common.JSValue.fromWebIDL(e));
    }
    /// Clear all algorithm references
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerClearAlgorithms(controller)"
    pub fn clearAlgorithms(self: *ReadableStreamDefaultController) void {
        // Reset algorithms to defaults to allow GC
        self.cancel_algorithm = common.defaultCancelAlgorithm();
        self.pull_algorithm = common.defaultPullAlgorithm();
        self.strategy_size_algorithm = common.defaultSizeAlgorithm();
    }
    /// Call pull if needed
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerCallPullIfNeeded(controller)"
    pub fn callPullIfNeeded(self: *ReadableStreamDefaultController) void {
        // Step 1: Let shouldPull be ! ReadableStreamDefaultControllerShouldCallPull(controller).
        const should_pull = self.shouldCallPull();

        // Step 2: If shouldPull is false, return.
        if (!should_pull) {
            return;
        }

        // Step 3: If controller.[[pulling]] is true,
        if (self.pulling) {
            // Step 3.1: Set controller.[[pullAgain]] to true.
            self.pull_again = true;
            // Step 3.2: Return.
            return;
        }

        // Step 4: Assert: controller.[[pullAgain]] is false.
        // (Implicit)

        // Step 5: Set controller.[[pulling]] to true.
        self.pulling = true;

        // Step 6: Let pullPromise be the result of performing controller.[[pullAlgorithm]].
        const pull_promise = self.pull_algorithm.call();

        // Step 7-9: Upon fulfillment/rejection, update pulling state
        // Convert sync promise to async and schedule completion as microtask
        const async_promise = AsyncPromise(void).init(self.allocator, self.event_loop) catch {
            // Failed to create promise - just clear pulling flag
            self.pulling = false;
            return;
        };

        if (pull_promise.isFulfilled()) {
            async_promise.fulfill({});
        } else if (pull_promise.isRejected()) {
            async_promise.reject(pull_promise.error_value orelse common.JSValue{ .string = "Pull failed" });
        } else {
            async_promise.fulfill({}); // Pending treated as fulfilled for now
        }

        // Schedule pull completion handler as microtask
        const PullContext = struct {
            controller: *ReadableStreamDefaultController,
            promise: *AsyncPromise(void),
        };

        const context = self.allocator.create(PullContext) catch {
            async_promise.deinit();
            self.pulling = false;
            return;
        };
        context.* = .{
            .controller = self,
            .promise = async_promise,
        };

        // Use onSettleCtx() to avoid creating leaked chained promises
        async_promise.onSettleCtx(
            struct {
                fn onFulfilled(ctx: *anyopaque, _: void) !void {
                    const c: *PullContext = @ptrCast(@alignCast(ctx));

                    // Clean up resources
                    defer c.controller.allocator.destroy(c);
                    defer c.promise.deinit();

                    c.controller.pulling = false;
                    if (c.controller.pull_again) {
                        c.controller.pull_again = false;
                        c.controller.callPullIfNeeded();
                    }
                }
            }.onFulfilled,
            null,
            context,
        ) catch {
            self.allocator.destroy(context);
            async_promise.deinit();
            self.pulling = false;
            return;
        };
    }
    /// Check if should call pull
    /// 
    /// Spec: § 4.6.4 "ReadableStreamDefaultControllerShouldCallPull(controller)"
    fn shouldCallPull(self: *const ReadableStreamDefaultController) bool {
        // Step 1: Let stream be controller.[[stream]].
        // Step 2: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return false.
        if (!self.canCloseOrEnqueue()) {
            return false;
        }

        // Step 3: If controller.[[started]] is false, return false.
        if (!self.started) {
            return false;
        }

        // Step 4-5: Check if stream has readers and desired size is positive
        // (Simplified for now - full implementation would check stream state)
        const desired_size = self.calculateDesiredSize() orelse return false;
        return desired_size > 0.0;
    }
    /// [[CancelSteps]](reason) - Called when stream is canceled
    /// 
    /// Spec: § 4.6.4 "[[CancelSteps]](reason)"
    pub fn cancelSteps(self: *ReadableStreamDefaultController, reason: ?common.JSValue) !*AsyncPromise(void) {
        // Step 1: Perform ! ResetQueue(this).
        self.queue.resetQueue();

        // Step 2: Let result be the result of performing this.[[cancelAlgorithm]], passing in reason.
        const result = self.cancel_algorithm.call(reason);

        // Step 3: Perform ! ReadableStreamDefaultControllerClearAlgorithms(this).
        self.clearAlgorithms();

        // Step 4: Return result (convert synchronous promise to async).
        const promise = try AsyncPromise(void).init(self.allocator, self.event_loop);
        if (result.isFulfilled()) {
            promise.fulfill({});
        } else if (result.isRejected()) {
            promise.reject(result.error_value orelse common.JSValue{ .string = "Cancel failed" });
        }
        return promise;
    }
};


// Tests

test "ReadableStreamDefaultController - enqueue with default size" {
    const allocator = std.testing.allocator;

    const TestEventLoop = @import("test_event_loop").TestEventLoop;
    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    var controller = ReadableStreamDefaultController.init(
        allocator,
        common.defaultCancelAlgorithm(),
        common.defaultPullAlgorithm(),
        10.0, // high water mark
        common.defaultSizeAlgorithm(), // Returns 1.0 for each chunk
        test_loop.eventLoop(),
    );
    defer controller.deinit();

    // Enqueue some chunks
    try controller.call_enqueue(.{ .was_passed = true, .value = webidl.JSValue{ .string = "abc" } });
    try controller.call_enqueue(.{ .was_passed = true, .value = webidl.JSValue{ .string = "defgh" } });

    // Verify queue has items
    try std.testing.expect(!controller.queue.isEmpty());

    // With default size algorithm, each chunk has size 1.0
    try std.testing.expectEqual(@as(f64, 2.0), controller.queue.queue_total_size); // 1.0 + 1.0

    // Verify desired size
    const desired = controller.get_desiredSize();
    try std.testing.expect(desired != null);
    try std.testing.expectEqual(@as(f64, 8.0), desired.?); // 10 - 2
}

test "ReadableStreamDefaultController - enqueue and callPullIfNeeded" {
    const allocator = std.testing.allocator;

    const TestEventLoop = @import("test_event_loop").TestEventLoop;
    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    var controller = ReadableStreamDefaultController.init(
        allocator,
        common.defaultCancelAlgorithm(),
        common.defaultPullAlgorithm(),
        1.0,
        common.defaultSizeAlgorithm(),
        test_loop.eventLoop(),
    );
    defer controller.deinit();

    // Mark as started so pull can be called
    controller.started = true;

    // Initially should not pull (queue is empty but we haven't enqueued yet)
    const should_pull_before = controller.shouldCallPull();
    try std.testing.expect(should_pull_before); // Should pull because queue is empty and started

    // Enqueue a chunk
    try controller.call_enqueue(.{ .was_passed = true, .value = webidl.JSValue{ .undefined = {} } });

    // Verify the chunk was enqueued
    try std.testing.expect(!controller.queue.isEmpty());

    // After enqueuing, pull might or might not be needed depending on HWM
    // With HWM of 1.0 and one item of size 1.0, we're at capacity
    const should_pull_after = controller.shouldCallPull();
    try std.testing.expect(!should_pull_after); // Should not pull because we're at HWM
}

test "ReadableStreamDefaultController - cannot enqueue after close requested" {
    const allocator = std.testing.allocator;

    const TestEventLoop = @import("test_event_loop").TestEventLoop;
    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    var controller = ReadableStreamDefaultController.init(
        allocator,
        common.defaultCancelAlgorithm(),
        common.defaultPullAlgorithm(),
        1.0,
        common.defaultSizeAlgorithm(),
        test_loop.eventLoop(),
    );
    defer controller.deinit();

    // Request close
    try controller.call_close();

    // Try to enqueue - should return TypeError
    const result = controller.call_enqueue(.{ .was_passed = true, .value = webidl.JSValue{ .string = "test" } });
    try std.testing.expectError(error.TypeError, result);

    // Queue should be empty
    try std.testing.expect(controller.queue.isEmpty());
}

test "Async pull algorithm - microtask scheduling" {
    const allocator = std.testing.allocator;
    const TestEventLoop = @import("test_event_loop").TestEventLoop;

    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    // Track if pull was executed
    const TestContext = struct {
        var pull_count: usize = 0;

        fn pullAlgorithm() common.Promise(void) {
            pull_count += 1;
            return common.Promise(void).fulfilled({});
        }
    };
    TestContext.pull_count = 0;

    var controller = ReadableStreamDefaultController.init(
        allocator,
        common.defaultCancelAlgorithm(),
        common.wrapPullCallback(&TestContext.pullAlgorithm),
        1.0, // High water mark
        common.defaultSizeAlgorithm(),
        test_loop.eventLoop(),
    );
    defer controller.deinit();

    // Mark as started so pull can be called
    controller.started = true;

    // Call pull - should schedule microtask
    controller.callPullIfNeeded();

    // Verify pull was called
    try std.testing.expectEqual(@as(usize, 1), TestContext.pull_count);

    // Verify pulling flag is set
    try std.testing.expect(controller.pulling);

    // Process microtasks - should clear pulling flag
    test_loop.eventLoop().runMicrotasks();

    // Verify pulling flag is cleared
    try std.testing.expect(!controller.pulling);

    // Run event loop to completion to clean up any remaining promises
    while (test_loop.pendingMicrotasks() > 0) {
        test_loop.eventLoop().runMicrotasks();
    }
}

test "Async pull algorithm - pullAgain flag" {
    const allocator = std.testing.allocator;
    const TestEventLoop = @import("test_event_loop").TestEventLoop;

    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    const TestContext = struct {
        var pull_count: usize = 0;

        fn pullAlgorithm() common.Promise(void) {
            pull_count += 1;
            return common.Promise(void).fulfilled({});
        }
    };
    TestContext.pull_count = 0;

    var controller = ReadableStreamDefaultController.init(
        allocator,
        common.defaultCancelAlgorithm(),
        common.wrapPullCallback(&TestContext.pullAlgorithm),
        1.0,
        common.defaultSizeAlgorithm(),
        test_loop.eventLoop(),
    );
    defer controller.deinit();
    controller.started = true;

    // Call pull first time
    controller.callPullIfNeeded();
    try std.testing.expectEqual(@as(usize, 1), TestContext.pull_count);
    try std.testing.expect(controller.pulling);

    // Call pull again while pulling - should set pullAgain
    controller.callPullIfNeeded();
    try std.testing.expectEqual(@as(usize, 1), TestContext.pull_count); // Not called again
    try std.testing.expect(controller.pull_again);

    // Process microtasks - should trigger second pull
    test_loop.eventLoop().runMicrotasks();

    // Verify second pull was called
    try std.testing.expectEqual(@as(usize, 2), TestContext.pull_count);
    try std.testing.expect(!controller.pull_again);

    // Process microtasks again to complete second pull
    test_loop.eventLoop().runMicrotasks();
    try std.testing.expect(!controller.pulling);

    // Run event loop to completion to clean up any remaining promises
    while (test_loop.pendingMicrotasks() > 0) {
        test_loop.eventLoop().runMicrotasks();
    }
}
