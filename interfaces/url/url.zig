// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! WebIDL URL Interface (Zoop Source)
//!
//! WHATWG URL Standard: https://url.spec.whatwg.org/#url-class
//! WebIDL: specs/url.idl lines 4-26
//!
//! This file will be processed by zoop-codegen to generate src/url.zig

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

// Internal imports (using named modules)
const URLRecord = @import("url_record").URLRecord;
const api_parser = @import("api_parser");
const url_serializer = @import("url_serializer");
const origin_module = @import("origin");
const host_serializer = @import("host_serializer");
const path_serializer = @import("path_serializer");
const basic_parser = @import("basic_parser");
const ParserState = @import("parser_state").ParserState;
const helpers = @import("helpers");
const percent_encoding = @import("percent_encoding");
const EncodeSet = @import("encode_sets").EncodeSet;

// Forward declaration (will be in same module after codegen)
const URLSearchParams = @import("url_search_params").URLSearchParams;
/// URL class per WebIDL spec (specs/url.idl lines 4-26)
/// 
/// interface URL {
/// constructor(USVString url, optional USVString base);
/// static URL? parse(USVString url, optional USVString base);
/// static boolean canParse(USVString url, optional USVString base);
/// stringifier attribute USVString href;
/// readonly attribute USVString origin;
/// attribute USVString protocol;
/// attribute USVString username;
/// attribute USVString password;
/// attribute USVString host;
/// attribute USVString hostname;
/// attribute USVString port;
/// attribute USVString pathname;
/// attribute USVString search;
/// [SameObject] readonly attribute URLSearchParams searchParams;
/// attribute USVString hash;
/// USVString toJSON();
/// };
pub const URL = struct {
    allocator: std.mem.Allocator,
    internal: URLRecord,
    search_params_ptr: *URLSearchParams,

    /// Constructor: new URL(url, base) (spec lines 1794-1817)
    pub fn init(allocator: std.mem.Allocator, url: webidl.USVString, base: ?webidl.USVString) !URL {
        // Convert UTF-16 to UTF-8 for internal processing
        const url_utf8 = try infra.string.utf16ToUtf8(allocator, url);
        defer allocator.free(url_utf8);

        var base_utf8: ?[]const u8 = null;
        defer if (base_utf8) |b| allocator.free(b);

        if (base) |base_str| {
            base_utf8 = try infra.string.utf16ToUtf8(allocator, base_str);
        }

        // Parse base URL if provided
        var parsed_base: ?URLRecord = null;
        errdefer if (parsed_base) |*pb| pb.deinit();

        if (base_utf8) |base_str| {
            parsed_base = api_parser.parseURL(allocator, base_str, null) catch {
                return error.TypeError;
            };
        }
        defer if (parsed_base) |*pb| pb.deinit();

        // Parse URL with base
        const parsed_base_ptr = if (parsed_base) |*pb| pb else null;
        var parsed_url = api_parser.parseURL(allocator, url_utf8, parsed_base_ptr) catch {
            return error.TypeError;
        };
        errdefer parsed_url.deinit();

        // Create URLSearchParams for query
        const query_str = parsed_url.query() orelse "";
        const search_params = try allocator.create(URLSearchParams);
        errdefer allocator.destroy(search_params);

        search_params.* = try URLSearchParams.initFromString(allocator, query_str);
        errdefer search_params.deinit();

        var self = URL{
            .allocator = allocator,
            .internal = parsed_url,
            .search_params_ptr = search_params,
        };

        // Link URLSearchParams back to URL
        search_params.linkToURL(&self);

        return self;
    }
    pub fn deinit(self: *URL) void {
        self.internal.deinit();
        self.search_params_ptr.deinit();
        self.allocator.destroy(self.search_params_ptr);
    }
    /// Internal helper: Get href as UTF-8 for internal operations
    fn getHrefUtf8(self: *const URL) ![]const u8 {
        return url_serializer.serialize(self.allocator, &self.internal, false);
    }
    /// Internal helper: Set href from UTF-8 for internal operations
    fn setHrefUtf8(self: *URL, href_utf8: []const u8) !void {
        const parsed_url = api_parser.parseURL(self.allocator, href_utf8, null) catch {
            return error.TypeError;
        };

        self.internal.deinit();
        self.internal = parsed_url;

        // Update search params (UTF-8 is fine for internal method)
        const query_str = self.internal.query() orelse "";
        try self.search_params_ptr.updateFromString(query_str);
    }
    /// static URL? parse(USVString url, optional USVString base)
    pub fn call_parse(allocator: std.mem.Allocator, url: webidl.USVString, base: ?webidl.USVString) ?*URL {
        const url_obj = allocator.create(URL) catch return null;
        url_obj.* = URL.init(allocator, url, base) catch {
            allocator.destroy(url_obj);
            return null;
        };
        return url_obj;
    }
    /// static boolean canParse(USVString url, optional USVString base)
    pub fn call_canParse(allocator: std.mem.Allocator, url: webidl.USVString, base: ?webidl.USVString) webidl.boolean {
        // Convert UTF-16 to UTF-8 for internal processing
        const url_utf8 = infra.string.utf16ToUtf8(allocator, url) catch return false;
        defer allocator.free(url_utf8);

        var base_utf8: ?[]const u8 = null;
        defer if (base_utf8) |b| allocator.free(b);

        if (base) |base_str| {
            base_utf8 = infra.string.utf16ToUtf8(allocator, base_str) catch return false;
        }

        var parsed_base: ?URLRecord = null;
        defer if (parsed_base) |*pb| pb.deinit();

        if (base_utf8) |base_str| {
            parsed_base = api_parser.parseURL(allocator, base_str, null) catch return false;
        }

        const parsed_base_ptr = if (parsed_base) |*pb| pb else null;
        var parsed_url = api_parser.parseURL(allocator, url_utf8, parsed_base_ptr) catch return false;
        defer parsed_url.deinit();

        return true;
    }
    /// stringifier attribute USVString href
    pub fn get_href(self: *const URL) !webidl.USVString {
        const href_utf8 = try url_serializer.serialize(self.allocator, &self.internal, false);
        defer self.allocator.free(href_utf8);
        return infra.string.utf8ToUtf16(self.allocator, href_utf8);
    }
    pub fn set_href(self: *URL, href: webidl.USVString) !void {
        const href_utf8 = try infra.string.utf16ToUtf8(self.allocator, href);
        defer self.allocator.free(href_utf8);

        const parsed_url = api_parser.parseURL(self.allocator, href_utf8, null) catch {
            return error.TypeError;
        };

        self.internal.deinit();
        self.internal = parsed_url;

        // Update search params
        const query_str = self.internal.query() orelse "";
        try self.search_params_ptr.updateFromString(query_str);
    }
    /// readonly attribute USVString origin
    pub fn get_origin(self: *const URL) !webidl.USVString {
        const origin = try origin_module.getOrigin(self.allocator, &self.internal);
        const origin_utf8 = try origin.serialize(self.allocator);
        defer self.allocator.free(origin_utf8);
        return infra.string.utf8ToUtf16(self.allocator, origin_utf8);
    }
    /// attribute USVString protocol
    pub fn get_protocol(self: *const URL) !webidl.USVString {
        const protocol_utf8 = try std.fmt.allocPrint(self.allocator, "{s}:", .{self.internal.scheme()});
        defer self.allocator.free(protocol_utf8);
        return infra.string.utf8ToUtf16(self.allocator, protocol_utf8);
    }
    pub fn set_protocol(self: *URL, protocol: webidl.USVString) !void {
        // Spec lines 1873-1875: basic URL parse the given value, followed by U+003A (:),
        // with this's URL as url and scheme start state as state override.
        const protocol_utf8 = try infra.string.utf16ToUtf8(self.allocator, protocol);
        defer self.allocator.free(protocol_utf8);

        // Prepare input: protocol + ":"
        const input = try std.fmt.allocPrint(self.allocator, "{s}:", .{protocol_utf8});
        defer self.allocator.free(input);

        // Use state override mode to update scheme in-place
        // Parser handles all validation: special scheme checks, file scheme restrictions, etc.
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            input,
            null,
            ParserState.scheme_start,
            &self.internal,
        ) catch return; // Fail silently per spec (setter returns without error)
    }
    /// attribute USVString username
    pub fn get_username(self: *const URL) !webidl.USVString {
        const username_utf8 = self.internal.username();
        return infra.string.utf8ToUtf16(self.allocator, username_utf8);
    }
    pub fn set_username(self: *URL, username: webidl.USVString) !void {
        const username_utf8 = try infra.string.utf16ToUtf8(self.allocator, username);
        defer self.allocator.free(username_utf8);

        // Spec lines 1879-1882:
        // 1. If this's URL cannot have a username/password/port, then return.
        if (self.internal.cannotHaveUsernamePasswordPort()) return;

        // 2. Set the username given this's URL and the given value.
        // "Set the username" (spec line 1534): set url's username to the result of
        // running UTF-8 percent-encode on username using the userinfo percent-encode set.

        const encoded_username = try percent_encoding.utf8PercentEncode(
            self.allocator,
            username_utf8,
            EncodeSet.userinfo,
        );
        defer self.allocator.free(encoded_username);

        // Rebuild URL with new username (browser pattern for offset-based storage)
        const old_href = try self.getHrefUtf8();
        defer self.allocator.free(old_href);

        // Parse: scheme://[username[:password]@]host...
        // Find the scheme end
        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse return;
        const after_scheme = scheme_end + 3; // Skip "://"

        // Find where authority ends (at /, ?, #, or end)
        var authority_end = old_href.len;
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '/' or c == '?' or c == '#') {
                authority_end = after_scheme + i;
                break;
            }
        }

        // Check if there's an @ (credentials separator)
        const at_pos = std.mem.indexOf(u8, old_href[after_scheme..authority_end], "@");

        const new_href = if (at_pos) |at_offset| blk: {
            // Has existing credentials: replace username part
            const at_abs = after_scheme + at_offset;
            const colon_in_creds = std.mem.indexOf(u8, old_href[after_scheme..at_abs], ":");

            if (colon_in_creds) |colon_offset| {
                // Has password: scheme://NEW_USERNAME:password@host...
                const colon_abs = after_scheme + colon_offset;
                break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{ old_href[0..after_scheme], encoded_username, old_href[colon_abs..] });
            } else {
                // No password: scheme://NEW_USERNAME@host...
                break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{ old_href[0..after_scheme], encoded_username, old_href[at_abs..] });
            }
        } else blk: {
            // No existing credentials: insert username@
            break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}@{s}", .{ old_href[0..after_scheme], encoded_username, old_href[after_scheme..] });
        };
        defer self.allocator.free(new_href);

        try self.setHrefUtf8(new_href);
    }
    /// attribute USVString password
    pub fn get_password(self: *const URL) !webidl.USVString {
        const password_utf8 = self.internal.password();
        return infra.string.utf8ToUtf16(self.allocator, password_utf8);
    }
    pub fn set_password(self: *URL, password: webidl.USVString) !void {
        const password_utf8 = try infra.string.utf16ToUtf8(self.allocator, password);
        defer self.allocator.free(password_utf8);

        // Spec lines 1886-1889:
        // 1. If this's URL cannot have a username/password/port, then return.
        if (self.internal.cannotHaveUsernamePasswordPort()) return;

        // 2. Set the password given this's URL and the given value.
        // "Set the password" (spec line 1536): set url's password to the result of
        // running UTF-8 percent-encode on password using the userinfo percent-encode set.

        const encoded_password = try percent_encoding.utf8PercentEncode(
            self.allocator,
            password_utf8,
            EncodeSet.userinfo,
        );
        defer self.allocator.free(encoded_password);

        // Rebuild URL with new password (browser pattern)
        const old_href = try self.getHrefUtf8();
        defer self.allocator.free(old_href);

        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse return;
        const after_scheme = scheme_end + 3;

        var authority_end = old_href.len;
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '/' or c == '?' or c == '#') {
                authority_end = after_scheme + i;
                break;
            }
        }

        const at_pos = std.mem.indexOf(u8, old_href[after_scheme..authority_end], "@");

        const new_href = if (at_pos) |at_offset| blk: {
            // Has existing credentials
            const at_abs = after_scheme + at_offset;
            const username_part = self.internal.username();

            // scheme://username:NEW_PASSWORD@host...
            break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}:{s}{s}", .{ old_href[0..after_scheme], username_part, encoded_password, old_href[at_abs..] });
        } else blk: {
            // No existing credentials: insert :password@ (with empty username)
            break :blk try std.fmt.allocPrint(self.allocator, "{s}:{s}@{s}", .{ old_href[0..after_scheme], encoded_password, old_href[after_scheme..] });
        };
        defer self.allocator.free(new_href);

        try self.setHrefUtf8(new_href);
    }
    /// attribute USVString host
    pub fn get_host(self: *const URL) !webidl.USVString {
        const host = self.internal.host orelse {
            const empty = try self.allocator.dupe(u8, "");
            defer self.allocator.free(empty);
            return infra.string.utf8ToUtf16(self.allocator, empty);
        };

        const host_str = try host_serializer.serializeHost(self.allocator, host);
        defer self.allocator.free(host_str);

        const host_utf8 = if (self.internal.port) |port|
            try std.fmt.allocPrint(self.allocator, "{s}:{d}", .{ host_str, port })
        else
            try self.allocator.dupe(u8, host_str);
        defer self.allocator.free(host_utf8);

        return infra.string.utf8ToUtf16(self.allocator, host_utf8);
    }
    pub fn set_host(self: *URL, host: webidl.USVString) !void {
        const host_utf8 = try infra.string.utf16ToUtf8(self.allocator, host);
        defer self.allocator.free(host_utf8);

        // Spec lines 1903-1904: If this's URL has an opaque path, then return.
        if (self.internal.hasOpaquePath()) return;

        // Spec line 1905: Basic URL parse the given value with this's URL as url
        // and host state as state override.
        //
        // NOTE: Using hybrid approach instead of state override because the spec's
        // host state override doesn't support parsing host+port together (returns
        // error when encountering ':'), but set_host is expected to handle "host:port".

        // If empty string, special handling for special schemes
        if (host_utf8.len == 0 and helpers.isSpecialScheme(self.internal.scheme())) {
            return; // Can't set empty host for special schemes
        }

        // Parse the host (may include port)
        // Rebuild URL string and reparse (browser pattern)
        const old_href = try self.getHrefUtf8();
        defer self.allocator.free(old_href);

        // Find authority section: scheme://[userinfo@]HOST[:port]/...
        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse return;
        const after_scheme = scheme_end + 3;

        // Find @ if exists (end of userinfo)
        var host_start = after_scheme;
        var authority_end = old_href.len;
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '@') host_start = after_scheme + i + 1;
            if (c == '/' or c == '?' or c == '#') {
                authority_end = after_scheme + i;
                break;
            }
        }

        // Build new href: prefix + new_host + suffix
        const prefix = old_href[0..host_start];
        const suffix = old_href[authority_end..];
        const new_href = try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{ prefix, host_utf8, suffix });
        defer self.allocator.free(new_href);

        try self.setHrefUtf8(new_href);
    }
    /// attribute USVString hostname
    pub fn get_hostname(self: *const URL) !webidl.USVString {
        const host = self.internal.host orelse {
            const empty = try self.allocator.dupe(u8, "");
            defer self.allocator.free(empty);
            return infra.string.utf8ToUtf16(self.allocator, empty);
        };
        const hostname_utf8 = try host_serializer.serializeHost(self.allocator, host);
        defer self.allocator.free(hostname_utf8);
        return infra.string.utf8ToUtf16(self.allocator, hostname_utf8);
    }
    pub fn set_hostname(self: *URL, hostname: webidl.USVString) !void {
        const hostname_utf8 = try infra.string.utf16ToUtf8(self.allocator, hostname);
        defer self.allocator.free(hostname_utf8);

        // Spec lines 1918-1919: If this's URL has an opaque path, then return.
        if (self.internal.hasOpaquePath()) return;

        // Spec line 1920: Basic URL parse the given value with this's URL as url
        // and hostname state as state override.
        //
        // Hostname is like host but without port. Rebuild URL preserving existing port.

        if (hostname_utf8.len == 0 and helpers.isSpecialScheme(self.internal.scheme())) {
            return; // Can't set empty hostname for special schemes
        }

        const old_href = try self.getHrefUtf8();
        defer self.allocator.free(old_href);

        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse return;
        const after_scheme = scheme_end + 3;

        var host_start = after_scheme;
        var host_end = old_href.len;

        // Find @ (end of userinfo)
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '@') host_start = after_scheme + i + 1;
            if (c == '/' or c == '?' or c == '#') {
                host_end = after_scheme + i;
                break;
            }
        }

        // Find : (start of port) after host_start
        var port_part: []const u8 = "";
        for (old_href[host_start..host_end], 0..) |c, i| {
            if (c == ':') {
                host_end = host_start + i;
                port_part = old_href[host_end..]; // Includes ":port"
                break;
            }
        }

        const prefix = old_href[0..host_start];
        const suffix = old_href[host_end..];

        const new_href = if (port_part.len > 0) blk: {
            // Keep existing port
            break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{ prefix, hostname_utf8, suffix });
        } else blk: {
            break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{ prefix, hostname_utf8, suffix });
        };
        defer self.allocator.free(new_href);

        try self.setHrefUtf8(new_href);
    }
    /// attribute USVString port
    pub fn get_port(self: *const URL) !webidl.USVString {
        const port_utf8 = if (self.internal.port) |port|
            try std.fmt.allocPrint(self.allocator, "{d}", .{port})
        else
            try self.allocator.dupe(u8, "");
        defer self.allocator.free(port_utf8);
        return infra.string.utf8ToUtf16(self.allocator, port_utf8);
    }
    pub fn set_port(self: *URL, port: webidl.USVString) !void {
        const port_utf8 = try infra.string.utf16ToUtf8(self.allocator, port);
        defer self.allocator.free(port_utf8);

        // Spec lines 1930-1933:
        // 1. If this's URL cannot have a username/password/port, then return.
        if (self.internal.cannotHaveUsernamePasswordPort()) return;

        // 2. If the given value is the empty string, then set this's URL's port to null.
        if (port_utf8.len == 0) {
            self.internal.port = null;
            return;
        }

        // 3. Otherwise, basic URL parse the given value with this's URL as url
        // and port state as state override.
        //
        // Hybrid approach: Parse port, validate, rebuild URL.

        // Parse port number (use u32 to detect overflow beyond u16 range)
        var port_num: u32 = 0;
        for (port_utf8) |c| {
            if (!std.ascii.isDigit(c)) return; // Invalid port, no change
            const digit: u32 = c - '0';
            port_num = port_num * 10 + digit;
            if (port_num > 65535) return; // Port out of range, no change
        }

        // Check if port matches scheme's default (should be set to null)
        const scheme = self.internal.scheme();
        if (helpers.defaultPort(scheme)) |default| {
            if (port_num == default) {
                self.internal.port = null;
                // Rebuild URL without port
                const old_href = try self.getHrefUtf8();
                defer self.allocator.free(old_href);
                // Remove :port if present
                // For simplicity, reparse
                try self.setHrefUtf8(old_href);
                return;
            }
        }

        // Rebuild URL with new port
        const old_href = try self.getHrefUtf8();
        defer self.allocator.free(old_href);

        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse return;
        const after_scheme = scheme_end + 3;

        var host_start = after_scheme;
        var host_end = old_href.len;

        // Find @ (end of userinfo)
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '@') host_start = after_scheme + i + 1;
        }

        // Find end of authority (/, ?, #, or end)
        var path_start = old_href.len;
        for (old_href[host_start..], 0..) |c, i| {
            if (c == '/' or c == '?' or c == '#') {
                path_start = host_start + i;
                break;
            }
        }

        // Find existing : (port separator)
        for (old_href[host_start..path_start], 0..) |c, i| {
            if (c == ':') {
                host_end = host_start + i;
                break;
            }
        }
        if (host_end == old_href.len) host_end = path_start;

        const prefix = old_href[0..host_end];
        const suffix = old_href[path_start..];

        const new_href = try std.fmt.allocPrint(self.allocator, "{s}:{d}{s}", .{ prefix, port_num, suffix });
        defer self.allocator.free(new_href);

        try self.setHrefUtf8(new_href);
    }
    /// attribute USVString pathname
    pub fn get_pathname(self: *const URL) !webidl.USVString {
        const pathname_utf8 = try path_serializer.serializePath(self.allocator, &self.internal);
        defer self.allocator.free(pathname_utf8);
        return infra.string.utf8ToUtf16(self.allocator, pathname_utf8);
    }
    pub fn set_pathname(self: *URL, pathname: webidl.USVString) !void {
        const pathname_utf8 = try infra.string.utf16ToUtf8(self.allocator, pathname);
        defer self.allocator.free(pathname_utf8);

        // Spec lines 1939-1942:
        // 1. If this's URL has an opaque path, then return.
        if (self.internal.hasOpaquePath()) return;

        // 2. Empty this's URL's path.
        // 3. Basic URL parse the given value with this's URL as url
        // and path start state as state override.
        //
        // Hybrid approach: Rebuild URL with new pathname.

        const old_href = try self.getHrefUtf8();
        defer self.allocator.free(old_href);

        // Find where pathname starts (after authority)
        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse {
            // No authority, pathname starts after scheme:
            const colon = std.mem.indexOf(u8, old_href, ":") orelse return;
            const prefix = old_href[0 .. colon + 1];
            const suffix_start = blk: {
                for (old_href[colon + 1 ..], 0..) |c, i| {
                    if (c == '?' or c == '#') break :blk colon + 1 + i;
                }
                break :blk old_href.len;
            };
            const suffix = old_href[suffix_start..];

            const new_href = try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{ prefix, pathname_utf8, suffix });
            defer self.allocator.free(new_href);
            try self.setHrefUtf8(new_href);
            return;
        };

        const after_scheme = scheme_end + 3;

        // Find end of authority (first /, ?, or #)
        var path_start = old_href.len;
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '/' or c == '?' or c == '#') {
                path_start = after_scheme + i;
                break;
            }
        }

        // Find where query/fragment starts
        var path_end = old_href.len;
        for (old_href[path_start..], 0..) |c, i| {
            if (c == '?' or c == '#') {
                path_end = path_start + i;
                break;
            }
        }

        const prefix = old_href[0..path_start];
        const suffix = old_href[path_end..];

        // Ensure pathname starts with / for special schemes
        const normalized_pathname = if (helpers.isSpecialScheme(self.internal.scheme()) and
            !std.mem.startsWith(u8, pathname_utf8, "/"))
            try std.fmt.allocPrint(self.allocator, "/{s}", .{pathname_utf8})
        else
            try self.allocator.dupe(u8, pathname_utf8);
        defer self.allocator.free(normalized_pathname);

        const new_href = try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{ prefix, normalized_pathname, suffix });
        defer self.allocator.free(new_href);

        try self.setHrefUtf8(new_href);
    }
    /// attribute USVString search
    pub fn get_search(self: *const URL) !webidl.USVString {
        const query = self.internal.query() orelse {
            const empty = try self.allocator.dupe(u8, "");
            defer self.allocator.free(empty);
            return infra.string.utf8ToUtf16(self.allocator, empty);
        };
        const search_utf8 = try std.fmt.allocPrint(self.allocator, "?{s}", .{query});
        defer self.allocator.free(search_utf8);
        return infra.string.utf8ToUtf16(self.allocator, search_utf8);
    }
    pub fn set_search(self: *URL, search: webidl.USVString) !void {
        // Spec lines 1967-1972: Basic URL parse with query state override
        const search_utf8 = try infra.string.utf16ToUtf8(self.allocator, search);
        defer self.allocator.free(search_utf8);

        // Strip leading "?" if present (spec line 1969)
        const input = if (std.mem.startsWith(u8, search_utf8, "?"))
            search_utf8[1..]
        else
            search_utf8;

        // Empty string clears the query (spec line 1968)
        if (input.len == 0) {
            self.internal.query_start = 0;
            self.internal.query_len = 0;
            try self.search_params_ptr.updateFromString("");
            return;
        }

        // Use state override mode to update query in-place
        // Parser handles percent encoding and query parsing
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            input,
            null,
            ParserState.query,
            &self.internal,
        ) catch return; // Fail silently per spec

        // Update search params to match new query
        const new_query = self.internal.query() orelse "";
        try self.search_params_ptr.updateFromString(new_query);
    }
    /// [SameObject] readonly attribute URLSearchParams searchParams
    pub fn get_searchParams(self: *const URL) *URLSearchParams {
        return self.search_params_ptr;
    }
    /// attribute USVString hash
    pub fn get_hash(self: *const URL) !webidl.USVString {
        const fragment = self.internal.fragment() orelse {
            const empty = try self.allocator.dupe(u8, "");
            defer self.allocator.free(empty);
            return infra.string.utf8ToUtf16(self.allocator, empty);
        };
        const hash_utf8 = try std.fmt.allocPrint(self.allocator, "#{s}", .{fragment});
        defer self.allocator.free(hash_utf8);
        return infra.string.utf8ToUtf16(self.allocator, hash_utf8);
    }
    pub fn set_hash(self: *URL, hash: webidl.USVString) !void {
        // Spec lines 1975-1978: Basic URL parse with fragment state override
        const hash_utf8 = try infra.string.utf16ToUtf8(self.allocator, hash);
        defer self.allocator.free(hash_utf8);

        // Step 1: Empty string clears the fragment (spec line 1976)
        if (hash_utf8.len == 0) {
            self.internal.fragment_start = 0;
            self.internal.fragment_len = 0;
            return;
        }

        // Step 2: Strip leading "#" if present (spec line 1977)
        const input = if (std.mem.startsWith(u8, hash_utf8, "#"))
            hash_utf8[1..]
        else
            hash_utf8;

        // Step 3-4: Use state override mode to update fragment in-place
        // Parser handles percent encoding and fragment parsing
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            input,
            null,
            ParserState.fragment,
            &self.internal,
        ) catch return; // Fail silently per spec
    }
    /// USVString toJSON()
    pub fn call_toJSON(self: *const URL) !webidl.USVString {
        return self.get_href();
    }
};

