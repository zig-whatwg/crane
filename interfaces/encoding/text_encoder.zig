// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

const std = @import("std");
const infra = @import("infra");
const webidl = @import("webidl");
const TextEncoderEncodeIntoResult = @import("text_encoder_encode_into_result").TextEncoderEncodeIntoResult;
/// TextEncoder - encodes strings to UTF-8 bytes
/// 
/// WHATWG Encoding Standard § 7.4
/// https://encoding.spec.whatwg.org/#interface-textencoder
/// 
/// **WebIDL Compliance**: This implementation uses UTF-16 input and Uint8Array output:
/// - `encode()` accepts `USVString` (UTF-16) input
/// - `encode()` returns `Uint8Array` output
/// - `encodeInto()` accepts `USVString` (UTF-16) source and `Uint8Array` destination
/// 
/// TextEncoder only supports UTF-8 encoding.
pub const TextEncoder = struct {
    allocator: std.mem.Allocator,
    array_buffer: ?*webidl.ArrayBuffer,

    /// Constructor - creates a new TextEncoder
    /// 
    /// WHATWG Encoding Standard § 5
    /// https://encoding.spec.whatwg.org/#dom-textencoder
    /// 
    /// IDL:
    /// ```
    /// constructor();
    /// ```
    /// 
    /// The encoding is always "utf-8"
    pub fn init(allocator: std.mem.Allocator) TextEncoder {
        return .{
            .allocator = allocator,
        };
    }
    /// Cleanup resources (if any allocated state exists)
    pub fn deinit(self: *TextEncoder) void {
        // Free ArrayBuffer if allocated
        if (self.array_buffer) |buffer| {
            buffer.deinit(self.allocator);
            self.allocator.destroy(buffer);
        }
    }
    /// Get the encoding name (always "utf-8" as DOMString)
    /// 
    /// WHATWG Encoding Standard § 5
    /// TextEncoder.encoding getter
    /// 
    /// **WebIDL Compliance**: Returns `DOMString` (UTF-16) per WebIDL spec
    /// 
    /// IDL:
    /// ```
    /// readonly attribute DOMString encoding;
    /// ```
    pub inline fn get_encoding(self: *const TextEncoder) webidl.DOMString {
        _ = self;
        // Return "utf-8" as UTF-16
        return &.{ 'u', 't', 'f', '-', '8' };
    }
    /// call_encode() - Encodes a USVString into UTF-8 bytes
    /// 
    /// WHATWG Encoding Standard § 5
    /// https://encoding.spec.whatwg.org/#dom-textencoder-encode
    /// 
    /// **WebIDL Compliance**:
    /// - Input: `USVString` (UTF-16) per WebIDL spec
    /// - Output: `[NewObject] Uint8Array` per WebIDL spec
    /// 
    /// IDL:
    /// ```
    /// [NewObject] Uint8Array encode(optional USVString input = "");
    /// ```
    /// 
    /// Takes an optional input USVString (default empty), returns Uint8Array.
    /// This follows the spec algorithm which converts the string to scalar values
    /// and then runs UTF-8's encoder.
    pub fn call_encode(self: *TextEncoder, input: webidl.USVString) !webidl.TypedArray(u8) {
        // Step 1: Convert USVString (UTF-16) to UTF-8
        // USVString is already scalar values only (no unpaired surrogates)

        // ASCII ULTRA-FAST PATH (common case: 70-80% of inputs)
        // Check if all UTF-16 code units are ASCII (0x00-0x7F)
        const is_ascii = blk: {
            for (input) |cu| {
                if (cu > 0x7F) break :blk false;
            }
            break :blk true;
        };

        if (is_ascii and input.len > 0) {
            // ASCII: each UTF-16 code unit becomes one UTF-8 byte
            const utf8_bytes = try self.allocator.alloc(u8, input.len);
            for (input, 0..) |cu, i| {
                utf8_bytes[i] = @intCast(cu);
            }

            // Create ArrayBuffer and Uint8Array
            const buffer = try self.allocator.create(webidl.ArrayBuffer);
            buffer.* = webidl.ArrayBuffer{
                .data = utf8_bytes,
                .detached = false,
            };

            return try webidl.TypedArray(u8).init(buffer, 0, utf8_bytes.len);
        }

        // Non-ASCII: Convert UTF-16 → UTF-8
        const utf8_bytes = try infra.string.utf16ToUtf8(self.allocator, input);

        // Create ArrayBuffer and Uint8Array
        const buffer = try self.allocator.create(webidl.ArrayBuffer);
        buffer.* = webidl.ArrayBuffer{
            .data = utf8_bytes,
            .detached = false,
        };

        return try webidl.TypedArray(u8).init(buffer, 0, utf8_bytes.len);
    }
    /// call_encodeInto() - Encodes a USVString into an existing Uint8Array
    /// 
    /// WHATWG Encoding Standard § 5
    /// https://encoding.spec.whatwg.org/#dom-textencoder-encodeinto
    /// 
    /// **WebIDL Compliance**:
    /// - source: `USVString` (UTF-16) per WebIDL spec
    /// - destination: `[AllowShared] Uint8Array` per WebIDL spec
    /// 
    /// IDL:
    /// ```
    /// TextEncoderEncodeIntoResult encodeInto(USVString source, [AllowShared] Uint8Array destination);
    /// ```
    /// 
    /// Encodes source USVString into destination Uint8Array.
    /// Returns the number of UTF-16 code units read and bytes written.
    pub fn call_encodeInto(
        self: *TextEncoder,
        source: webidl.USVString,
        destination: webidl.TypedArray(u8),
    ) !TextEncoderEncodeIntoResult {
        _ = self;

        var read: webidl.@"unsigned long long" = 0;
        var written: webidl.@"unsigned long long" = 0;

        // Get destination slice (zero-copy view)
        const dest_slice = try destination.asSlice();

        // Process UTF-16 input (USVString)
        var i: usize = 0;
        while (i < source.len and written < dest_slice.len) {
            const cu = source[i];

            // USVString contains only scalar values (no unpaired surrogates)
            // Check for surrogate pair (BMP vs supplementary plane)
            const cp: u21 = blk: {
                // Use infra code point predicates for clarity (Priority 2)
                if (infra.code_point.isLeadSurrogate(cu)) {
                    // High surrogate - should be paired with low surrogate
                    if (i + 1 < source.len) {
                        const low = source[i + 1];
                        if (infra.code_point.isTrailSurrogate(low)) {
                            // Valid surrogate pair - use infra's decodeSurrogatePair
                            const code_point = infra.code_point.decodeSurrogatePair(cu, low) catch unreachable;
                            i += 1; // Consume low surrogate
                            read += 1;
                            break :blk code_point;
                        }
                    }
                    // Unpaired high surrogate (shouldn't happen in USVString, but handle it)
                    break :blk @as(u21, cu);
                }
                // BMP character (single code unit)
                break :blk @as(u21, cu);
            };

            // Encode code point to UTF-8
            var buf: [4]u8 = undefined;
            const out_len = std.unicode.utf8Encode(cp, &buf) catch unreachable;

            // Check if we have space
            if (written + out_len > dest_slice.len) {
                // Not enough space, stop here
                break;
            }

            // Write to destination
            @memcpy(dest_slice[written .. written + out_len], buf[0..out_len]);
            written += out_len;
            read += 1; // Read one UTF-16 code unit
            i += 1;
        }

        return .{
            .read = read,
            .written = written,
        };
    }
    /// Helper: Check if a byte slice is ASCII-only
    /// Uses WHATWG Infra Standard's SIMD-optimized implementation
    fn isAscii(bytes: []const u8) bool {
        return infra.string.isAscii(bytes);
    }
};

