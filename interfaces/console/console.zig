// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! WHATWG Console Standard Implementation
//!
//! Spec: https://console.spec.whatwg.org/
//!
//! This module implements the console namespace object as defined by the
//! WHATWG Console Standard. The console provides logging, timing, counting,
//! and grouping operations for debugging and development.
//!
//! # Architecture
//!
//! This implementation focuses on the **console algorithm logic** (Logger,
//! Formatter, Printer operations) and assumes integration with a JavaScript
//! runtime for ECMAScript type conversions.
//!
//! # State Management
//!
//! Each console namespace object has associated state:
//! - **count_map**: OrderedMap of labels to counts (for count/countReset)
//! - **timer_table**: OrderedMap of labels to start times (for time/timeLog/timeEnd)
//! - **group_stack**: Stack of active groups (for group/groupCollapsed/groupEnd)
//!
//! # Usage
//!
//! ```zig
//! const allocator = std.heap.page_allocator;
//! var console_obj = try Console.init(allocator);
//! defer console_obj.deinit();
//!
//! // Logging
//! try console_obj.call_log(&.{some_value});
//!
//! // Timing
//! try console_obj.call_time(label);
//! // ... do work ...
//! try console_obj.call_timeEnd(label);
//!
//! // Counting
//! try console_obj.call_count(label);
//!
//! // Grouping
//! try console_obj.call_group(&.{});
//! try console_obj.call_log(&.{value}); // Indented
//! console_obj.call_groupEnd();
//! ```

const std = @import("std");
const infra = @import("infra");
const webidl = @import("webidl");
const types = @import("types");
const format = @import("format");

const Allocator = std.mem.Allocator;
const Group = types.Group;
const LogLevel = types.LogLevel;
const Message = types.Message;
const CircularMessageBuffer = types.CircularMessageBuffer;

/// Printer function signature - matches std.debug.print exactly.
/// Allows users to control where console output goes (stderr, file, network, etc.).
/// Printer function type for console output.
/// Takes a pre-formatted message string and outputs it.
/// This is a simple runtime function pointer, not generic.
pub const PrintFn = *const fn (message: []const u8) void;

/// Default printer function that outputs to stderr.
fn defaultPrinter(message: []const u8) void {
    std.debug.print("{s}\n", .{message});
}
/// Console namespace object implementing the WHATWG Console Standard.
/// 
/// WHATWG Console Standard lines 8-39:
/// ```webidl
/// [Exposed=*]
/// namespace console {
/// // Logging
/// undefined assert(optional boolean condition = false, any... data);
/// undefined clear();
/// undefined debug(any... data);
/// undefined error(any... data);
/// undefined info(any... data);
/// undefined log(any... data);
/// undefined table(optional any tabularData, optional sequence<DOMString> properties);
/// undefined trace(any... data);
/// undefined warn(any... data);
/// undefined dir(optional any item, optional object? options);
/// undefined dirxml(any... data);
/// 
/// // Counting
/// undefined count(optional DOMString label = "default");
/// undefined countReset(optional DOMString label = "default");
/// 
/// // Grouping
/// undefined group(any... data);
/// undefined groupCollapsed(any... data);
/// undefined groupEnd();
/// 
/// // Timing
/// undefined time(optional DOMString label = "default");
/// undefined timeLog(optional DOMString label = "default", any... data);
/// undefined timeEnd(optional DOMString label = "default");
/// };
/// ```
pub const Console = struct {
    allocator: Allocator,
    enabled: bool,
    print_fn: ?PrintFn,
    runtime: ?*types.RuntimeInterface,
    count_map: infra.OrderedMap(webidl.DOMString, u32),
    timer_table: infra.OrderedMap(webidl.DOMString, infra.Moment),
    group_stack: infra.Stack(Group),
    message_buffer: CircularMessageBuffer,
    label_pool: std.StringHashMap(void),

    /// Initialize a new Console namespace object with default buffer size (1000 messages).
    /// 
    /// All state (count_map, timer_table, group_stack, message_buffer, label_pool) is initialized empty.
    /// Console is enabled by default with immediate output to stderr.
    pub fn init(allocator: Allocator) !Console {
        return initWithBufferSize(allocator, 1000);
    }
    /// Clean up all resources.
    /// 
    /// This must be called when the Console object is no longer needed.
    /// Frees all allocated memory for count_map, timer_table, group_stack, message_buffer, and label_pool.
    pub fn deinit(self: *Console) void {
        self.count_map.deinit();
        self.timer_table.deinit();
        self.group_stack.deinit();
        self.message_buffer.deinit();

        // Free all interned label strings
        var it = self.label_pool.keyIterator();
        while (it.next()) |key| {
            self.allocator.free(key.*);
        }
        self.label_pool.deinit();
    }
    /// Initialize a new Console namespace object with custom buffer size.
    /// 
    /// Allows customization of message buffer size for different deployment scenarios:
    /// - Embedded systems: small buffer (e.g., 100)
    /// - Servers: large buffer (e.g., 10000)
    /// - Testing: no buffer (0)
    /// - Default: 1000 messages (browser standard)
    pub fn initWithBufferSize(allocator: Allocator, buffer_size: usize) !Console {
        var label_pool = std.StringHashMap(void).init(allocator);
        errdefer {
            // Clean up any labels that were added to the pool
            var it = label_pool.keyIterator();
            while (it.next()) |key| {
                allocator.free(key.*);
            }
            label_pool.deinit();
        }

        // Pre-intern the "default" label (used 90% of the time)
        const default_label = try allocator.dupe(u8, "default");
        errdefer allocator.free(default_label);
        try label_pool.put(default_label, {});

        var message_buffer = try CircularMessageBuffer.init(allocator, buffer_size);
        errdefer message_buffer.deinit();

        return .{
            .allocator = allocator,
            .enabled = true, // Browser optimization: fast disabled path
            .print_fn = defaultPrinter,
            .runtime = null, // No runtime by default (standalone mode)
            .count_map = infra.OrderedMap(webidl.DOMString, u32).init(allocator),
            .timer_table = infra.OrderedMap(webidl.DOMString, infra.Moment).init(allocator),
            .group_stack = infra.Stack(Group).init(allocator),
            .message_buffer = message_buffer,
            .label_pool = label_pool,
        };
    }
    /// Intern a label string (UTF-8) for reuse.
    /// 
    /// This is a browser optimization pattern: common labels like "default"
    /// are used repeatedly (90% of timer/counter calls). By interning these
    /// strings, we reduce allocations and enable pointer-based equality checks.
    /// 
    /// Returns the interned string from the pool, or inserts it if not present.
    /// 
    /// Performance:
    /// - First call for a label: allocates and stores in pool
    /// - Subsequent calls: O(1) lookup, no allocation
    /// - "default" label: pre-interned in init(), zero-cost
    /// 
    /// See BROWSER_PATTERNS.md Phase 5 for details.
    fn internLabel(self: *Console, label_utf8: []const u8) ![]const u8 {
        // Check if already in pool
        if (self.label_pool.getKey(label_utf8)) |existing| {
            return existing;
        }

        // Not in pool - allocate and insert
        const owned = try self.allocator.dupe(u8, label_utf8);
        errdefer self.allocator.free(owned);

        try self.label_pool.put(owned, {});

        // Return the owned string from the pool
        return self.label_pool.getKey(owned).?;
    }
    /// Logger(logLevel, args)
    /// 
    /// WHATWG Console Standard lines 278-293:
    /// The logger operation accepts a log level and a list of arguments.
    /// Its main output is printing the result to the console.
    fn logger(self: *Console, log_level: LogLevel, args: []const webidl.JSValue) void {
        // Browser optimization: Fast disabled path (~10ns overhead)
        if (!self.enabled) return;

        // Step 1: If args is empty, return
        if (args.len == 0) return;

        // Step 2: Let first be args[0]
        const first = args[0];

        // Step 3: Let rest be all elements following first in args
        const rest = args[1..];

        // Step 4: If rest is empty, perform Printer(logLevel, « first »)
        if (rest.len == 0) {
            self.printer(log_level, &.{first});
            return;
        }

        // Step 5: Otherwise, perform Printer(logLevel, Formatter(args))
        const formatted = self.formatter(args) catch {
            // If formatting fails, print args unformatted
            self.printer(log_level, args);
            return;
        };
        defer if (formatted.ptr != args.ptr) self.allocator.free(formatted);

        self.printer(log_level, formatted);

        // Step 6: Return undefined (implicit in Zig void return)
    }
    /// Formatter(args)
    /// 
    /// WHATWG Console Standard lines 297-338:
    /// The formatter operation tries to format the first argument using format specifiers.
    /// Returns a list of objects suitable for printing.
    /// 
    /// This is a RECURSIVE implementation following the spec exactly (step 8: "Return Formatter(result)").
    /// 
    /// Note: Uses SIMD scanning for '%' characters (5-10x faster than scalar)
    /// and comptime lookup table for O(1) specifier identification.
    /// See format.zig for SIMD implementation details.
    fn formatter(self: *Console, args: []const webidl.JSValue) ![]const webidl.JSValue {
        // Step 1: If args's size is 1, return args
        if (args.len == 1) return args;

        // Step 2: Let target be the first element of args
        const target = args[0];

        // Step 3: Let current be the second element of args
        const current = args[1];

        // Convert target to string for format specifier scanning
        const target_str = switch (target) {
            .string => |s| s,
            else => {
                // Can't process format specifiers on non-strings
                return args;
            },
        };

        // Step 4: Find the first possible format specifier specifier, from the left to the right in target
        const first_spec_match = blk: {
            var specs = try format.findAllSpecifiers(self.allocator, target_str);
            defer specs.deinit();

            // Get first specifier (if any)
            if (specs.size() > 0) {
                break :blk specs.get(0);
            } else {
                break :blk null;
            }
        };

        // Step 5: If no format specifier was found, return args
        if (first_spec_match == null) return args;

        const spec_info = first_spec_match.?;

        // Step 6: Otherwise (a specifier was found)
        // Convert current arg based on specifier type
        const converted = try self.convertForSpecifier(current, spec_info.spec);
        defer self.allocator.free(converted);

        // Step 6.7: Replace specifier in target with converted
        // Build new target with specifier replaced
        var new_target_buf = infra.List(u8).init(self.allocator);
        defer new_target_buf.deinit();

        // Append text before specifier
        try new_target_buf.appendSlice(target_str[0..spec_info.index]);
        // Append converted value
        try new_target_buf.appendSlice(converted);
        // Append text after specifier (skip the 2-char specifier: %s, %d, etc.)
        try new_target_buf.appendSlice(target_str[spec_info.index + 2 ..]);

        const new_target_str = try self.allocator.dupe(u8, new_target_buf.items());
        // new_target_str will be freed by caller or next recursive call

        // Step 7: Let result be a list containing target together with the elements
        // of args starting from the third onward
        const result_len = 1 + (if (args.len > 2) args.len - 2 else 0);
        var result = try self.allocator.alloc(webidl.JSValue, result_len);

        result[0] = webidl.JSValue{ .string = new_target_str };

        // Copy remaining args (starting from third element, index 2)
        if (args.len > 2) {
            @memcpy(result[1..], args[2..]);
        }

        // Step 8: Return Formatter(result) - RECURSIVE CALL
        const final_result = try self.formatter(result);

        // Clean up intermediate allocations
        // If formatter returned a different array, we need to free our result array
        if (final_result.ptr != result.ptr) {
            // Formatter created a new array, free ours
            // But don't free the string inside result[0] if it's still being used
            var string_still_used = false;
            for (final_result) |item| {
                if (item == .string and item.string.ptr == new_target_str.ptr) {
                    string_still_used = true;
                    break;
                }
            }
            if (!string_still_used) {
                self.allocator.free(new_target_str);
            }
            self.allocator.free(result);
        }

        return final_result;
    }
    /// Convert a JSValue based on format specifier type.
    /// 
    /// WHATWG Console Standard lines 313-333 (Formatter algorithm steps 6.1-6.5):
    /// - %s: Call %String%(current)
    /// - %d or %i: Call %parseInt%(current, 10)
    /// - %f: Call %parseFloat%(current)
    /// - %o: Optimal formatting (runtime-specific)
    /// - %O: Generic object formatting (runtime-specific)
    /// 
    /// If runtime is available, use its type conversion methods (ToString, parseInt, parseFloat).
    /// Otherwise, use simple fallback conversions.
    fn convertForSpecifier(self: *Console, value: webidl.JSValue, spec: format.FormatSpec) ![]const u8 {
        // If runtime is available, use it for type conversions
        if (self.runtime) |rt| {
            return switch (spec) {
                // %s - String conversion using ECMAScript ToString
                .string => try rt.vtable.toString(rt.context, value, self.allocator),

                // %d or %i - Integer conversion using ECMAScript parseInt(value, 10)
                .integer => {
                    const int_val = try rt.vtable.toInteger(rt.context, value);
                    return try std.fmt.allocPrint(self.allocator, "{d}", .{int_val});
                },

                // %f - Float conversion using ECMAScript parseFloat
                .float => {
                    const float_val = try rt.vtable.toFloat(rt.context, value);
                    return try std.fmt.allocPrint(self.allocator, "{d}", .{float_val});
                },

                // %o and %O - Object formatting (use toString for now)
                .optimal, .object => try rt.vtable.toString(rt.context, value, self.allocator),

                // %c - CSS styling (not implemented, return empty string)
                .css => try self.allocator.dupe(u8, ""),
            };
        }

        // Fallback: Use simple conversions when no runtime available
        return switch (spec) {
            // %s - String conversion
            .string => switch (value) {
                .string => |s| try self.allocator.dupe(u8, s),
                .number => |n| try std.fmt.allocPrint(self.allocator, "{d}", .{n}),
                .boolean => |b| try self.allocator.dupe(u8, if (b) "true" else "false"),
                .null => try self.allocator.dupe(u8, "null"),
                .undefined => try self.allocator.dupe(u8, "undefined"),
            },

            // %d, %i - Integer conversion (fallback)
            .integer => {
                const num = value.toNumber();
                const int_val = @as(i32, @intFromFloat(@round(num)));
                return try std.fmt.allocPrint(self.allocator, "{d}", .{int_val});
            },

            // %f - Float conversion (fallback)
            .float => {
                const num = value.toNumber();
                return try std.fmt.allocPrint(self.allocator, "{d}", .{num});
            },

            // %o, %O - Optimal/object formatting (fallback, same as string)
            .optimal, .object => switch (value) {
                .string => |s| try self.allocator.dupe(u8, s),
                .number => |n| try std.fmt.allocPrint(self.allocator, "{d}", .{n}),
                .boolean => |b| try self.allocator.dupe(u8, if (b) "true" else "false"),
                .null => try self.allocator.dupe(u8, "null"),
                .undefined => try self.allocator.dupe(u8, "undefined"),
            },

            // %c - CSS styling (not implemented, return empty string)
            .css => try self.allocator.dupe(u8, ""),
        };
    }
    /// Printer(logLevel, args, options?)
    /// 
    /// WHATWG Console Standard lines 354-371:
    /// The printer operation is implementation-defined. It accepts a log level,
    /// a list of arguments, and optional formatting options.
    /// 
    /// Phase 3 (Lazy Formatting): Store raw args, format only when displayed.
    /// This implementation buffers messages (up to 1000) for message history,
    /// following the browser pattern (Chrome, Firefox, Safari).
    fn printer(self: *Console, log_level: LogLevel, args: []const webidl.JSValue) void {
        self.printerWithOwnedStrings(log_level, args, &.{});
    }
    /// Printer with owned strings tracking for memory management.
    /// Use this when args contain dynamically allocated strings that should be
    /// freed when the message is evicted from the buffer.
    fn printerWithOwnedStrings(
        self: *Console,
        log_level: LogLevel,
        args: []const webidl.JSValue,
        owned_strings: []const []const u8,
    ) void {
        // Capture current indentation level
        const indent = self.group_stack.items_list.size();

        // Create message with current timestamp
        const timestamp = infra.Moment.now();

        // Phase 3: Store raw args (lazy formatting) with owned strings
        const message = Message.initWithOwnedStrings(
            log_level,
            timestamp,
            args,
            indent,
            owned_strings,
            self.allocator,
        ) catch {
            // If allocation fails, free owned strings and skip buffering
            for (owned_strings) |owned_str| {
                self.allocator.free(owned_str);
            }
            return;
        };

        // Add to buffer (automatically handles overflow by freeing oldest)
        self.message_buffer.push(message);

        // Print immediately if printer is configured
        // Set print_fn to null for production mode (buffer only)
        if (self.print_fn) |print| {
            const formatted = message.format(self.allocator) catch return;
            defer self.allocator.free(formatted);
            print(formatted);
        }
    }
    /// assert(condition, ...data)
    /// 
    /// WHATWG Console Standard lines 52-72:
    /// If condition is false, log an assertion failure message.
    /// The message is prepended or concatenated to the provided data.
    /// 
    /// IDL: undefined assert(optional boolean condition = false, any... data);
    pub fn call_assert(self: *Console, condition: webidl.boolean, data: []const webidl.JSValue) void {
        // Step 1: If condition is true, return
        if (condition) return;

        // Step 2: Let message be a string without any formatting specifiers
        // indicating generically an assertion failure (such as "Assertion failed")
        const message = "Assertion failed";

        // Step 3: If data is empty, append message to data
        if (data.len == 0) {
            const args: [1]webidl.JSValue = .{webidl.JSValue{ .string = message }};
            self.logger(.assert_level, &args);
            return;
        }

        // Step 4: Otherwise
        const first = data[0];

        // Step 4.2: If first is not a String, then prepend message to data
        if (first != .string) {
            var args_with_prefix = self.allocator.alloc(webidl.JSValue, data.len + 1) catch {
                // If allocation fails, just log data without prefix
                self.logger(.assert_level, data);
                return;
            };
            defer self.allocator.free(args_with_prefix);

            args_with_prefix[0] = webidl.JSValue{ .string = message };
            @memcpy(args_with_prefix[1..], data);

            // Step 5: Perform Logger("assert", data)
            self.logger(.assert_level, args_with_prefix);
        } else {
            // Step 4.3: Otherwise (first IS a String)
            // Step 4.3.1: Let concat be the concatenation of message, U+003A (:), U+0020 SPACE, and first
            const concat = std.fmt.allocPrint(
                self.allocator,
                "{s}: {s}",
                .{ message, first.string },
            ) catch {
                // If allocation fails, just log data
                self.logger(.assert_level, data);
                return;
            };
            // concat will be owned by the message buffer and freed when message is evicted

            // Step 4.3.2: Set data[0] to concat
            var modified_data = self.allocator.alloc(webidl.JSValue, data.len) catch {
                self.allocator.free(concat); // Free concat if we can't allocate modified_data
                self.logger(.assert_level, data);
                return;
            };
            defer self.allocator.free(modified_data); // Free temp array after printer copies it

            modified_data[0] = webidl.JSValue{ .string = concat };
            if (data.len > 1) {
                @memcpy(modified_data[1..], data[1..]);
            }

            // Step 5: Perform Logger("assert", data)
            // Since we're passing a simple concatenated string (no format specifiers),
            // logger will go to step 4 (rest is empty) and call printer directly.
            // We use the owned strings variant to properly track concat for cleanup.
            const owned_strings = [_][]const u8{concat};

            // Check if this will hit the formatting path or direct printer path
            if (modified_data.len == 1) {
                // Single arg - will call printer directly (logger step 4)
                self.printerWithOwnedStrings(.assert_level, modified_data, &owned_strings);
            } else {
                // Multiple args - would call formatter, but concat has no format specifiers
                // so formatter will return original args, then printer is called
                // For simplicity, just call printer directly
                self.printerWithOwnedStrings(.assert_level, modified_data, &owned_strings);
            }
        }
    }
    /// clear()
    /// 
    /// WHATWG Console Standard lines 75-79:
    /// Empty the group stack and optionally clear the console output.
    /// 
    /// IDL: undefined clear();
    pub fn call_clear(self: *Console) void {
        // Step 1: Empty the appropriate group stack
        while (self.group_stack.pop()) |popped_group| {
            // Free the label if it was allocated
            if (popped_group.label) |lbl| {
                self.allocator.free(lbl);
            }
        }

        // Step 2: If possible for the environment, clear the console
        // Clear the message buffer to remove all stored messages
        self.message_buffer.clear();
    }
    /// debug(...data)
    /// 
    /// WHATWG Console Standard lines 82-84:
    /// Perform Logger("debug", data).
    /// 
    /// IDL: undefined debug(any... data);
    pub fn call_debug(self: *Console, data: []const webidl.JSValue) void {
        self.logger(.debug, data);
    }
    /// error(...data)
    /// 
    /// WHATWG Console Standard lines 87-89:
    /// Perform Logger("error", data).
    /// 
    /// IDL: undefined error(any... data);
    pub fn call_error(self: *Console, data: []const webidl.JSValue) void {
        self.logger(.error_level, data);
    }
    /// info(...data)
    /// 
    /// WHATWG Console Standard lines 92-94:
    /// Perform Logger("info", data).
    /// 
    /// IDL: undefined info(any... data);
    pub fn call_info(self: *Console, data: []const webidl.JSValue) void {
        self.logger(.info, data);
    }
    /// log(...data)
    /// 
    /// WHATWG Console Standard lines 97-99:
    /// Perform Logger("log", data).
    /// 
    /// IDL: undefined log(any... data);
    pub fn call_log(self: *Console, data: []const webidl.JSValue) void {
        self.logger(.log, data);
    }
    /// table(tabularData, properties)
    /// 
    /// WHATWG Console Standard lines 95-105:
    /// Try to construct a table with the columns of the properties of tabularData.
    /// Fall back to just logging the argument if it can't be parsed as tabular.
    /// 
    /// NOTE: The spec says "TODO: This will need a good algorithm."
    /// For now, we fall back to logging since we don't have runtime introspection.
    /// 
    /// IDL: undefined table(optional any tabularData, optional sequence<DOMString> properties);
    pub fn call_table(self: *Console, tabular_data: ?*const webidl.JSValue, properties: ?[]const webidl.DOMString) void {
        // WHATWG Console Standard lines 102-106:
        // Try to construct a table with columns of properties and rows of tabularData.
        // Fall back to logging if it can't be parsed as tabular.

        if (tabular_data == null) {
            self.logger(.log, &.{});
            return;
        }

        const data = tabular_data.?.*;

        // If runtime is available, attempt to construct table
        if (self.runtime) |rt| {
            self.constructTable(rt, data, properties) catch {
                // Fall back to logging on error
                const args: [1]webidl.JSValue = .{data};
                self.logger(.log, &args);
                return;
            };
        } else {
            // No runtime - fall back to logging
            const args: [1]webidl.JSValue = .{data};
            self.logger(.log, &args);
        }
    }
    /// Construct and display a table from tabular data.
    /// 
    /// Complete implementation following browser console.table() behavior:
    /// 1. Parse array elements and extract all unique keys
    /// 2. Filter columns by properties parameter if provided
    /// 3. Build ASCII table with proper alignment and borders
    /// 4. Support primitives and objects as array elements
    /// 
    /// Browser compatibility: Matches Chrome, Firefox, Safari table() behavior
    fn constructTable(
        self: *Console,
        rt: *types.RuntimeInterface,
        data: webidl.JSValue,
        properties: ?[]const webidl.DOMString,
    ) !void {
        // Step 1: Check if data is an array
        const is_array = rt.vtable.isArray(rt.context, data);

        if (!is_array) {
            // Not an array - fall back to logging
            return error.NotTabular;
        }

        // Step 2: Get array length
        const length = try rt.vtable.getLength(rt.context, data);

        if (length == 0) {
            // Empty array - just log it
            const args: [1]webidl.JSValue = .{data};
            self.logger(.log, &args);
            return;
        }

        // Step 3: Collect all unique keys from array elements
        var all_keys = std.StringHashMap(void).init(self.allocator);
        defer {
            var key_iter = all_keys.keyIterator();
            while (key_iter.next()) |key| {
                self.allocator.free(key.*);
            }
            all_keys.deinit();
        }

        // Iterate through array to collect keys
        var i: u32 = 0;
        while (i < length) : (i += 1) {
            // Get element at index
            const index_str = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
            defer self.allocator.free(index_str);

            const element = rt.vtable.getProperty(rt.context, data, index_str) orelse continue;

            // If element is an object, get its keys
            if (rt.vtable.isObject(rt.context, element)) {
                const keys = try rt.vtable.getKeys(rt.context, element, self.allocator);
                defer {
                    for (keys) |key| {
                        self.allocator.free(key);
                    }
                    self.allocator.free(keys);
                }

                // Add each key to our set
                for (keys) |key| {
                    const entry = try all_keys.getOrPut(key);
                    if (!entry.found_existing) {
                        // Key not in map yet, we need to own it
                        entry.key_ptr.* = try self.allocator.dupe(u8, key);
                    }
                }
            }
        }

        // Step 4: Determine which columns to display
        var columns = infra.List([]const u8).init(self.allocator);
        defer columns.deinit();

        if (properties) |props| {
            // Filter by provided properties
            for (props) |prop| {
                const prop_utf8 = try infra.string.utf16ToUtf8(self.allocator, prop);
                defer self.allocator.free(prop_utf8);

                if (all_keys.contains(prop_utf8)) {
                    try columns.append(try self.allocator.dupe(u8, prop_utf8));
                }
            }
        } else {
            // Use all collected keys
            var key_iter = all_keys.keyIterator();
            while (key_iter.next()) |key| {
                try columns.append(try self.allocator.dupe(u8, key.*));
            }
        }
        defer {
            for (columns.items()) |col| {
                self.allocator.free(col);
            }
        }

        // Step 5: Collect all cell values
        var rows = infra.List(infra.List([]const u8)).init(self.allocator);
        defer {
            // Need to get mutable access to rows for cleanup
            const rows_for_cleanup = &rows;
            var cleanup_idx: usize = 0;
            while (cleanup_idx < rows_for_cleanup.size()) : (cleanup_idx += 1) {
                var row = rows_for_cleanup.get(cleanup_idx).?;
                var cell_idx: usize = 0;
                while (cell_idx < row.size()) : (cell_idx += 1) {
                    const cell = row.get(cell_idx).?;
                    self.allocator.free(cell);
                }
                row.deinit();
            }
            rows_for_cleanup.deinit();
        }

        // Build rows
        i = 0;
        while (i < length) : (i += 1) {
            var row = infra.List([]const u8).init(self.allocator);

            // Add index column
            const index_cell = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
            try row.append(index_cell);

            // Get element
            const index_str = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
            defer self.allocator.free(index_str);

            const element = rt.vtable.getProperty(rt.context, data, index_str);

            // Add value columns
            for (columns.items()) |col| {
                if (element) |elem| {
                    if (rt.vtable.isObject(rt.context, elem)) {
                        const value = rt.vtable.getProperty(rt.context, elem, col);
                        if (value) |val| {
                            const val_str = try rt.vtable.toString(rt.context, val, self.allocator);
                            try row.append(val_str);
                        } else {
                            try row.append(try self.allocator.dupe(u8, ""));
                        }
                    } else {
                        // Element is primitive, not an object
                        try row.append(try self.allocator.dupe(u8, ""));
                    }
                } else {
                    try row.append(try self.allocator.dupe(u8, ""));
                }
            }

            try rows.append(row);
        }

        // Step 6: Calculate column widths
        const columns_slice = columns.items();
        const rows_slice = rows.items();

        var col_widths = try self.allocator.alloc(usize, columns_slice.len + 1);
        defer self.allocator.free(col_widths);

        // Initialize with header widths
        col_widths[0] = "(index)".len;
        for (columns_slice, 1..) |col, idx| {
            col_widths[idx] = col.len;
        }

        // Update with cell widths
        for (rows_slice) |row| {
            const row_slice = row.items();
            for (row_slice, 0..) |cell, idx| {
                col_widths[idx] = @max(col_widths[idx], cell.len);
            }
        }

        // Step 7: Build ASCII table
        var table = infra.List(u8).init(self.allocator);
        defer table.deinit();

        // Top border
        try table.appendSlice("┌");
        for (col_widths, 0..) |width, idx| {
            for (0..width + 2) |_| try table.appendSlice("─");
            if (idx < col_widths.len - 1) {
                try table.appendSlice("┬");
            }
        }
        try table.appendSlice("┐\n");

        // Header row
        try table.appendSlice("│ (index)");
        for (0..col_widths[0] - "(index)".len) |_| try table.append(' ');
        try table.append(' ');

        for (columns_slice, 1..) |col, idx| {
            try table.appendSlice("│ ");
            try table.appendSlice(col);
            for (0..col_widths[idx] - col.len) |_| try table.append(' ');
            try table.append(' ');
        }
        try table.appendSlice("│\n");

        // Header separator
        try table.appendSlice("├");
        for (col_widths, 0..) |width, idx| {
            for (0..width + 2) |_| try table.appendSlice("─");
            if (idx < col_widths.len - 1) {
                try table.appendSlice("┼");
            }
        }
        try table.appendSlice("┤\n");

        // Data rows
        for (rows_slice) |row| {
            const row_slice = row.items();
            for (row_slice, 0..) |cell, idx| {
                try table.appendSlice("│ ");
                try table.appendSlice(cell);
                for (0..col_widths[idx] - cell.len) |_| try table.append(' ');
                try table.append(' ');
            }
            try table.appendSlice("│\n");
        }

        // Bottom border
        try table.appendSlice("└");
        for (col_widths, 0..) |width, idx| {
            for (0..width + 2) |_| try table.appendSlice("─");
            if (idx < col_widths.len - 1) {
                try table.appendSlice("┴");
            }
        }
        try table.appendSlice("┘\n");

        // Step 8: Print the table
        const table_items = table.items();
        const table_value = webidl.JSValue{ .string = table_items };
        self.printer(.table, &.{table_value});
    }
    /// trace(...data)
    /// 
    /// WHATWG Console Standard lines 109-117:
    /// Get the call stack and log it with optional formatted data as label.
    /// 
    /// IDL: undefined trace(any... data);
    pub fn call_trace(self: *Console, data: []const webidl.JSValue) void {
        // WHATWG Console Standard lines 109-117 (trace algorithm):
        // 1. Let trace be some implementation-defined stack trace representation (stack of CallSites)
        // 2. Optionally, let formatted_data be the result of Formatter(data)
        // 3. Incorporate formatted_data as a label for trace
        // 4. Perform Printer("trace", « trace »)

        // If runtime is available, capture stack trace
        if (self.runtime) |rt| {
            const frames = rt.vtable.captureStackTrace(rt.context, self.allocator) catch {
                // If stack capture fails, fall back to simple trace
                self.logger(.trace, data);
                return;
            };
            defer {
                for (frames) |frame| {
                    if (frame.function_name) |name| self.allocator.free(name);
                    if (frame.file_name) |file| self.allocator.free(file);
                }
                self.allocator.free(frames);
            }

            // Format stack trace as string
            var trace_str = infra.List(u8).init(self.allocator);
            defer trace_str.deinit();

            // Add "Trace" header with optional data label
            if (data.len > 0) {
                const formatted = self.formatter(data) catch data;
                defer if (formatted.ptr != data.ptr) self.allocator.free(formatted);

                for (formatted) |arg| {
                    const str = switch (arg) {
                        .string => |s| s,
                        else => "[object]",
                    };
                    trace_str.appendSlice(str) catch {};
                    trace_str.append(' ') catch {};
                }
            }
            trace_str.appendSlice("Trace\n") catch {};

            // Format each stack frame
            for (frames) |frame| {
                const formatted_frame = frame.format(self.allocator) catch continue;
                defer self.allocator.free(formatted_frame);

                trace_str.appendSlice(formatted_frame) catch {};
                trace_str.append('\n') catch {};
            }

            // Print the complete stack trace
            const trace_items = trace_str.items();
            const trace_value = webidl.JSValue{ .string = trace_items };
            self.printer(.trace, &.{trace_value});
        } else {
            // Fallback: Just print with trace level (no stack capture)
            self.logger(.trace, data);
        }
    }
    /// warn(...data)
    /// 
    /// WHATWG Console Standard lines 120-122:
    /// Perform Logger("warn", data).
    /// 
    /// IDL: undefined warn(any... data);
    pub fn call_warn(self: *Console, data: []const webidl.JSValue) void {
        self.logger(.warn, data);
    }
    /// dir(item, options)
    /// 
    /// WHATWG Console Standard lines 125-129:
    /// Apply generic JavaScript object formatting to item and print.
    /// 
    /// IDL: undefined dir(optional any item, optional object? options);
    pub fn call_dir(self: *Console, item: ?*const webidl.JSValue, options: ?*const webidl.JSValue) void {
        // Step 1: Let object be item with generic JavaScript object formatting applied
        const obj = if (item) |i| i.* else webidl.JSValue{ .undefined = {} };

        // Apply generic JavaScript object formatting
        const formatted_object = if (self.runtime) |rt| blk: {
            // With runtime: use toString for object formatting
            const formatted_str = rt.vtable.toString(rt.context, obj, self.allocator) catch {
                // Fall back to obj itself
                break :blk obj;
            };
            defer self.allocator.free(formatted_str);
            break :blk webidl.JSValue{ .string = formatted_str };
        } else obj;

        // Step 2: Perform Printer("dir", « object », options)
        // Note: Printer signature in our implementation doesn't have options parameter,
        // so we pass it via the printer function's implementation-defined behavior
        _ = options; // Options would be used by printer implementation for formatting hints

        const args: [1]webidl.JSValue = .{formatted_object};
        self.printer(.dir, &args);
    }
    /// dirxml(...data)
    /// 
    /// WHATWG Console Standard lines 132-142:
    /// Convert each item to a DOM tree representation (if possible) and log.
    /// 
    /// IDL: undefined dirxml(any... data);
    pub fn call_dirxml(self: *Console, data: []const webidl.JSValue) void {
        // Step 1: Let finalList be a new list, initially empty
        if (self.runtime) |rt| {
            // With runtime: convert DOM nodes to tree representation
            var final_list = infra.List(webidl.JSValue).init(self.allocator);
            defer {
                // Free allocated strings
                var i: usize = 0;
                while (i < final_list.size()) : (i += 1) {
                    const item = final_list.get(i).?;
                    if (item == .string) {
                        self.allocator.free(item.string);
                    }
                }
                final_list.deinit();
            }

            // Step 2: For each item of data
            for (data) |item| {
                // Step 2.1: Let converted be a DOM tree representation of item if possible;
                // otherwise let converted be item with optimally useful formatting applied
                if (rt.vtable.isDOMNode(rt.context, item)) {
                    // Item is a DOM node - convert to tree representation
                    const dom_string = rt.vtable.toDOMString(rt.context, item, self.allocator) catch {
                        // Failed to convert - use item as-is
                        final_list.append(item) catch return;
                        continue;
                    };
                    // Keep ownership - will be freed in defer above
                    final_list.append(.{ .string = dom_string }) catch {
                        self.allocator.free(dom_string);
                        return;
                    };
                } else {
                    // Not a DOM node - apply optimal formatting (toString)
                    const formatted = rt.vtable.toString(rt.context, item, self.allocator) catch {
                        // Failed to format - use item as-is
                        final_list.append(item) catch return;
                        continue;
                    };
                    // Keep ownership - will be freed in defer above
                    final_list.append(.{ .string = formatted }) catch {
                        self.allocator.free(formatted);
                        return;
                    };
                }
            }

            // Step 3: Perform Logger("dirxml", finalList)
            self.logger(.dirxml, final_list.items());
        } else {
            // No runtime - simple logging without DOM conversion
            self.logger(.dirxml, data);
        }
    }
    /// count(label)
    /// 
    /// WHATWG Console Standard lines 150-160:
    /// Increment the count for label and log "label: count".
    /// 
    /// IDL: undefined count(optional DOMString label = "default");
    pub fn call_count(self: *Console, label: webidl.DOMString) !void {
        // Step 1: Let map be the associated count map
        // (self.count_map)

        // Step 2-3: If map[label] exists, increment it; otherwise set to 1
        const current_count = self.count_map.get(label) orelse 0;
        const new_count = current_count + 1;
        try self.count_map.set(label, new_count);

        // Step 4: Let concat be the concatenation of label, U+003A (:),
        // U+0020 SPACE, and ToString(map[label])
        // Optimization: Intern the UTF-8 label to avoid repeated conversions
        const label_utf8_temp = try infra.string.utf16ToUtf8(self.allocator, label);
        defer self.allocator.free(label_utf8_temp);

        const label_utf8 = try self.internLabel(label_utf8_temp);
        // Note: label_utf8 is now from pool, no need to free

        const concat_utf8 = try std.fmt.allocPrint(
            self.allocator,
            "{s}: {d}",
            .{ label_utf8, new_count },
        );
        defer self.allocator.free(concat_utf8);

        // Step 5: Perform Logger("count", « concat »)
        const args: [1]webidl.JSValue = .{webidl.JSValue{ .string = concat_utf8 }};
        self.printer(.count, &args);
    }
    /// countReset(label)
    /// 
    /// WHATWG Console Standard lines 163-173:
    /// Reset the count for label to 0, or report a warning if it doesn't exist.
    /// 
    /// IDL: undefined countReset(optional DOMString label = "default");
    pub fn call_countReset(self: *Console, label: webidl.DOMString) !void {
        // Step 1: Let map be the associated count map
        // (self.count_map)

        // Step 2: If map[label] exists, set to 0
        if (self.count_map.contains(label)) {
            try self.count_map.set(label, 0);
        } else {
            // Step 3: Otherwise, report warning
            const label_utf8 = try infra.string.utf16ToUtf8(self.allocator, label);
            defer self.allocator.free(label_utf8);

            const message = try std.fmt.allocPrint(
                self.allocator,
                "Count for '{s}' does not exist",
                .{label_utf8},
            );
            defer self.allocator.free(message);

            // Perform Logger("countReset", « message »)
            const args: [1]webidl.JSValue = .{webidl.JSValue{ .string = message }};
            self.printer(.count_reset, &args);
        }
    }
    /// group(...data)
    /// 
    /// WHATWG Console Standard lines 181-194:
    /// Create a new expanded group with optional label and push to stack.
    /// 
    /// IDL: undefined group(any... data);
    pub fn call_group(self: *Console, data: []const webidl.JSValue) !void {
        // Step 1: Let group be a new group
        var group: Group = undefined;

        // Step 2-3: If data is not empty, let groupLabel be result of Formatter(data)
        // Otherwise, let groupLabel be implementation-chosen label
        if (data.len > 0) {
            // Use Formatter to format the label
            const formatted = try self.formatter(data);
            defer if (formatted.ptr != data.ptr) self.allocator.free(formatted);

            // Convert first formatted arg to DOMString for group label
            const label = switch (formatted[0]) {
                .string => |s| try infra.string.utf8ToUtf16(self.allocator, s),
                .number => |n| blk: {
                    const temp = try std.fmt.allocPrint(self.allocator, "{d}", .{n});
                    defer self.allocator.free(temp);
                    break :blk try infra.string.utf8ToUtf16(self.allocator, temp);
                },
                .boolean => |b| try infra.string.utf8ToUtf16(self.allocator, if (b) "true" else "false"),
                .null => try infra.string.utf8ToUtf16(self.allocator, "null"),
                .undefined => try infra.string.utf8ToUtf16(self.allocator, "undefined"),
            };
            group = Group.init(label);
        } else {
            // No label provided - use null (implementation-chosen default)
            group = Group.init(null);
        }

        // Step 4: Optionally, group should be expanded by default
        // (Already set by Group.init - collapsed = false)

        // Step 5: Perform Printer("group", « group »)
        if (group.label) |lbl| {
            const label_utf8 = try infra.string.utf16ToUtf8(self.allocator, lbl);
            defer self.allocator.free(label_utf8);

            const label_js = webidl.JSValue{ .string = label_utf8 };
            self.printer(.group, &.{label_js});
        } else {
            self.printer(.group, &.{});
        }

        // Step 6: Push group onto the appropriate group stack
        try self.group_stack.push(group);
    }
    /// groupCollapsed(...data)
    /// 
    /// WHATWG Console Standard lines 197-208:
    /// Create a new collapsed group with optional label and push to stack.
    /// 
    /// IDL: undefined groupCollapsed(any... data);
    pub fn call_groupCollapsed(self: *Console, data: []const webidl.JSValue) !void {
        // Step 1: Let group be a new group
        var group: Group = undefined;

        // Step 2-3: If data is not empty, let groupLabel be result of Formatter(data)
        // Otherwise, let groupLabel be implementation-chosen label
        if (data.len > 0) {
            // Use Formatter to format the label
            const formatted = try self.formatter(data);
            defer if (formatted.ptr != data.ptr) self.allocator.free(formatted);

            // Convert first formatted arg to DOMString for group label
            const label = switch (formatted[0]) {
                .string => |s| try infra.string.utf8ToUtf16(self.allocator, s),
                .number => |n| blk: {
                    const temp = try std.fmt.allocPrint(self.allocator, "{d}", .{n});
                    defer self.allocator.free(temp);
                    break :blk try infra.string.utf8ToUtf16(self.allocator, temp);
                },
                .boolean => |b| try infra.string.utf8ToUtf16(self.allocator, if (b) "true" else "false"),
                .null => try infra.string.utf8ToUtf16(self.allocator, "null"),
                .undefined => try infra.string.utf8ToUtf16(self.allocator, "undefined"),
            };
            group = Group.initCollapsed(label);
        } else {
            // No label provided - use null (implementation-chosen default)
            group = Group.initCollapsed(null);
        }

        // Step 4: Optionally, group should be collapsed by default
        // (Already set by Group.initCollapsed - collapsed = true)

        // Step 5: Perform Printer("groupCollapsed", « group »)
        if (group.label) |lbl| {
            const label_utf8 = try infra.string.utf16ToUtf8(self.allocator, lbl);
            defer self.allocator.free(label_utf8);

            const label_js = webidl.JSValue{ .string = label_utf8 };
            self.printer(.group_collapsed, &.{label_js});
        } else {
            self.printer(.group_collapsed, &.{});
        }

        // Step 6: Push group onto the appropriate group stack
        try self.group_stack.push(group);
    }
    /// groupEnd()
    /// 
    /// WHATWG Console Standard lines 211-213:
    /// Pop the last group from the group stack.
    /// 
    /// IDL: undefined groupEnd();
    pub fn call_groupEnd(self: *Console) void {
        // Step 1: Pop the last group from the group stack
        if (self.group_stack.pop()) |popped_group| {
            // Free the label if it was allocated
            if (popped_group.label) |lbl| {
                self.allocator.free(lbl);
            }

            // Step 2: Optionally, notify user that the group has ended
            const empty_args: [0]webidl.JSValue = .{};
            self.printer(.group, &empty_args);
        }
        // If stack is empty, pop returns null and we do nothing
        // (This is spec-compliant - no error on empty stack)
    }
    /// time(label)
    /// 
    /// WHATWG Console Standard lines 221-225:
    /// Start a timer with the given label. If the timer already exists,
    /// optionally report a warning and return.
    /// 
    /// IDL: undefined time(optional DOMString label = "default");
    pub fn call_time(self: *Console, label: webidl.DOMString) !void {
        // Step 1: If timer table contains an entry with key label, return
        // (optionally reporting a warning)
        if (self.timer_table.contains(label)) {
            // Timer already exists - report warning
            const label_utf8 = try infra.string.utf16ToUtf8(self.allocator, label);
            defer self.allocator.free(label_utf8);

            const warning = try std.fmt.allocPrint(
                self.allocator,
                "Timer '{s}' already exists",
                .{label_utf8},
            );
            defer self.allocator.free(warning);

            const args: [1]webidl.JSValue = .{webidl.JSValue{ .string = warning }};
            self.printer(.warn, &args);
            return;
        }

        // Step 2: Set the value of the entry with key label to the current time
        const now = infra.Moment.now();
        try self.timer_table.set(label, now);
    }
    /// timeLog(label, ...data)
    /// 
    /// WHATWG Console Standard lines 228-242:
    /// Log the elapsed time for the timer with the given label.
    /// The elapsed time is prepended to the provided data.
    /// 
    /// IDL: undefined timeLog(optional DOMString label = "default", any... data);
    pub fn call_timeLog(self: *Console, label: webidl.DOMString, data: []const webidl.JSValue) !void {
        // Step 1: Let timerTable be the associated timer table
        // (self.timer_table)

        // Step 2: Let startTime be timerTable[label]
        const start_time = self.timer_table.get(label) orelse {
            // Timer not found - report warning
            const label_utf8 = try infra.string.utf16ToUtf8(self.allocator, label);
            defer self.allocator.free(label_utf8);

            const warning = try std.fmt.allocPrint(
                self.allocator,
                "Timer '{s}' does not exist",
                .{label_utf8},
            );
            defer self.allocator.free(warning);

            const args: [1]webidl.JSValue = .{webidl.JSValue{ .string = warning }};
            self.printer(.warn, &args);
            return;
        };

        // Step 3: Let duration be a string representing the difference between
        // the current time and startTime
        const now = infra.Moment.now();
        const duration = now.since(start_time);
        const duration_ms = duration.toMilliseconds();

        // Format duration as "4650.69 ms" (implementation-defined format)
        const duration_str = try std.fmt.allocPrint(
            self.allocator,
            "{d:.2} ms",
            .{duration_ms},
        );
        defer self.allocator.free(duration_str);

        // Step 4: Let concat be the concatenation of label, U+003A (:),
        // U+0020 SPACE, and the string representation of duration
        // Optimization: Intern the UTF-8 label to avoid repeated conversions
        const label_utf8_temp = try infra.string.utf16ToUtf8(self.allocator, label);
        defer self.allocator.free(label_utf8_temp);

        const label_utf8 = try self.internLabel(label_utf8_temp);
        // Note: label_utf8 is now from pool, no need to free

        const concat_utf8 = try std.fmt.allocPrint(
            self.allocator,
            "{s}: {s}",
            .{ label_utf8, duration_str },
        );
        defer self.allocator.free(concat_utf8);

        // Step 5: Prepend concat to data
        // Step 6: Perform Printer("timeLog", data)
        // Build args array with concat prepended to data
        const args = try self.allocator.alloc(webidl.JSValue, data.len + 1);
        defer self.allocator.free(args);

        args[0] = webidl.JSValue{ .string = concat_utf8 };
        @memcpy(args[1..], data);

        self.printer(.time_log, args);
    }
    /// timeEnd(label)
    /// 
    /// WHATWG Console Standard lines 258-270:
    /// Stop the timer with the given label, log the total elapsed time,
    /// and remove the timer from the timer table.
    /// 
    /// IDL: undefined timeEnd(optional DOMString label = "default");
    pub fn call_timeEnd(self: *Console, label: webidl.DOMString) !void {
        // Step 1: Let timerTable be the associated timer table
        // (self.timer_table)

        // Step 2: Let startTime be timerTable[label]
        const start_time = self.timer_table.get(label) orelse {
            // Timer not found - report warning
            const label_utf8 = try infra.string.utf16ToUtf8(self.allocator, label);
            defer self.allocator.free(label_utf8);

            const warning = try std.fmt.allocPrint(
                self.allocator,
                "Timer '{s}' does not exist",
                .{label_utf8},
            );
            defer self.allocator.free(warning);

            const args: [1]webidl.JSValue = .{webidl.JSValue{ .string = warning }};
            self.printer(.warn, &args);
            return;
        };

        // Step 3: Remove timerTable[label]
        _ = self.timer_table.remove(label);

        // Step 4: Let duration be a string representing the difference between
        // the current time and startTime
        const now = infra.Moment.now();
        const duration = now.since(start_time);
        const duration_ms = duration.toMilliseconds();

        // Format duration as "4650.69 ms" (implementation-defined format)
        const duration_str = try std.fmt.allocPrint(
            self.allocator,
            "{d:.2} ms",
            .{duration_ms},
        );
        defer self.allocator.free(duration_str);

        // Step 5: Let concat be the concatenation of label, U+003A (:),
        // U+0020 SPACE, and the string representation of duration
        // Optimization: Intern the UTF-8 label to avoid repeated conversions
        const label_utf8_temp = try infra.string.utf16ToUtf8(self.allocator, label);
        defer self.allocator.free(label_utf8_temp);

        const label_utf8 = try self.internLabel(label_utf8_temp);
        // Note: label_utf8 is now from pool, no need to free

        const concat_utf8 = try std.fmt.allocPrint(
            self.allocator,
            "{s}: {s}",
            .{ label_utf8, duration_str },
        );
        defer self.allocator.free(concat_utf8);

        // Step 6: Perform Printer("timeEnd", « concat »)
        const args: [1]webidl.JSValue = .{webidl.JSValue{ .string = concat_utf8 }};
        self.printer(.time_end, &args);
    }
};


// Tests
test "Console.clear - removes messages and empties groups" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    // Disable printer for testing (no stderr output)
    console.print_fn = null;

    // Add some messages
    const msg = webidl.JSValue{ .string = "Test message" };
    console.call_log(&.{msg});
    console.call_log(&.{msg});

    // Add a group
    const label = webidl.JSValue{ .string = "Test Group" };
    try console.call_group(&.{label});

    // Verify state before clear
    try testing.expect(console.message_buffer.size() > 0);
    try testing.expect(console.group_stack.items_list.size() > 0);

    // Clear console
    console.call_clear();

    // Verify everything is cleared
    try testing.expectEqual(@as(usize, 0), console.message_buffer.size());
    try testing.expectEqual(@as(usize, 0), console.group_stack.items_list.size());
}

test "Console.table - falls back to logging" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    // Disable printer
    console.print_fn = null;

    // Call table with some data
    const data = webidl.JSValue{ .string = "test data" };
    console.call_table(&data, null);

    // Verify message was logged (fallback behavior)
    try testing.expectEqual(@as(usize, 1), console.message_buffer.size());

    const msg = console.message_buffer.get(0).?;
    try testing.expectEqual(LogLevel.log, msg.log_level);
    try testing.expectEqual(@as(usize, 1), msg.args.len);
    try testing.expectEqualStrings("test data", msg.args[0].string);
}

test "Console.table - handles null data" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    // Call table with null
    console.call_table(null, null);

    // With null data, logger() receives empty args and returns early (line 209)
    // So no message is logged - this is correct per spec (nothing to log)
    try testing.expectEqual(@as(usize, 0), console.message_buffer.size());
}

// ============================================================================
// console.assert() Tests
// ============================================================================

test "Console.assert - true condition does nothing" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{
        .{ .string = "Should not appear" },
    };

    // Assert with true condition - should not log anything
    console.call_assert(true, data);

    try testing.expectEqual(@as(usize, 0), console.message_buffer.size());
}

test "Console.assert - false condition with empty data" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{};

    // Step 3: If data is empty, append message to data
    console.call_assert(false, data);

    try testing.expectEqual(@as(usize, 1), console.message_buffer.size());
    const msg = console.message_buffer.get(0).?;
    try testing.expectEqual(@as(usize, 1), msg.args.len);
    try testing.expectEqualStrings("Assertion failed", msg.args[0].string);
}

test "Console.assert - false condition with string first (concatenate)" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{
        .{ .string = "custom message" },
    };

    // Step 4.3: If first is a String, concatenate "Assertion failed: " + first
    console.call_assert(false, data);

    try testing.expectEqual(@as(usize, 1), console.message_buffer.size());
    const msg = console.message_buffer.get(0).?;
    try testing.expectEqual(@as(usize, 1), msg.args.len);
    try testing.expectEqualStrings("Assertion failed: custom message", msg.args[0].string);
}

test "Console.assert - false condition with non-string first (prepend)" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{
        .{ .number = 42.0 },
        .{ .string = "extra" },
    };

    // Step 4.2: If first is NOT a String, prepend message to data
    console.call_assert(false, data);

    try testing.expectEqual(@as(usize, 1), console.message_buffer.size());
    const msg = console.message_buffer.get(0).?;
    try testing.expectEqual(@as(usize, 3), msg.args.len);
    try testing.expectEqualStrings("Assertion failed", msg.args[0].string);
    try testing.expectEqual(@as(f64, 42.0), msg.args[1].number);
    try testing.expectEqualStrings("extra", msg.args[2].string);
}

test "Console.assert - false condition with string first and extra args" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{
        .{ .string = "error occurred" },
        .{ .number = 123.0 },
        .{ .string = "details" },
    };

    // Step 4.3.2: Set data[0] to concat, keep rest of args
    console.call_assert(false, data);

    try testing.expectEqual(@as(usize, 1), console.message_buffer.size());
    const msg = console.message_buffer.get(0).?;
    try testing.expectEqual(@as(usize, 3), msg.args.len);
    try testing.expectEqualStrings("Assertion failed: error occurred", msg.args[0].string);
    try testing.expectEqual(@as(f64, 123.0), msg.args[1].number);
    try testing.expectEqualStrings("details", msg.args[2].string);
}

// ============================================================================
// console.dirxml() Tests
// ============================================================================

test "Console.dirxml - without runtime - logs simple values" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{
        .{ .string = "test" },
        .{ .number = 42.0 },
        .{ .boolean = true },
    };

    // Should log values as-is without runtime
    console.call_dirxml(data);

    // Verify message was logged
    try testing.expectEqual(@as(usize, 1), console.message_buffer.size());
}

test "Console.dirxml - empty data" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{};

    // Should handle empty data gracefully
    console.call_dirxml(data);

    // Empty data should result in empty args to logger (which returns early)
    try testing.expectEqual(@as(usize, 0), console.message_buffer.size());
}

test "Console.dirxml - null and undefined values" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var console = try Console.init(allocator);
    defer console.deinit();

    console.print_fn = null;

    const data: []const webidl.JSValue = &.{
        .null,
        .undefined,
    };

    // Should handle null/undefined values
    console.call_dirxml(data);

    // Verify message was logged
    try testing.expectEqual(@as(usize, 1), console.message_buffer.size());
}
