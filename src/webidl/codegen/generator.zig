//! Code Generator from IR
//!
//! Generates clean, correct Zig code from EnhancedClassIR.
//!
//! Key improvements over string-based generation:
//! 1. All imports emitted once, deduplicated
//! 2. No shadowing conflicts (scope-aware)
//! 3. Proper handling of inherited methods
//! 4. Clean, maintainable output

const std = @import("std");
const Allocator = std.mem.Allocator;
const infra = @import("infra");
const ir = @import("ir.zig");

/// Generate Zig code from enhanced class IR
pub fn generateCode(
    allocator: Allocator,
    enhanced: ir.EnhancedClassIR,
) ![]const u8 {
    var output: std.ArrayList(u8) = .empty;
    errdefer output.deinit(allocator);

    const writer = output.writer(allocator);

    // Header
    try writeHeader(writer);

    // Imports (deduplicated, sorted)
    try writeImports(writer, enhanced.all_imports);

    // Class definition
    try writeClass(writer, enhanced);

    return output.toOwnedSlice(allocator);
}

/// Write file header
fn writeHeader(writer: anytype) !void {
    try writer.writeAll(
        \\// Auto-generated by webidl-codegen (AST/IR-based)
        \\// DO NOT EDIT - changes will be overwritten
        \\//
        \\// This file was generated from the source file with the same name.
        \\// Class definitions have been enhanced with:
        \\//   - Inherited methods from parent classes
        \\//   - Property getters and setters
        \\//   - Optimized field layouts
        \\//   - Automatic import resolution
        \\
        \\
    );
}

/// Write all imports
fn writeImports(writer: anytype, imports: []ir.Import) !void {
    // Always include std and webidl
    try writer.writeAll("const std = @import(\"std\");\n");
    try writer.writeAll("const webidl = @import(\"webidl\");\n");

    // Sort imports by name for consistent output
    var sorted_imports: std.ArrayList(ir.Import) = .empty;
    defer sorted_imports.deinit(std.heap.page_allocator);

    for (imports) |import| {
        try sorted_imports.append(std.heap.page_allocator, import);
    }

    // Simple bubble sort (small lists)
    var i: usize = 0;
    while (i < sorted_imports.items.len) : (i += 1) {
        var j: usize = i + 1;
        while (j < sorted_imports.items.len) : (j += 1) {
            if (std.mem.order(u8, sorted_imports.items[i].name, sorted_imports.items[j].name) == .gt) {
                const temp = sorted_imports.items[i];
                sorted_imports.items[i] = sorted_imports.items[j];
                sorted_imports.items[j] = temp;
            }
        }
    }

    // Write sorted imports
    for (sorted_imports.items) |import| {
        try writer.print("{}", .{import});
    }

    try writer.writeAll("\n");
}

/// Write class definition
fn writeClass(writer: anytype, enhanced: ir.EnhancedClassIR) !void {
    const class = enhanced.class;

    // Class doc comment
    if (class.doc_comment) |doc| {
        var lines = std.mem.splitScalar(u8, doc, '\n');
        while (lines.next()) |line| {
            try writer.print("/// {s}\n", .{line});
        }
    }

    // Class declaration
    try writer.print("pub const {s} = struct {{\n", .{class.name});

    // Fields
    if (enhanced.all_fields.len > 0) {
        try writer.writeAll("\n    // ========================================================================\n");
        try writer.writeAll("    // Fields\n");
        try writer.writeAll("    // ========================================================================\n\n");

        for (enhanced.all_fields) |field| {
            if (field.doc_comment) |doc| {
                try writer.print("    /// {s}\n", .{doc});
            }
            try writer.print("    {s}: {s},\n", .{ field.name, field.type_name });
        }
    }

    // Constants
    if (class.own_constants.len > 0) {
        try writer.writeAll("\n    // ========================================================================\n");
        try writer.writeAll("    // Constants\n");
        try writer.writeAll("    // ========================================================================\n\n");

        for (class.own_constants) |constant| {
            try writer.print("    {s}const {s}", .{ constant.visibility.toString(), constant.name });
            if (constant.type_name) |type_name| {
                try writer.print(": {s}", .{type_name});
            }
            try writer.print(" = {s};\n", .{constant.value});
        }
    }

    // Methods
    if (enhanced.all_methods.len > 0) {
        try writer.writeAll("\n    // ========================================================================\n");
        try writer.writeAll("    // Methods\n");
        try writer.writeAll("    // ========================================================================\n\n");

        for (enhanced.all_methods) |method| {
            try writeMethod(writer, method);
            try writer.writeAll("\n");
        }
    }

    try writer.writeAll("};\n");
}

/// Write a single method
fn writeMethod(writer: anytype, method: ir.Method) !void {
    // Doc comment
    if (method.doc_comment) |doc| {
        var lines = std.mem.splitScalar(u8, doc, '\n');
        while (lines.next()) |line| {
            try writer.print("    /// {s}\n", .{line});
        }
    }

    // Method signature
    const pub_str = if (method.modifiers.is_public) "pub " else "";
    const inline_str = if (method.modifiers.is_inline) "inline " else "";

    try writer.print("    {s}{s}fn {s}{s} {{\n", .{
        pub_str,
        inline_str,
        method.name,
        method.signature,
    });

    // Method body
    try writer.writeAll(method.body);

    try writer.writeAll("\n    }\n");
}
