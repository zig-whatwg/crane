//! Code Generator from IR
//!
//! Generates clean, correct Zig code from EnhancedClassIR.
//!
//! Key improvements over string-based generation:
//! 1. All imports emitted once, deduplicated
//! 2. No shadowing conflicts (scope-aware)
//! 3. Proper handling of inherited methods
//! 4. Clean, maintainable output

const std = @import("std");
const Allocator = std.mem.Allocator;
const infra = @import("infra");
const ir = @import("ir.zig");

/// Generate Zig code from enhanced class IR
/// If module_definitions is provided, they will be included after imports
pub fn generateCode(
    allocator: Allocator,
    enhanced: ir.EnhancedClassIR,
    module_definitions: ?[]const u8,
) ![]const u8 {
    var output: std.ArrayList(u8) = .empty;
    errdefer output.deinit(allocator);

    const writer = output.writer(allocator);

    // Header
    try writeHeader(writer);

    // Imports (deduplicated, sorted)
    try writeImports(writer, enhanced.all_imports);

    // Module-level definitions (if this is the first class in the file)
    if (module_definitions) |defs| {
        if (defs.len > 0) {
            try writer.writeAll("\n");
            try writer.writeAll(defs);
            try writer.writeAll("\n");
        }
    }

    // Add helper functions needed by inherited methods
    if (needsCallbackEquals(enhanced)) {
        try writer.writeAll("\n");
        try writer.writeAll(
            \\/// Compare two callbacks for equality (from EventTarget)
            \\pub fn callbackEquals(a: ?webidl.JSValue, b: ?webidl.JSValue) bool {
            \\    if (a == null and b == null) return true;
            \\    if (a == null or b == null) return false;
            \\    const a_val = a.?;
            \\    const b_val = b.?;
            \\    if (@as(std.meta.Tag(webidl.JSValue), a_val) != @as(std.meta.Tag(webidl.JSValue), b_val)) {
            \\        return false;
            \\    }
            \\    return switch (a_val) {
            \\        .undefined, .null => true,
            \\        .boolean => |a_bool| a_bool == b_val.boolean,
            \\        .number => |a_num| a_num == b_val.number,
            \\        .string => |a_str| std.mem.eql(u8, a_str, b_val.string),
            \\        .object => |a_obj| @intFromPtr(&a_obj) == @intFromPtr(&b_val.object),
            \\        else => false,
            \\    };
            \\}
            \\
        );
    }

    try writer.writeAll("\n");

    // Class definition
    try writeClass(allocator, writer, enhanced);

    return output.toOwnedSlice(allocator);
}

/// Check if class needs callbackEquals helper function
fn needsCallbackEquals(enhanced: ir.EnhancedClassIR) bool {
    const class = enhanced.class;

    // EventTarget itself has it in module definitions
    if (std.mem.eql(u8, class.name, "EventTarget")) return false;

    // Check if any method uses callbackEquals
    for (enhanced.all_methods) |method| {
        if (std.mem.indexOf(u8, method.body, "callbackEquals") != null) {
            return true;
        }
    }

    return false;
}

/// Check if class needs Node constant aliases
fn needsNodeConstantAliases(enhanced: ir.EnhancedClassIR) bool {
    const class = enhanced.class;

    // Node itself doesn't need aliases
    if (std.mem.eql(u8, class.name, "Node")) return false;

    // Check if any method uses Node constants
    for (enhanced.all_methods) |method| {
        if (std.mem.indexOf(u8, method.body, "ELEMENT_NODE") != null or
            std.mem.indexOf(u8, method.body, "ATTRIBUTE_NODE") != null or
            std.mem.indexOf(u8, method.body, "DOCUMENT_NODE") != null or
            std.mem.indexOf(u8, method.body, "DOCUMENT_TYPE_NODE") != null)
        {
            return true;
        }
    }

    return false;
}

/// Write file header
fn writeHeader(writer: anytype) !void {
    try writer.writeAll(
        \\// Auto-generated by webidl-codegen (AST/IR-based)
        \\// DO NOT EDIT - changes will be overwritten
        \\//
        \\// This file was generated from the source file with the same name.
        \\// Class definitions have been enhanced with:
        \\//   - Inherited methods from parent classes
        \\//   - Property getters and setters
        \\//   - Optimized field layouts
        \\//   - Automatic import resolution
        \\
        \\
    );
}

/// Write all imports
fn writeImports(writer: anytype, imports: []ir.Import) !void {
    // Sort imports by name for consistent output
    var sorted_imports: std.ArrayList(ir.Import) = .empty;
    defer sorted_imports.deinit(std.heap.page_allocator);

    for (imports) |import| {
        try sorted_imports.append(std.heap.page_allocator, import);
    }

    // Simple bubble sort (small lists)
    var i: usize = 0;
    while (i < sorted_imports.items.len) : (i += 1) {
        var j: usize = i + 1;
        while (j < sorted_imports.items.len) : (j += 1) {
            if (std.mem.order(u8, sorted_imports.items[i].name, sorted_imports.items[j].name) == .gt) {
                const temp = sorted_imports.items[i];
                sorted_imports.items[i] = sorted_imports.items[j];
                sorted_imports.items[j] = temp;
            }
        }
    }

    // Write sorted imports
    for (sorted_imports.items) |import| {
        const vis = if (import.visibility == .public) "pub " else "";
        if (import.is_type) {
            // Type import: const Foo = @import("foo").Foo;
            try writer.print("{s}const {s} = @import(\"{s}\").{s};\n", .{
                vis,
                import.name,
                import.module,
                import.name,
            });
        } else {
            // Module import: const std = @import("std");
            try writer.print("{s}const {s} = @import(\"{s}\");\n", .{
                vis,
                import.name,
                import.module,
            });
        }
    }

    try writer.writeAll("\n");
}

/// Write class definition
fn writeClass(allocator: Allocator, writer: anytype, enhanced: ir.EnhancedClassIR) !void {
    const class = enhanced.class;

    // Class doc comment
    if (class.doc_comment) |doc| {
        var lines = std.mem.splitScalar(u8, doc, '\n');
        while (lines.next()) |line| {
            try writer.print("/// {s}\n", .{line});
        }
    }

    // Class declaration
    try writer.print("pub const {s} = struct {{\n", .{class.name});

    // Fields
    if (enhanced.all_fields.len > 0) {
        try writer.writeAll("\n    // ========================================================================\n");
        try writer.writeAll("    // Fields\n");
        try writer.writeAll("    // ========================================================================\n\n");

        for (enhanced.all_fields) |field| {
            if (field.doc_comment) |doc| {
                try writer.print("    /// {s}\n", .{doc});
            }
            try writer.print("    {s}: {s},\n", .{ field.name, field.type_name });
        }
    }

    // Constants
    const has_constants = class.own_constants.len > 0;
    const needs_node_constants = needsNodeConstantAliases(enhanced);

    if (has_constants or needs_node_constants) {
        try writer.writeAll("\n    // ========================================================================\n");
        try writer.writeAll("    // Constants\n");
        try writer.writeAll("    // ========================================================================\n\n");

        // Own constants
        for (class.own_constants) |constant| {
            try writer.print("    {s}const {s}", .{ constant.visibility.toString(), constant.name });
            if (constant.type_name) |type_name| {
                try writer.print(": {s}", .{type_name});
            }
            try writer.print(" = {s};\n", .{constant.value});
        }

        // Node constant aliases (for classes inheriting from Node)
        if (needs_node_constants and !std.mem.eql(u8, class.name, "Node")) {
            if (has_constants) try writer.writeAll("\n");
            try writer.writeAll("    // Node type constants (inherited)\n");
            try writer.writeAll("    pub const ELEMENT_NODE: u16 = Node.ELEMENT_NODE;\n");
            try writer.writeAll("    pub const ATTRIBUTE_NODE: u16 = Node.ATTRIBUTE_NODE;\n");
            try writer.writeAll("    pub const TEXT_NODE: u16 = Node.TEXT_NODE;\n");
            try writer.writeAll("    pub const CDATA_SECTION_NODE: u16 = Node.CDATA_SECTION_NODE;\n");
            try writer.writeAll("    pub const PROCESSING_INSTRUCTION_NODE: u16 = Node.PROCESSING_INSTRUCTION_NODE;\n");
            try writer.writeAll("    pub const COMMENT_NODE: u16 = Node.COMMENT_NODE;\n");
            try writer.writeAll("    pub const DOCUMENT_NODE: u16 = Node.DOCUMENT_NODE;\n");
            try writer.writeAll("    pub const DOCUMENT_TYPE_NODE: u16 = Node.DOCUMENT_TYPE_NODE;\n");
            try writer.writeAll("    pub const DOCUMENT_FRAGMENT_NODE: u16 = Node.DOCUMENT_FRAGMENT_NODE;\n");
        }
    }

    // Methods
    if (enhanced.all_methods.len > 0) {
        try writer.writeAll("\n    // ========================================================================\n");
        try writer.writeAll("    // Methods\n");
        try writer.writeAll("    // ========================================================================\n\n");

        for (enhanced.all_methods) |method| {
            try writeMethod(allocator, writer, method, enhanced.all_imports, class.name);
            try writer.writeAll("\n");
        }
    }

    try writer.writeAll("};\n");
}

/// Write a single method
fn writeMethod(allocator: Allocator, writer: anytype, method: ir.Method, top_level_imports: []ir.Import, class_name: []const u8) !void {
    // Doc comment
    if (method.doc_comment) |doc| {
        var lines = std.mem.splitScalar(u8, doc, '\n');
        while (lines.next()) |line| {
            try writer.print("    /// {s}\n", .{line});
        }
    }

    // Method signature
    const pub_str = if (method.modifiers.is_public) "pub " else "";
    const inline_str = if (method.modifiers.is_inline) "inline " else "";

    try writer.print("    {s}{s}fn {s}{s} {{\n", .{
        pub_str,
        inline_str,
        method.name,
        method.signature,
    });

    // Method body - strip local imports that shadow top-level imports or the current class
    const cleaned_body = try stripShadowingImports(allocator, method.body, top_level_imports, class_name);
    defer if (cleaned_body.ptr != method.body.ptr) allocator.free(cleaned_body);
    try writer.writeAll(cleaned_body);

    try writer.writeAll("\n    }\n");
}

/// Remove local imports from method body if they shadow top-level imports or the current class
/// Example: removes `const DocumentType = @import("document_type").DocumentType;`
/// if DocumentType is already imported at file level OR if it's the current class name
fn stripShadowingImports(allocator: Allocator, body: []const u8, top_level_imports: []ir.Import, class_name: []const u8) ![]const u8 {
    // Build set of imported names
    var imported_names = std.StringHashMap(void).init(allocator);
    defer imported_names.deinit();

    for (top_level_imports) |import| {
        try imported_names.put(import.name, {});
    }

    // Also add the current class name to prevent self-reference shadowing
    try imported_names.put(class_name, {});

    // Scan for local imports: `const Name = @import("...")`
    var result: std.ArrayList(u8) = .empty;
    errdefer result.deinit(allocator);

    var pos: usize = 0;
    while (pos < body.len) {
        // Look for pattern: const Name = @import(
        const const_pos = std.mem.indexOfPos(u8, body, pos, "const ") orelse {
            // No more consts, append rest
            try result.appendSlice(allocator, body[pos..]);
            break;
        };

        // Append everything before this const
        try result.appendSlice(allocator, body[pos..const_pos]);

        // Check if this is an import statement
        const after_const = const_pos + "const ".len;
        const eq_pos = std.mem.indexOfScalarPos(u8, body, after_const, '=') orelse {
            // No = sign, not an import, keep it
            try result.appendSlice(allocator, "const ");
            pos = after_const;
            continue;
        };

        const name_end = eq_pos;
        // Trim whitespace
        var name_start = after_const;
        while (name_start < name_end and std.ascii.isWhitespace(body[name_start])) : (name_start += 1) {}
        var name_end_trimmed = name_end;
        while (name_end_trimmed > name_start and std.ascii.isWhitespace(body[name_end_trimmed - 1])) : (name_end_trimmed -= 1) {}

        const name = body[name_start..name_end_trimmed];

        // Check if this is an @import statement
        const after_eq = eq_pos + 1;
        const import_pos = std.mem.indexOfPos(u8, body, after_eq, "@import(") orelse {
            // Not an import, keep it
            try result.appendSlice(allocator, body[const_pos..after_eq]);
            pos = after_eq;
            continue;
        };

        // This is a const Name = @import(...); statement
        // Find the semicolon
        const semicolon_pos = std.mem.indexOfScalarPos(u8, body, import_pos, ';') orelse {
            // No semicolon found, keep it
            try result.appendSlice(allocator, body[const_pos..]);
            pos = body.len;
            break;
        };

        // Check if this name is already imported at top level
        if (imported_names.contains(name)) {
            // Skip this entire line (it shadows a top-level import)
            // Find the end of the line
            const newline_pos = std.mem.indexOfScalarPos(u8, body, semicolon_pos, '\n') orelse body.len;
            pos = newline_pos;
            if (pos < body.len and body[pos] == '\n') pos += 1; // Skip the newline
        } else {
            // Keep this import (not shadowing)
            try result.appendSlice(allocator, body[const_pos .. semicolon_pos + 1]);
            pos = semicolon_pos + 1;
        }
    }

    return result.toOwnedSlice(allocator);
}
