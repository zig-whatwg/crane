//! AST-Based Code Generation Integration
//!
//! This module provides the main entry point for AST/IR-based codegen,
//! integrating the parser, optimizer, and generator.

const std = @import("std");
const Allocator = std.mem.Allocator;
const infra = @import("infra");
const ir = @import("ir.zig");
const parser = @import("parser.zig");
const optimizer = @import("optimizer.zig");
const generator = @import("generator.zig");

/// Generate enhanced code from a source file using AST/IR pipeline
pub fn generateEnhancedFile(
    allocator: Allocator,
    source_path: []const u8,
    source_content: []const u8,
    registry: *optimizer.ClassRegistry,
) ![]const u8 {
    // Step 1: Parse source into IR
    var file_ir = try parser.parseFile(allocator, source_content, source_path);
    defer file_ir.deinit(allocator);

    // Step 2: Register all classes
    for (file_ir.classes) |*class| {
        try registry.register(class);
    }

    // Step 3: Enhance each class (resolve inheritance, imports)
    var output: std.ArrayList(u8) = .empty;
    errdefer output.deinit(allocator);

    const writer = output.writer(allocator);

    // Write header comment
    try writer.writeAll(
        \\// Auto-generated by webidl-codegen (AST/IR-based)
        \\// DO NOT EDIT - changes will be overwritten
        \\
        \\
    );

    // Process each class
    for (file_ir.classes, 0..) |*class, idx| {
        var enhanced = try optimizer.enhanceClass(allocator, class, registry, file_ir.module_imports, file_ir.module_definitions);
        defer enhanced.deinit(allocator);

        // Include module definitions only for the first class in the file
        const module_defs = if (idx == 0) file_ir.module_definitions else null;
        const class_code = try generator.generateCode(allocator, enhanced, module_defs);
        defer allocator.free(class_code);

        try writer.writeAll(class_code);
        try writer.writeAll("\n\n");
    }

    return output.toOwnedSlice(allocator);
}

/// Process all files in a directory using AST/IR pipeline
pub fn generateAllFiles(
    allocator: Allocator,
    source_dir: []const u8,
    output_dir: []const u8,
) !void {
    var registry = optimizer.ClassRegistry.init(allocator);
    defer registry.deinit();

    // First pass: parse all files and build registry
    var dir = try std.fs.cwd().openDir(source_dir, .{ .iterate = true });
    defer dir.close();

    var iter = dir.iterate();
    var file_irs = infra.List(ir.FileIR).init(allocator);
    defer {
        for (file_irs.items) |*file_ir| {
            file_ir.deinit(allocator);
        }
        file_irs.deinit();
    }

    while (try iter.next()) |entry| {
        if (entry.kind != .file) continue;
        if (!std.mem.endsWith(u8, entry.name, ".zig")) continue;

        const source_path = try std.fs.path.join(allocator, &.{ source_dir, entry.name });
        defer allocator.free(source_path);

        const source_content = try dir.readFileAlloc(allocator, entry.name, 10 * 1024 * 1024);
        defer allocator.free(source_content);

        const file_ir = try parser.parseFile(allocator, source_content, source_path);

        // Register classes
        for (file_ir.classes) |*class| {
            try registry.register(class);
        }

        try file_irs.append(file_ir);
    }

    // Second pass: enhance and generate
    for (file_irs.items) |file_ir| {
        if (file_ir.classes.len == 0) continue;

        var output: std.ArrayList(u8) = .empty;
        errdefer output.deinit(allocator);

        const writer = output.writer(allocator);

        // Write file header
        try writer.writeAll(
            \\// Auto-generated by webidl-codegen (AST/IR-based)
            \\// DO NOT EDIT - changes will be overwritten
            \\
            \\
        );

        // Process each class in the file
        for (file_ir.classes, 0..) |*class, idx| {
            var enhanced = try optimizer.enhanceClass(allocator, class, &registry, file_ir.module_imports, file_ir.module_definitions);
            defer enhanced.deinit(allocator);

            // Include module definitions only for the first class in the file
            const module_defs = if (idx == 0) file_ir.module_definitions else null;
            const class_code = try generator.generateCode(allocator, enhanced, module_defs);
            defer allocator.free(class_code);

            try writer.writeAll(class_code);
            try writer.writeAll("\n\n");
        }

        // Write to output file
        const output_path = try std.fs.path.join(allocator, &.{
            output_dir,
            std.fs.path.basename(file_ir.path),
        });
        defer allocator.free(output_path);

        const output_file = try std.fs.cwd().createFile(output_path, .{});
        defer output_file.close();

        try output_file.writeAll(output.items);
    }
}
