// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! WritableStreamDefaultController class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#ws-default-controller-class
//! IDL: specs/streams.idl lines 161-165
//!
//! Controls a WritableStream's state and internal queue.

const std = @import("std");

const webidl = @import("webidl");
const common = @import("common");
const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
const eventLoop = @import("eventLoop");
const AsyncPromise = @import("async_promise").AsyncPromise;

/// Placeholder for AbortSignal (from DOM spec)
pub const AbortSignal = opaque {};
/// WritableStreamDefaultController WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface WritableStreamDefaultController {
/// readonly attribute AbortSignal signal;
/// undefined error(optional any e);
/// };
/// ```
pub const WritableStreamDefaultController = struct {
    allocator: std.mem.Allocator,
    /// [[abortAlgorithm]]: Promise-returning algorithm for abort
    abortAlgorithm: common.AbortAlgorithm,
    /// [[closeAlgorithm]]: Promise-returning algorithm for close
    closeAlgorithm: common.CloseAlgorithm,
    /// [[queue]]: Queue-with-sizes for internal chunk queue
    queue: QueueWithSizes,
    /// [[signal]]: AbortSignal for abort notifications
    signal: ?*AbortSignal,
    /// [[started]]: boolean - underlying sink has finished starting
    started: bool,
    /// [[strategyHWM]]: High water mark for backpressure
    strategyHwm: f64,
    /// [[strategySizeAlgorithm]]: Algorithm to calculate chunk size
    strategySizeAlgorithm: common.SizeAlgorithm,
    /// [[stream]]: The WritableStream instance controlled (will be a pointer in full implementation)
    stream: ?*anyopaque,
    /// [[writeAlgorithm]]: Promise-returning algorithm for write
    writeAlgorithm: common.WriteAlgorithm,
    /// Event loop for async operations
    eventLoop: eventLoop.EventLoop,
    /// Optional transform controller for TransformStream integration
    /// When set, writes will be routed through the transform controller
    transformController: ?*anyopaque,

    /// Initialize a new controller (internal - not exposed via WebIDL)
    pub fn init(
        allocator: std.mem.Allocator,
        abortAlgorithm: common.AbortAlgorithm,
        closeAlgorithm: common.CloseAlgorithm,
        writeAlgorithm: common.WriteAlgorithm,
        strategyHwm: f64,
        strategySizeAlgorithm: common.SizeAlgorithm,
        loop: eventLoop.EventLoop,
    ) WritableStreamDefaultController {
        return .{
            .allocator = allocator,
            .abortAlgorithm = abortAlgorithm,
            .closeAlgorithm = closeAlgorithm,
            .queue = QueueWithSizes.init(allocator),
            .signal = null,
            .started = false,
            .strategyHwm = strategyHwm,
            .strategySizeAlgorithm = strategySizeAlgorithm,
            .stream = null,
            .writeAlgorithm = writeAlgorithm,
            .eventLoop = loop,
            .transformController = null,
        };
    }
    pub fn deinit(self: *WritableStreamDefaultController) void {
        self.queue.deinit();
    }
    /// Returns the AbortSignal associated with this controller.
    /// 
    /// IDL: readonly attribute AbortSignal signal;
    /// 
    /// Spec algorithm: § 5.4.3 "The signal getter steps are:"
    pub fn get_signal(self: *const WritableStreamDefaultController) webidl.JSValue {
        // Step 1: Return this.[[signal]].
        // In full implementation, would return proper AbortSignal WebIDL type
        _ = self;
        return webidl.JSValue{ .undefined = {} };
    }
    /// Errors the controlled writable stream.
    /// 
    /// IDL: undefined error(optional any e);
    /// 
    /// Spec algorithm: § 5.4.3 "The error(e) method steps are:"
    pub fn call_error(self: *WritableStreamDefaultController, e: webidl.Optional(webidl.JSValue)) void {
        // Step 1: Let state be this.[[stream]].[[state]].
        // Step 2: If state is not "writable", return.
        // (Simplified for now - full implementation would check stream state)

        const error_value = if (e.was_passed)
            common.JSValue.fromWebIDL(e.value)
        else
            common.JSValue.fromWebIDL(webidl.JSValue{ .undefined = {} });

        // Step 3: Perform ! WritableStreamDefaultControllerError(this, e).
        self.errorInternal(error_value);
    }
    /// Error the controller
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerError(controller, error)"
    fn errorInternal(self: *WritableStreamDefaultController, error_value: common.JSValue) void {
        _ = error_value;

        // Step 1: Let stream be controller.[[stream]].
        // Step 2: Assert: stream.[[state]] is "writable".

        // Step 3: Perform ! WritableStreamDefaultControllerClearAlgorithms(controller).
        self.clearAlgorithms();

        // Step 4: Perform ! WritableStreamStartErroring(stream, error).
        // (Would error the stream here - not implemented yet)
    }
    /// Clear all algorithm references
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerClearAlgorithms(controller)"
    fn clearAlgorithms(self: *WritableStreamDefaultController) void {
        // Reset algorithms to defaults to allow GC
        self.abortAlgorithm = common.defaultAbortAlgorithm();
        self.closeAlgorithm = common.defaultCloseAlgorithm();
        self.writeAlgorithm = common.defaultWriteAlgorithm();
        self.strategySizeAlgorithm = common.defaultSizeAlgorithm();
    }
    /// [[AbortSteps]](reason) - Called when stream is aborted
    /// 
    /// Spec: § 5.4.5 "[[AbortSteps]](reason)"
    pub fn abortSteps(self: *WritableStreamDefaultController, reason: ?common.JSValue) !*AsyncPromise(void) {
        // Step 1: Let result be the result of performing this.[[abortAlgorithm]], passing reason.
        const result = self.abortAlgorithm.call(reason);

        // Step 2: Perform ! WritableStreamDefaultControllerClearAlgorithms(this).
        self.clearAlgorithms();

        // Step 3: Return result (convert synchronous promise to async).
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        if (result.isFulfilled()) {
            promise.fulfill({});
        } else if (result.isRejected()) {
            promise.reject(result.error_value orelse common.JSValue{ .string = "Abort failed" });
        }
        return promise;
    }
    /// Calculate desired size (internal helper)
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerGetDesiredSize(controller)"
    pub fn calculateDesiredSize(self: *const WritableStreamDefaultController) ?f64 {
        // Return highWaterMark - queueTotalSize
        return self.strategyHwm - self.queue.queueTotalSize;
    }
    /// Write a chunk through the write algorithm
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerWrite(controller, chunk, chunkSize)"
    pub fn writeChunk(self: *WritableStreamDefaultController, chunk: common.JSValue, stream: *anyopaque) void {
        // Check if this is part of a TransformStream
        // If so, route through the transform controller instead of write algorithm
        if (self.transformController) |transform_ctrl_ptr| {
            const TransformStreamDefaultController = @import("transform_stream_default_controller").TransformStreamDefaultController;
            const transform_ctrl: *TransformStreamDefaultController = @ptrCast(@alignCast(transform_ctrl_ptr));

            // Call transform controller's enqueue (identity transform)
            // Spec: § 6.4 "TransformStreamDefaultSinkWriteAlgorithm" +
            //       § 6.5 "TransformStreamDefaultControllerPerformTransform"
            transform_ctrl.enqueueInternal(chunk) catch {
                // Transform/enqueue failed - error the stream
                // For now, just return (should error the stream)
                return;
            };

            // For TransformStream, we don't use the regular write algorithm
            // The chunk has been routed to the readable side
            return;
        }

        // Step 1: Let writeAlgorithm be controller.[[writeAlgorithm]].
        // Step 2: Let chunkSize be ! controller.[[strategySizeAlgorithm]](chunk).
        const chunkSize = self.strategySizeAlgorithm.call(chunk);

        // Step 3: Call write algorithm (currently sync, wrapping in async)
        const write_promise = self.writeAlgorithm.call(chunk);

        // Convert sync promise to async and schedule as microtask
        const async_promise = AsyncPromise(void).init(self.allocator, self.eventLoop) catch {
            // Failed to create promise - error the stream
            // For now, just return
            return;
        };

        if (write_promise.isFulfilled()) {
            async_promise.fulfill({});
        } else if (write_promise.isRejected()) {
            async_promise.reject(write_promise.error_value orelse common.JSValue{ .string = "Write failed" });
        } else {
            async_promise.fulfill({}); // Pending treated as fulfilled
        }

        // Schedule write completion handler
        const WriteContext = struct {
            controller: *WritableStreamDefaultController,
            promise: *AsyncPromise(void),
            chunkSize: f64,
            stream: *anyopaque,
        };

        const context = self.allocator.create(WriteContext) catch {
            async_promise.deinit();
            return;
        };
        context.* = .{
            .controller = self,
            .promise = async_promise,
            .chunkSize = chunkSize,
            .stream = stream,
        };

        const onFulfilled = struct {
            fn call(ctx: *anyopaque, _: void) !void {
                const c: *WriteContext = @ptrCast(@alignCast(ctx));
                defer c.controller.allocator.destroy(c);
                defer c.promise.deinit();

                // Write completed successfully
                // Update queue size
                c.controller.queue.queueTotalSize += c.chunkSize;

                // Get the WritableStream to fulfill write request
                const WritableStream = @import("writableStream").WritableStream;
                const ws: *WritableStream = @ptrCast(@alignCast(c.stream));

                // Fulfill the oldest write request
                if (ws.writeRequests.items.len > 0) {
                    const write_req = ws.writeRequests.orderedRemove(0);
                    write_req.fulfill({});
                    // Don't deinit - caller owns the promise
                }

                // Check if backpressure should change
                const desired_size = c.controller.calculateDesiredSize();
                if (desired_size) |size| {
                    const old_backpressure = ws.backpressure;
                    const new_backpressure = size <= 0.0;

                    if (old_backpressure != new_backpressure) {
                        ws.updateBackpressure(new_backpressure) catch {
                            // Failed to update backpressure - continue
                        };
                    }
                }
            }
        }.call;

        _ = async_promise.thenCtx(onFulfilled, null, context) catch {
            self.allocator.destroy(context);
            async_promise.deinit();
        };
    }
    /// Advance queue processing if needed
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)"
    pub fn advanceQueueIfNeeded(self: *WritableStreamDefaultController) void {
        const WritableStream = @import("writableStream").WritableStream;

        // Step 1: Let stream be controller.[[stream]].
        const stream: *WritableStream = @ptrCast(@alignCast(self.stream.?));

        // Step 2: If controller.[[started]] is false, return.
        if (!self.started) return;

        // Step 3: If stream.[[inFlightWriteRequest]] is not undefined, return.
        if (stream.inFlightWriteRequest != null) return;

        // Step 4: Let state be stream.[[state]].
        const state = stream.state;

        // Step 5: Assert: state is not "closed" or "errored".

        // Step 6: If state is "erroring",
        if (state == .erroring) {
            // Step 6.1: Perform ! WritableStreamFinishErroring(stream).
            stream.finishErroring();
            // Step 6.2: Return.
            return;
        }

        // Step 7: If controller.[[queue]] is empty, return.
        if (self.queue.isEmpty()) return;

        // Step 8: Let value be ! PeekQueueValue(controller).
        const value = self.queue.peekQueueValue() catch return;

        // Step 9: If value is the close sentinel, perform ! WritableStreamDefaultControllerProcessClose(controller).
        if (value.isCloseSentinel()) {
            self.processClose();
            return;
        }

        // Step 10: Otherwise, perform ! WritableStreamDefaultControllerProcessWrite(controller, value).
        self.processWrite(value);
    }
    /// Process a write from the queue
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerProcessWrite(controller, chunk)"
    pub fn processWrite(self: *WritableStreamDefaultController, chunk: common.JSValue) void {
        const WritableStream = @import("writableStream").WritableStream;

        // Step 1: Let stream be controller.[[stream]].
        const stream: *WritableStream = @ptrCast(@alignCast(self.stream.?));

        // Step 2: Perform ! WritableStreamMarkFirstWriteRequestInFlight(stream).
        stream.markFirstWriteRequestInFlight();

        // Step 3: Let sinkWritePromise be the result of performing controller.[[writeAlgorithm]], passing in chunk.
        const sink_write_promise = self.writeAlgorithm.call(chunk);

        // Create async promise to handle write result
        const async_promise = AsyncPromise(void).init(self.allocator, self.eventLoop) catch {
            // Failed to create promise - error the stream
            stream.finishInFlightWriteWithError(common.JSValue{ .string = "Failed to create write promise" });
            return;
        };

        // Convert sync promise to async
        if (sink_write_promise.isFulfilled()) {
            async_promise.fulfill({});
        } else if (sink_write_promise.isRejected()) {
            async_promise.reject(sink_write_promise.error_value orelse common.JSValue{ .string = "Write failed" });
        } else {
            async_promise.fulfill({}); // Pending treated as fulfilled
        }

        // Create context for handlers
        const ProcessWriteContext = struct {
            controller: *WritableStreamDefaultController,
            stream: *WritableStream,
            promise: *AsyncPromise(void),
        };

        const context = self.allocator.create(ProcessWriteContext) catch {
            async_promise.deinit();
            stream.finishInFlightWriteWithError(common.JSValue{ .string = "Out of memory" });
            return;
        };
        context.* = .{
            .controller = self,
            .stream = stream,
            .promise = async_promise,
        };

        // Step 4: Upon fulfillment of sinkWritePromise,
        const onFulfilled = struct {
            fn call(ctx: *anyopaque, _: void) !void {
                const c: *ProcessWriteContext = @ptrCast(@alignCast(ctx));
                defer c.controller.allocator.destroy(c);
                defer c.promise.deinit();

                // Step 4.1: Perform ! WritableStreamFinishInFlightWrite(stream).
                c.stream.finishInFlightWrite();

                // Step 4.2: Let state be stream.[[state]].
                const s = c.stream.state;

                // Step 4.3: Assert: state is "writable" or "erroring".

                // Step 4.4: Perform ! DequeueValue(controller).
                _ = c.controller.queue.dequeueValue() catch {};

                // Step 4.5: If ! WritableStreamCloseQueuedOrInFlight(stream) is false and state is "writable",
                if (!c.stream.closeQueuedOrInFlight() and s == .writable) {
                    // Step 4.5.1: Let backpressure be ! WritableStreamDefaultControllerGetBackpressure(controller).
                    const backpressure = c.controller.getBackpressure();

                    // Step 4.5.2: Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
                    c.stream.updateBackpressure(backpressure) catch {};
                }

                // Step 4.6: Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
                c.controller.advanceQueueIfNeeded();
            }
        }.call;

        // Step 5: Upon rejection of sinkWritePromise with reason,
        const onRejected = struct {
            fn call(ctx: *anyopaque, reason: common.JSValue) !void {
                const c: *ProcessWriteContext = @ptrCast(@alignCast(ctx));
                defer c.controller.allocator.destroy(c);
                defer c.promise.deinit();

                // Step 5.1: If stream.[[state]] is "writable", perform ! WritableStreamDefaultControllerClearAlgorithms(controller).
                if (c.stream.state == .writable) {
                    c.controller.clearAlgorithms();
                }

                // Step 5.2: Perform ! WritableStreamFinishInFlightWriteWithError(stream, reason).
                c.stream.finishInFlightWriteWithError(reason);
            }
        }.call;

        // Attach both fulfillment and rejection handlers
        async_promise.onSettleCtx(onFulfilled, onRejected, context) catch {
            self.allocator.destroy(context);
            async_promise.deinit();
            stream.finishInFlightWriteWithError(common.JSValue{ .string = "Failed to attach handlers" });
        };
    }
    /// Process close from the queue
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerProcessClose(controller)"
    pub fn processClose(self: *WritableStreamDefaultController) void {
        const WritableStream = @import("writableStream").WritableStream;

        // Step 1: Let stream be controller.[[stream]].
        const stream: *WritableStream = @ptrCast(@alignCast(self.stream.?));

        // Step 2: Perform ! WritableStreamMarkCloseRequestInFlight(stream).
        stream.markCloseRequestInFlight();

        // Step 3: Perform ! DequeueValue(controller).
        _ = self.queue.dequeueValue() catch {};

        // Step 4: Assert: controller.[[queue]] is empty.
        std.debug.assert(self.queue.isEmpty());

        // Step 5: Let sinkClosePromise be the result of performing controller.[[closeAlgorithm]].
        const sink_close_promise = self.closeAlgorithm.call();

        // Step 6: Perform ! WritableStreamDefaultControllerClearAlgorithms(controller).
        self.clearAlgorithms();

        // Create async promise to handle close result
        const async_promise = AsyncPromise(void).init(self.allocator, self.eventLoop) catch {
            // Failed to create promise - finish close with error
            stream.finishInFlightCloseWithError(common.JSValue{ .string = "Failed to create close promise" });
            return;
        };

        // Convert sync promise to async
        if (sink_close_promise.isFulfilled()) {
            async_promise.fulfill({});
        } else if (sink_close_promise.isRejected()) {
            async_promise.reject(sink_close_promise.error_value orelse common.JSValue{ .string = "Close failed" });
        } else {
            async_promise.fulfill({}); // Pending treated as fulfilled
        }

        // Create context for handlers
        const ProcessCloseContext = struct {
            stream: *WritableStream,
            promise: *AsyncPromise(void),
            allocator: std.mem.Allocator,
        };

        const context = self.allocator.create(ProcessCloseContext) catch {
            async_promise.deinit();
            stream.finishInFlightCloseWithError(common.JSValue{ .string = "Out of memory" });
            return;
        };
        context.* = .{
            .stream = stream,
            .promise = async_promise,
            .allocator = self.allocator,
        };

        // Step 7: Upon fulfillment of sinkClosePromise,
        const onFulfilled = struct {
            fn call(ctx: *anyopaque, _: void) !void {
                const c: *ProcessCloseContext = @ptrCast(@alignCast(ctx));
                defer c.allocator.destroy(c);
                defer c.promise.deinit();

                // Step 7.1: Perform ! WritableStreamFinishInFlightClose(stream).
                c.stream.finishInFlightClose();
            }
        }.call;

        // Step 8: Upon rejection of sinkClosePromise with reason reason,
        const onRejected = struct {
            fn call(ctx: *anyopaque, reason: common.JSValue) !void {
                const c: *ProcessCloseContext = @ptrCast(@alignCast(ctx));
                defer c.allocator.destroy(c);
                defer c.promise.deinit();

                // Step 8.1: Perform ! WritableStreamFinishInFlightCloseWithError(stream, reason).
                c.stream.finishInFlightCloseWithError(reason);
            }
        }.call;

        // Attach both handlers
        async_promise.onSettleCtx(onFulfilled, onRejected, context) catch {
            self.allocator.destroy(context);
            async_promise.deinit();
            stream.finishInFlightCloseWithError(common.JSValue{ .string = "Failed to attach close handlers" });
        };
    }
    /// Get backpressure state
    /// 
    /// Spec: § 5.4.4 "WritableStreamDefaultControllerGetBackpressure(controller)"
    fn getBackpressure(self: *const WritableStreamDefaultController) bool {
        // Step 1: Let desiredSize be ! WritableStreamDefaultControllerGetDesiredSize(controller).
        const desired_size = self.calculateDesiredSize();

        // Step 2: Return true if desiredSize ≤ 0, otherwise false.
        return if (desired_size) |size| size <= 0.0 else false;
    }
};

