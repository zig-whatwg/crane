// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! TransformStreamDefaultController class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#ts-default-controller-class
//! IDL: specs/streams.idl lines 191-198
//!
//! Controls a TransformStream's transformation and queueing.

const std = @import("std");

const webidl = @import("webidl");
const common = @import("common");
const eventLoop = @import("eventLoop");
const AsyncPromise = @import("async_promise").AsyncPromise;

/// Transform algorithm function type
/// NOTE: Returns error union for promise allocation, actual promise returned via pointer
pub const TransformAlgorithm = *const fn (chunk: common.JSValue) anyerror!*AsyncPromise(void);

/// Flush algorithm function type
/// NOTE: Returns error union for promise allocation, actual promise returned via pointer
pub const FlushAlgorithm = *const fn () anyerror!*AsyncPromise(void);
/// TransformStreamDefaultController WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface TransformStreamDefaultController {
/// readonly attribute unrestricted double? desiredSize;
/// 
/// undefined enqueue(optional any chunk);
/// undefined error(optional any reason);
/// undefined terminate();
/// };
/// ```
pub const TransformStreamDefaultController = struct {
    allocator: std.mem.Allocator,
    /// [[cancelAlgorithm]]: Promise-returning algorithm for cancelation
    cancelAlgorithm: ?common.CancelAlgorithm,
    /// [[flushAlgorithm]]: Promise-returning algorithm for flush
    flushAlgorithm: ?FlushAlgorithm,
    /// [[stream]]: The TransformStream instance controlled (will be a pointer in full implementation)
    stream: ?*anyopaque,
    /// [[transformAlgorithm]]: Promise-returning algorithm for transform
    transformAlgorithm: ?TransformAlgorithm,
    /// Transformer context for custom algorithms (used by TextDecoderStream/TextEncoderStream)
    transformerContext: ?*anyopaque,

    /// Initialize a new controller (internal - not exposed via WebIDL)
    pub fn init(
        allocator: std.mem.Allocator,
        transformAlgorithm: ?TransformAlgorithm,
        flushAlgorithm: ?FlushAlgorithm,
        cancelAlgorithm: ?common.CancelAlgorithm,
    ) TransformStreamDefaultController {
        return .{
            .allocator = allocator,
            .cancelAlgorithm = cancelAlgorithm,
            .flushAlgorithm = flushAlgorithm,
            .stream = null,
            .transformAlgorithm = transformAlgorithm,
            .transformerContext = null,
        };
    }
    pub fn deinit(self: *TransformStreamDefaultController) void {
        _ = self;
        // No heap allocations to clean up (algorithms are function pointers)
    }
    /// Returns the desired size to fill the readable side's internal queue.
    /// 
    /// IDL: readonly attribute unrestricted double? desiredSize;
    /// 
    /// Spec algorithm: § 6.3.3 "The desiredSize getter steps are:"
    pub fn get_desiredSize(self: *const TransformStreamDefaultController) ?f64 {
        // Step 1: Let readableController be this.[[stream]].[[readable]].[[controller]].
        // Step 2: Return ! ReadableStreamDefaultControllerGetDesiredSize(readableController).
        // For now, return null since we don't have the stream reference
        _ = self;
        return null;
    }
    /// Enqueues a chunk in the readable side of the transform stream.
    /// 
    /// IDL: undefined enqueue(optional any chunk);
    /// 
    /// Spec algorithm: § 6.3.3 "The enqueue(chunk) method steps are:"
    pub fn call_enqueue(self: *TransformStreamDefaultController, chunk: webidl.Optional(webidl.JSValue)) !void {
        const chunkValue = if (chunk.was_passed)
            common.JSValue.fromWebIDL(chunk.value)
        else
            common.JSValue.fromWebIDL(webidl.JSValue{ .undefined = {} });

        // Step 1: Perform ? TransformStreamDefaultControllerEnqueue(this, chunk).
        try self.enqueueInternal(chunkValue);
    }
    /// Errors both sides of the transform stream.
    /// 
    /// IDL: undefined error(optional any reason);
    /// 
    /// Spec algorithm: § 6.3.3 "The error(reason) method steps are:"
    pub fn call_error(self: *TransformStreamDefaultController, reason: webidl.Optional(webidl.JSValue)) void {
        const reason_value = if (reason.was_passed)
            common.JSValue.fromWebIDL(reason.value)
        else
            common.JSValue.fromWebIDL(webidl.JSValue{ .undefined = {} });

        // Step 1: Perform ! TransformStreamDefaultControllerError(this, reason).
        self.errorInternal(reason_value);
    }
    /// Closes the readable side and errors the writable side.
    /// 
    /// IDL: undefined terminate();
    /// 
    /// Spec algorithm: § 6.3.3 "The terminate() method steps are:"
    pub fn call_terminate(self: *TransformStreamDefaultController) void {
        // Step 1: Perform ! TransformStreamDefaultControllerTerminate(this).
        self.terminateInternal();
    }
    /// Enqueue chunk to readable side
    /// 
    /// Spec: § 6.3.4 "TransformStreamDefaultControllerEnqueue(controller, chunk)"
    pub fn enqueueInternal(self: *TransformStreamDefaultController, chunk: common.JSValue) !void {
        // Step 1: Let stream be controller.[[stream]].
        if (self.stream) |stream_ptr| {
            const TransformStream = @import("transform_stream").TransformStream;
            const stream: *TransformStream = @ptrCast(@alignCast(stream_ptr));

            // Step 2: Let readableController be stream.[[readable]].[[controller]].
            const readable_controller = stream.readableStream.controller;

            // Step 3: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) is false,
            //         throw a TypeError exception.
            // TODO: Add can-enqueue check

            // Step 4: Let enqueueResult be ReadableStreamDefaultControllerEnqueue(readableController, chunk).
            try readable_controller.enqueueInternal(chunk.toWebIDL());

            // Step 5: If enqueueResult is an abrupt completion, ...
            // (Handled by error propagation)

            // Step 6: Let backpressure be ! ReadableStreamDefaultControllerHasBackpressure(readableController).
            // Step 7: If backpressure is not stream.[[backpressure]], ...
            // TODO: Implement backpressure coordination
        } else {
            return error.StreamNotSet;
        }
    }
    /// Error both sides of transform stream
    /// 
    /// Spec: § 6.3.4 "TransformStreamDefaultControllerError(controller, e)"
    fn errorInternal(self: *TransformStreamDefaultController, e: common.JSValue) void {
        // Step 1: Perform ! TransformStreamError(controller.[[stream]], e).
        _ = self;
        _ = e;
        // Would error both readable and writable sides
    }
    /// Terminate the transform stream
    /// 
    /// Spec: § 6.3.4 "TransformStreamDefaultControllerTerminate(controller)"
    fn terminateInternal(self: *TransformStreamDefaultController) void {
        // Step 1: Let stream be controller.[[stream]].
        // Step 2: Let readableController be stream.[[readable]].[[controller]].
        // Step 3: Perform ! ReadableStreamDefaultControllerClose(readableController).
        // Step 4: Let error be a TypeError exception.
        // Step 5: Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, error).

        _ = self;
        // Would close readable side and error writable side
    }
    /// Invoke the transformer's transform function
    /// 
    /// Used by TextDecoderStream and TextEncoderStream to process chunks.
    pub fn invokeTransform(self: *TransformStreamDefaultController, chunk: webidl.JSValue) !void {
        if (self.transformerContext) |ctx_ptr| {
            const TransformStream = @import("transform_stream").TransformStream;
            const transformer: *TransformStream.Transformer = @ptrCast(@alignCast(ctx_ptr));

            if (transformer.transformFn) |transformFn| {
                try transformFn(self, chunk, transformer.context);
            }
        }
    }
    /// Invoke the transformer's flush function
    /// 
    /// Called when the writable side closes.
    pub fn invokeFlush(self: *TransformStreamDefaultController) !void {
        if (self.transformerContext) |ctx_ptr| {
            const TransformStream = @import("transform_stream").TransformStream;
            const transformer: *TransformStream.Transformer = @ptrCast(@alignCast(ctx_ptr));

            if (transformer.flushFn) |flushFn| {
                try flushFn(self, transformer.context);
            }
        }
    }
};

