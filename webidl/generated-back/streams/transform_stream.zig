// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! TransformStream class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#ts-class
//! IDL: specs/streams.idl lines 167-175
//!
//! Represents a transformation that consists of a pair of streams: a WritableStream
//! (the writable side) and a ReadableStream (the readable side).

const std = @import("std");

const webidl = @import("webidl");
const common = @import("common");
const dict_parsing = @import("dict_parsing");
const ReadableStream = @import("readableStream").ReadableStream;
const WritableStream = @import("writableStream").WritableStream;
const TransformStreamDefaultController = @import("transform_stream_default_controller").TransformStreamDefaultController;
/// TransformStream WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*, Transferable]
/// interface TransformStream {
/// constructor(optional object transformer,
/// optional QueuingStrategy writableStrategy = {},
/// optional QueuingStrategy readableStrategy = {});
/// 
/// readonly attribute ReadableStream readable;
/// readonly attribute WritableStream writable;
/// };
/// ```
pub const TransformStream = struct {
    allocator: std.mem.Allocator,
    /// [[backpressure]]: boolean - whether backpressure signal has been sent to transformer
    backpressure: bool,
    /// [[backpressureChangePromise]]: Promise that resolves when backpressure changes
    backpressureChangePromise: ?webidl.Promise(void),
    /// [[readable]]: ReadableStream representing the readable side
    readableStream: *ReadableStream,
    /// [[writable]]: WritableStream representing the writable side
    writableStream: *WritableStream,
    /// [[controller]]: TransformStreamDefaultController
    controller: *TransformStreamDefaultController,

    pub const Transformer = struct {
            /// Transform function: processes a chunk
            ///
            /// Parameters:
            /// - controller: TransformStreamDefaultController for enqueuing output
            /// - chunk: Input chunk (AllowSharedBufferSource for decoder, DOMString for encoder)
            /// - context: User-provided context (e.g., TextDecoderStream instance)
            ///
            /// Returns: error if transformation fails
            transformFn: ?*const fn (
                controller: *TransformStreamDefaultController,
                chunk: webidl.JSValue,
                context: *anyopaque,
            ) anyerror!void,

            /// Flush function: called when writable side closes
            ///
            /// Parameters:
            /// - controller: TransformStreamDefaultController for final output
            /// - context: User-provided context
            ///
            /// Returns: error if flush fails
            flushFn: ?*const fn (
                controller: *TransformStreamDefaultController,
                context: *anyopaque,
            ) anyerror!void,

            /// User-provided context (e.g., pointer to TextDecoderStream or TextEncoderStream)
            context: *anyopaque,
        };

    /// Initialize a new TransformStream (internal - not exposed via WebIDL)
    pub fn init(allocator: std.mem.Allocator) !TransformStream {
        return initWithTransformer(allocator, null, null, null);
    }
    pub fn deinit(self: *TransformStream) void {
        self.readableStream.deinit();
        self.allocator.destroy(self.readableStream);
        self.writableStream.deinit();
        self.allocator.destroy(self.writableStream);
        self.controller.deinit();
        self.allocator.destroy(self.controller);
    }
    /// Initialize with transformer and strategies
    /// 
    /// IDL: constructor(optional object transformer,
    /// optional QueuingStrategy writableStrategy = {},
    /// optional QueuingStrategy readableStrategy = {});
    /// 
    /// Spec algorithm: ยง 6.1.3 "new TransformStream(transformer, writableStrategy, readableStrategy)"
    pub fn initWithTransformer(
        allocator: std.mem.Allocator,
        transformer: ?webidl.JSValue,
        writableStrategy: ?webidl.JSValue,
        readableStrategy: ?webidl.JSValue,
    ) !TransformStream {
        // Step 1: If transformer is missing, set it to null.
        // Step 2: Let transformerDict be transformer, converted to IDL value of type Transformer.
        const transformer_dict = try dict_parsing.parseTransformer(allocator, transformer);

        // Step 3: Let writableHighWaterMark be ? ExtractHighWaterMark(writableStrategy, 1).
        // Step 4: Let writableSizeAlgorithm be ? ExtractSizeAlgorithm(writableStrategy).
        const writable_hwm = try dict_parsing.extractHighWaterMark(writableStrategy, 1.0);
        const writable_size = dict_parsing.extractSizeAlgorithm(writableStrategy);

        // Step 5: Let readableHighWaterMark be ? ExtractHighWaterMark(readableStrategy, 0).
        // Step 6: Let readableSizeAlgorithm be ? ExtractSizeAlgorithm(readableStrategy).
        const readable_hwm = try dict_parsing.extractHighWaterMark(readableStrategy, 0.0);
        const readable_size = dict_parsing.extractSizeAlgorithm(readableStrategy);

        // Step 7: Let startPromise be a new promise.

        // Step 8: Perform ! InitializeTransformStream(this, startPromise,
        //         writableHighWaterMark, writableSizeAlgorithm,
        //         readableHighWaterMark, readableSizeAlgorithm).

        // Create readable stream
        const readable = try allocator.create(ReadableStream);
        errdefer allocator.destroy(readable);
        readable.* = try ReadableStream.init(allocator);

        // Create writable stream
        const writable = try allocator.create(WritableStream);
        errdefer allocator.destroy(writable);
        writable.* = try WritableStream.init(allocator);

        // Create controller first (needed for algorithms)
        const controller = try allocator.create(TransformStreamDefaultController);
        errdefer allocator.destroy(controller);

        controller.* = TransformStreamDefaultController.init(allocator, null, null, null);

        // Create stream structure (needed for controller reference)
        var stream = TransformStream{
            .allocator = allocator,
            .backpressure = false,
            .backpressureChangePromise = null,
            .readableStream = readable,
            .writableStream = writable,
            .controller = controller,
        };

        // Set controller's stream reference
        controller.stream = &stream;

        // Set up readable stream controller's stream reference
        readable.controller.stream = readable;

        // Set up writable stream controller's stream reference
        writable.controller.stream = writable;

        // Wire up TransformStream: set transformController on writable controller
        // This routes writes through the transform controller to the readable side
        // Spec: ยง 6.4 "TransformStreamDefaultSinkWriteAlgorithm"
        writable.controller.transformController = controller;

        // Simplified implementation: Set up identity transform algorithm
        // This creates an identity transformer that passes chunks through unchanged
        // TODO: Extract custom transform/flush/cancel algorithms from transformer_dict
        _ = transformer_dict;
        _ = writable_hwm;
        _ = writable_size;
        _ = readable_hwm;
        _ = readable_size;

        // NOTE: For now we use default (identity) transform.
        // Full implementation will extract algorithms from transformer_dict and create
        // wrapper algorithms that call them with proper context.

        return stream;
    }
    /// Initialize with custom transform algorithms (for TextDecoderStream/TextEncoderStream)
    /// 
    /// This is a Zig-native API for creating TransformStreams with custom algorithms
    /// without requiring JavaScript object parsing.
    /// 
    /// Usage:
    /// ```zig
    /// const Transformer = TransformStream.Transformer;
    /// const transformer = Transformer{
    /// .transformFn = myTransformFn,
    /// .flushFn = myFlushFn,
    /// .context = &my_context,
    /// };
    /// var stream = try TransformStream.initWithAlgorithms(allocator, transformer);
    /// ```
    pub fn initWithAlgorithms(
        allocator: std.mem.Allocator,
        transformer: Transformer,
    ) !TransformStream {
        // Create readable stream
        const readable = try allocator.create(ReadableStream);
        errdefer allocator.destroy(readable);
        readable.* = try ReadableStream.init(allocator);

        // Create writable stream
        const writable = try allocator.create(WritableStream);
        errdefer allocator.destroy(writable);
        writable.* = try WritableStream.init(allocator);

        // Create controller with custom algorithms
        const controller = try allocator.create(TransformStreamDefaultController);
        errdefer allocator.destroy(controller);

        // Store transformer context in controller
        controller.* = TransformStreamDefaultController.init(
            allocator,
            null, // transformAlgorithm (will be set below)
            null, // flushAlgorithm (will be set below)
            null, // cancelAlgorithm
        );

        // Create stream structure
        var stream = TransformStream{
            .allocator = allocator,
            .backpressure = false,
            .backpressureChangePromise = null,
            .readableStream = readable,
            .writableStream = writable,
            .controller = controller,
        };

        // Set controller's stream reference
        controller.stream = &stream;

        // Set up readable stream controller's stream reference
        readable.controller.stream = readable;

        // Set up writable stream controller's stream reference
        writable.controller.stream = writable;

        // Wire up TransformStream
        writable.controller.transformController = controller;

        // Store transformer in controller for later use
        // We'll store it as an opaque pointer and cast it back in the wrapper functions
        const transformer_ptr = try allocator.create(Transformer);
        errdefer allocator.destroy(transformer_ptr);
        transformer_ptr.* = transformer;

        // Store transformer pointer in controller (we'll use a field for this)
        controller.transformerContext = transformer_ptr;

        return stream;
    }
    /// Fix controller stream pointer after stack allocation
    /// 
    /// Must be called after TransformStream.init() when stream is stack-allocated
    pub fn fixControllerPointer(self: *TransformStream) void {
        self.controller.stream = self;
        self.readableStream.fixControllerPointer();
        self.writableStream.fixControllerPointer();
    }
    /// Returns the readable side of the transform stream.
    /// 
    /// IDL: readonly attribute ReadableStream readable;
    /// 
    /// Spec algorithm: ยง 6.1.3 "The readable getter steps are:"
    pub fn get_readable(self: *const TransformStream) webidl.JSValue {
        // Step 1: Return this.[[readable]].
        // In full implementation, would return proper ReadableStream WebIDL type
        _ = self;
        return webidl.JSValue{ .undefined = {} };
    }
    /// Returns the writable side of the transform stream.
    /// 
    /// IDL: readonly attribute WritableStream writable;
    /// 
    /// Spec algorithm: ยง 6.1.3 "The writable getter steps are:"
    pub fn get_writable(self: *const TransformStream) webidl.JSValue {
        // Step 1: Return this.[[writable]].
        // In full implementation, would return proper WritableStream WebIDL type
        _ = self;
        return webidl.JSValue{ .undefined = {} };
    }
};


// Tests

test "TransformStream - basic construction" {
    const allocator = std.testing.allocator;

    var transform = try TransformStream.init(allocator);
    defer transform.deinit();

    // Should have readable and writable sides (non-optional pointers are always valid)
    // Just verify we can access them without crashing
    _ = transform.readableStream;
    _ = transform.writableStream;
    _ = transform.controller;
}

test "TransformStream - manual identity transform" {
    const allocator = std.testing.allocator;

    var transform = try TransformStream.init(allocator);
    defer transform.deinit();

    // Manually enqueue a chunk to readable side (simulating transform)
    try transform.readableStream.controller.enqueueInternal((common.JSValue{ .number = 42.0 }).toWebIDL());

    // Verify the chunk is in the readable stream's queue
    const desired_size = transform.readableStream.controller.calculateDesiredSize();
    try std.testing.expect(desired_size != null);

    // Queue should have one chunk
    // Default HWM is 1, so: 1 HWM - 1 chunk = 0 desired size
    try std.testing.expectEqual(@as(f64, 0.0), desired_size.?);
}

test "TransformStream - controller enqueue to readable side" {
    const allocator = std.testing.allocator;

    var transform = try TransformStream.init(allocator);
    defer transform.deinit();

    // Use controller to enqueue
    try transform.controller.enqueueInternal(common.JSValue{ .string = "test" });

    // Verify chunk is in readable queue
    const queue_size = transform.readableStream.controller.queue.queueTotalSize;
    try std.testing.expectEqual(@as(f64, 1.0), queue_size);
}

// TODO: Cleanup crash with async operations
test "TransformStream - write to writable flows to readable (identity transform)" {
    const allocator = std.testing.allocator;
    const TestEventLoop = @import("test_eventLoop").TestEventLoop;

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    var transform = try TransformStream.init(allocator);
    transform.fixControllerPointer();
    defer transform.deinit();

    // Get writer from writable side
    const writer = try transform.writableStream.acquireDefaultWriter(loop.eventLoop());
    defer {
        writer.call_releaseLock();
        writer.deinit();
        allocator.destroy(writer);
    }

    // Write a chunk to the writable side
    _ = try writer.writeInternal(common.JSValue{ .number = 42.0 });
    // Note: Write promise is cleaned up by the write handler

    // The write should route through the transform controller and enqueue to readable side
    // Check that readable stream has the chunk
    const queue_size = transform.readableStream.controller.queue.queueTotalSize;
    try std.testing.expectEqual(@as(f64, 1.0), queue_size);

    // Get reader from readable side
    const reader = try transform.readableStream.acquireDefaultReader(loop.eventLoop());
    defer {
        reader.call_releaseLock();
        reader.deinit();
        allocator.destroy(reader);
    }

    // Read the chunk
    const read_promise = try reader.call_read();
    defer read_promise.deinit();

    // Run microtasks to process the read
    loop.eventLoop().runMicrotasks();

    // Verify we got the same chunk
    if (read_promise.isFulfilled()) {
        const result = read_promise.state.fulfilled;
        try std.testing.expect(!result.done);
        if (result.value) |value| {
            try std.testing.expectEqual(@as(f64, 42.0), value.number);
        } else {
            try std.testing.expect(false); // Should have a value
        }
    } else {
        try std.testing.expect(false); // Read should be fulfilled
    }
}

// TODO: Cleanup crash with async operations
test "TransformStream - multiple chunks through identity transform" {
    const allocator = std.testing.allocator;
    const TestEventLoop = @import("test_eventLoop").TestEventLoop;

    var loop = TestEventLoop.init(allocator);
    defer loop.deinit();

    var transform = try TransformStream.init(allocator);
    transform.fixControllerPointer();
    defer transform.deinit();

    const writer = try transform.writableStream.acquireDefaultWriter(loop.eventLoop());
    defer {
        writer.call_releaseLock();
        writer.deinit();
        allocator.destroy(writer);
    }

    const reader = try transform.readableStream.acquireDefaultReader(loop.eventLoop());
    defer {
        reader.call_releaseLock();
        reader.deinit();
        allocator.destroy(reader);
    }

    // Write multiple chunks
    _ = try writer.writeInternal(common.JSValue{ .number = 1.0 });
    _ = try writer.writeInternal(common.JSValue{ .number = 2.0 });
    _ = try writer.writeInternal(common.JSValue{ .number = 3.0 });

    // Readable queue should have 3 chunks
    try std.testing.expectEqual(@as(f64, 3.0), transform.readableStream.controller.queue.queueTotalSize);

    // Read them back in order
    const read1 = try reader.call_read();
    defer read1.deinit();
    loop.eventLoop().runMicrotasks();
    try std.testing.expectEqual(@as(f64, 1.0), read1.state.fulfilled.value.?.number);

    const read2 = try reader.call_read();
    defer read2.deinit();
    loop.eventLoop().runMicrotasks();
    try std.testing.expectEqual(@as(f64, 2.0), read2.state.fulfilled.value.?.number);

    const read3 = try reader.call_read();
    defer read3.deinit();
    loop.eventLoop().runMicrotasks();
    try std.testing.expectEqual(@as(f64, 3.0), read3.state.fulfilled.value.?.number);
}
