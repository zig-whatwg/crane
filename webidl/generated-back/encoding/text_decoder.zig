// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

const std = @import("std");

const webidl = @import("webidl");
const infra = @import("infra");
const TextDecoderOptions = @import("text_decoder_options").TextDecoderOptions;
const TextDecodeOptions = @import("text_decode_options").TextDecodeOptions;

// Import encoding infrastructure
const encoding_mod = @import("encoding");
const Encoding = encoding_mod.Encoding;
const Decoder = encoding_mod.Decoder;

/// WebIDL String Type Mapping for TextDecoder
///
/// Per WebIDL spec, TextDecoder uses:
/// - DOMString for encoding labels (UTF-16: []const u16)
/// - USVString for decoded output (UTF-16: []const u16, scalar values only)
///
/// **Zig Implementation Decision**:
/// This library uses UTF-8 ([]const u8) for all string I/O instead of UTF-16.
/// Rationale:
/// - UTF-8 is Zig's native string format
/// - Avoids UTF-8 â†” UTF-16 conversion overhead for Zig consumers
/// - TextDecoder output is typically consumed as UTF-8 in Zig
///
/// **For JavaScript bindings**:
/// Use the conversion helpers below to bridge Zig UTF-8 â†” WebIDL UTF-16:
/// - `labelToDOMString()` - Convert UTF-8 label to DOMString (UTF-16)
/// - `decodedToUSVString()` - Convert UTF-8 output to USVString (UTF-16)
/// - `usvStringToUtf8()` - Convert USVString input to UTF-8
///
/// This approach maintains:
/// âœ… WebIDL spec compliance (for JavaScript bindings)
/// âœ… Zig ergonomics (UTF-8 native APIs)
/// âœ… Performance (no conversion overhead for Zig-only code)
/// TextDecoder errors map to WebIDL simple exceptions per WHATWG Encoding Standard
///
/// Error Mapping (for JavaScript bindings):
/// - error.InvalidEncoding â†’ RangeError (invalid encoding label)
/// - error.ReplacementEncoding â†’ RangeError (replacement encoding not allowed)
/// - error.DecodingError â†’ TypeError (fatal mode encountered invalid sequence)
pub const TextDecoderError = error{
    /// Invalid encoding label â†’ WebIDL RangeError
    InvalidEncoding,

    /// Replacement encoding not supported â†’ WebIDL RangeError
    ReplacementEncoding,

    /// Fatal decoding error â†’ WebIDL TypeError
    DecodingError,
};

/// Converts a TextDecoderError to a WebIDL ErrorResult
///
/// WHATWG Encoding Standard Â§5.1.3 (TextDecoder constructor)
/// WHATWG Encoding Standard Â§5.1.4 (TextDecoder.decode())
///
/// Error Mapping per WHATWG spec:
/// - InvalidEncoding â†’ RangeError (WebIDL simple exception)
/// - ReplacementEncoding â†’ RangeError (WebIDL simple exception)
/// - DecodingError â†’ TypeError (WebIDL simple exception)
///
/// Per WebIDL spec, RangeError and TypeError are **simple exceptions**, not DOMException.
/// https://webidl.spec.whatwg.org/#idl-exceptions
///
/// This is used by JavaScript bindings to convert Zig errors to WebIDL exceptions.
/// Zig code should use the error return values directly.
pub fn errorToWebIDL(allocator: std.mem.Allocator, err: TextDecoderError) !webidl.errors.ErrorResult {
    var result = webidl.errors.ErrorResult{};

    switch (err) {
        error.InvalidEncoding => {
            // WHATWG Encoding Â§5.1.3 step 4: throw a RangeError
            try result.throwRangeError(allocator, "The encoding label provided is invalid");
        },
        error.ReplacementEncoding => {
            // WHATWG Encoding Â§5.1.3 step 5: throw a RangeError
            try result.throwRangeError(allocator, "The 'replacement' decoder may only be used with the Encoding API's decode() method");
        },
        error.DecodingError => {
            // WHATWG Encoding Â§5.1.4 step 4: throw a TypeError in fatal mode
            try result.throwTypeError(allocator, "The encoded data was malformed");
        },
    }

    return result;
}

// ============================================================================
// WebIDL String Type Conversion Helpers
// ============================================================================

/// Converts a UTF-8 encoding label to WebIDL DOMString (UTF-16)
///
/// WebIDL Spec: TextDecoder constructor takes DOMString label
///
/// This is used by JavaScript bindings to convert the encoding label
/// from UTF-8 (Zig native) to UTF-16 (WebIDL DOMString).
///
/// Example:
/// ```zig
/// const utf8_label = "utf-8";
/// const dom_string = try labelToDOMString(allocator, utf8_label);
/// defer allocator.free(dom_string);
/// // dom_string is []const u16 (UTF-16)
/// ```
pub fn labelToDOMString(allocator: std.mem.Allocator, utf8_label: []const u8) !webidl.DOMString {
    return try infra.string.utf8ToUtf16(allocator, utf8_label);
}

/// Converts a WebIDL DOMString (UTF-16) to UTF-8 encoding label
///
/// This is used by JavaScript bindings to convert a DOMString label
/// to UTF-8 for use with TextDecoder.init().
///
/// Example:
/// ```zig
/// const dom_string: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
/// const utf8_label = try domStringToLabel(allocator, dom_string);
/// defer allocator.free(utf8_label);
/// // utf8_label is "utf-8" (UTF-8)
/// ```
pub fn domStringToLabel(allocator: std.mem.Allocator, dom_string: webidl.DOMString) ![]const u8 {
    return try infra.string.utf16ToUtf8(allocator, dom_string);
}

/// Converts UTF-8 decoded output to WebIDL USVString (UTF-16)
///
/// WebIDL Spec: TextDecoder.decode() returns USVString
///
/// This is used by JavaScript bindings to convert the decoded UTF-8 string
/// to UTF-16 (WebIDL USVString). The conversion ensures scalar values only
/// (no unpaired surrogates).
///
/// Example:
/// ```zig
/// const utf8_output = "Hello, ä¸–ç•Œ";
/// const usv_string = try decodedToUSVString(allocator, utf8_output);
/// defer allocator.free(usv_string);
/// // usv_string is []const u16 (UTF-16, scalar values only)
/// ```
pub fn decodedToUSVString(allocator: std.mem.Allocator, utf8_decoded: []const u8) !webidl.USVString {
    // Step 1: Convert UTF-8 â†’ UTF-16
    const utf16 = try infra.string.utf8ToUtf16(allocator, utf8_decoded);
    errdefer allocator.free(utf16);

    // Step 2: Convert to scalar values (USVString) - replaces unpaired surrogates with U+FFFD
    const usv = try infra.string.convertToScalarValueString(allocator, utf16);
    allocator.free(utf16);
    return usv;
}

/// Converts WebIDL USVString (UTF-16) to UTF-8 for decoding
///
/// This is used by JavaScript bindings to convert USVString input
/// to UTF-8 for internal processing.
///
/// Note: USVString contains only scalar values (no unpaired surrogates),
/// so the conversion is always valid.
///
/// Example:
/// ```zig
/// const usv_string: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o' };
/// const utf8 = try usvStringToUtf8(allocator, usv_string);
/// defer allocator.free(utf8);
/// // utf8 is "Hello" (UTF-8)
/// ```
pub fn usvStringToUtf8(allocator: std.mem.Allocator, usv_string: webidl.USVString) ![]const u8 {
    return try infra.string.utf16ToUtf8(allocator, usv_string);
}

// NOTE: We no longer define a custom BufferSource type.
// The IDL specifies AllowSharedBufferSource, which is provided by webidl v0.3.0
/// TextDecoder - decodes bytes to strings using various character encodings
/// 
/// WHATWG Encoding Standard Â§ 7.5
/// https://encoding.spec.whatwg.org/#interface-textdecoder
/// 
/// **WebIDL Compliance**: This implementation uses UTF-16 strings per WebIDL spec:
/// - Constructor accepts `DOMString` label (UTF-16)
/// - `decode()` returns `USVString` (UTF-16)
/// - `encoding` getter returns `DOMString` (UTF-16)
/// 
/// TextDecoder supports all WHATWG encodings (UTF-8, UTF-16, legacy encodings, etc.)
pub const TextDecoder = struct {
    allocator: std.mem.Allocator,
    enc: *const Encoding,
    doNotFlush: bool,
    _fatal: webidl.boolean,
    _ignoreBOM: webidl.boolean,
    bomSeen: bool,
    encodingName: webidl.DOMString,
    reusableUtf16Buf: ?[]u16,
    reusableUtf8Buf: ?[]u8,

    /// Constructor - creates a new TextDecoder
    /// 
    /// WHATWG Encoding Standard Â§ 5
    /// https://encoding.spec.whatwg.org/#dom-textdecoder
    /// 
    /// **WebIDL Compliance**: Accepts `DOMString` label (UTF-16) per WebIDL spec
    /// 
    /// IDL:
    /// ```
    /// constructor(optional DOMString label = "utf-8", optional TextDecoderOptions options = {});
    /// ```
    /// 
    /// label: encoding label as DOMString (UTF-16), e.g., &.{'u','t','f','-','8'}
    /// options: fatal and ignoreBOM settings
    /// 
    /// Errors:
    /// - error.InvalidEncoding â†’ WebIDL RangeError (invalid encoding label)
    /// - error.ReplacementEncoding â†’ WebIDL RangeError (replacement encoding)
    pub fn init(
        allocator: std.mem.Allocator,
        label: webidl.DOMString,
        options: TextDecoderOptions,
    ) !TextDecoder {
        // Step 1: Convert DOMString label to UTF-8 for internal lookup
        const utf8_label = try infra.string.utf16ToUtf8(allocator, label);
        defer allocator.free(utf8_label);

        // Step 2: Get encoding from label (Â§4.2 get an encoding)
        // https://encoding.spec.whatwg.org/#concept-encoding-get
        const enc = encoding_mod.getEncoding(utf8_label) orelse {
            // Step 3: If encoding is failure, throw RangeError
            return error.InvalidEncoding;
        };

        // Step 4: If encoding is replacement, throw RangeError
        if (std.mem.eql(u8, enc.whatwg_name, "replacement")) {
            return error.ReplacementEncoding;
        }

        // Step 5: Store encoding name as DOMString (UTF-16)
        const encodingName = try infra.string.utf8ToUtf16(allocator, enc.whatwg_name);
        errdefer allocator.free(encodingName);

        // Step 6: Set properties
        return .{
            .allocator = allocator,
            .enc = enc,
            .encodingName = encodingName,
            .doNotFlush = false,
            ._fatal = options.fatal,
            ._ignoreBOM = options.ignoreBOM,
            .bomSeen = false,
            .reusableUtf16Buf = null,
            .reusableUtf8Buf = null,
        };
    }
    /// Cleanup resources
    pub fn deinit(self: *TextDecoder) void {
        // Free encoding name (DOMString)
        self.allocator.free(self.encodingName);

        // Free reusable buffers
        if (self.reusableUtf16Buf) |buf| {
            self.allocator.free(buf);
        }
        if (self.reusableUtf8Buf) |buf| {
            self.allocator.free(buf);
        }
    }
    /// Get the encoding name (WHATWG canonical name)
    /// 
    /// WHATWG Encoding Standard Â§ 5
    /// TextDecoder.encoding getter
    /// 
    /// **WebIDL Compliance**: Returns `DOMString` (UTF-16) per WebIDL spec
    /// 
    /// IDL:
    /// ```
    /// readonly attribute DOMString encoding;
    /// ```
    pub inline fn get_encoding(self: *const TextDecoder) webidl.DOMString {
        return self.encodingName;
    }
    /// Get the fatal flag
    /// 
    /// WHATWG Encoding Standard Â§ 5
    /// TextDecoder.fatal getter
    /// 
    /// **WebIDL Compliance**: Returns `boolean` per WebIDL spec
    /// 
    /// IDL:
    /// ```
    /// readonly attribute boolean fatal;
    /// ```
    pub inline fn get_fatal(self: *const TextDecoder) webidl.boolean {
        return self._fatal;
    }
    /// Get the ignoreBOM flag
    /// 
    /// WHATWG Encoding Standard Â§ 5
    /// TextDecoder.ignoreBOM getter
    /// 
    /// **WebIDL Compliance**: Returns `boolean` per WebIDL spec
    /// 
    /// IDL:
    /// ```
    /// readonly attribute boolean ignoreBOM;
    /// ```
    pub inline fn get_ignoreBOM(self: *const TextDecoder) webidl.boolean {
        return self._ignoreBOM;
    }
    /// call_decode() - Decodes AllowSharedBufferSource to a string
    /// 
    /// WHATWG Encoding Standard Â§ 5
    /// https://encoding.spec.whatwg.org/#dom-textdecoder-decode
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// USVString decode(optional AllowSharedBufferSource input, optional TextDecodeOptions options = {});
    /// ```
    /// 
    /// Takes optional AllowSharedBufferSource input, returns decoded USVString.
    /// Supports ArrayBuffer, SharedArrayBuffer, and all TypedArray/DataView variants.
    /// If fatal=true, throws on invalid sequences.
    /// If fatal=false (default), replaces invalid sequences with U+FFFD.
    /// 
    /// Errors:
    /// - error.DecodingError â†’ WebIDL TypeError (fatal mode error)
    /// - error.DetachedBuffer â†’ WebIDL TypeError (detached ArrayBuffer)
    pub fn call_decode(
        self: *TextDecoder,
        input: webidl.AllowSharedBufferSource,
        options: TextDecodeOptions,
    ) !webidl.USVString {
        // Convert AllowSharedBufferSource to byte slice
        const bytes = try input.asBytes();

        // Delegate to internal helper
        return self.decodeBytes(bytes, options);
    }
    /// decodeBytes() - Internal helper that decodes raw bytes to a string
    /// 
    /// This is an internal helper method that performs the actual decoding work.
    /// The public WebIDL interface is call_decode() which takes AllowSharedBufferSource.
    /// 
    /// Takes raw bytes (default empty), returns decoded USVString.
    /// If fatal=true, throws on invalid sequences.
    /// If fatal=false (default), replaces invalid sequences with U+FFFD.
    /// 
    /// Errors:
    /// - error.DecodingError â†’ WebIDL TypeError (fatal mode error)
    fn decodeBytes(
        self: *TextDecoder,
        input: []const u8,
        options: TextDecodeOptions,
    ) !webidl.USVString {
        // Step 1: If doNotFlush is false, reset decoder state
        // WHATWG Encoding Standard Â§ 7.5 (decode algorithm, step 1)
        // https://encoding.spec.whatwg.org/#dom-textdecoder-decode
        // "If this's do not flush is false, then set this's decoder to a new instance
        //  of this's encoding's decoder, this's I/O queue to the I/O queue of bytes
        //  Â« end-of-queue Â», and this's BOM seen to false."
        if (!self.doNotFlush) {
            self.bomSeen = false;
            // Note: We don't need to reset the decoder instance because we create
            // a new decoder for each decode() call. The I/O queue is implicitly
            // reset by using the input parameter directly.
        }

        // Step 2: Set doNotFlush to options[stream]
        self.doNotFlush = options.stream;

        // Step 4: Handle BOM (if not ignoreBOM)
        var bytes = input;

        // ASCII ULTRA-FAST PATH
        // For ASCII-only input, convert directly to UTF-16 (no complex decoding needed)
        // ASCII is 0x00-0x7F, maps 1:1 to UTF-16
        const ascii_mod = @import("utf8_ascii");
        if (!self.bomSeen and ascii_mod.isAscii(bytes)) {
            // ASCII â†’ UTF-16: each byte becomes a u16
            const utf16_result = try self.allocator.alloc(u16, bytes.len);
            for (bytes, 0..) |byte, i| {
                utf16_result[i] = byte;
            }
            return utf16_result;
        }

        if (!self._ignoreBOM and !self.bomSeen) {
            // Check for BOM and skip it
            const bom_mod = @import("bom");

            // UTF-8 BOM: EF BB BF
            if (std.mem.eql(u8, self.enc.whatwg_name, "utf-8")) {
                bytes = bom_mod.skipUtf8Bom(bytes);
                if (bytes.len < input.len) {
                    self.bomSeen = true;
                }
            }
            // UTF-16BE BOM: FE FF
            else if (std.mem.eql(u8, self.enc.whatwg_name, "UTF-16BE")) {
                bytes = bom_mod.skipUtf16BeBom(bytes);
                if (bytes.len < input.len) {
                    self.bomSeen = true;
                }
            }
            // UTF-16LE BOM: FF FE
            else if (std.mem.eql(u8, self.enc.whatwg_name, "UTF-16LE")) {
                bytes = bom_mod.skipUtf16LeBom(bytes);
                if (bytes.len < input.len) {
                    self.bomSeen = true;
                }
            }
        }

        // UTF-8 FAST PATH
        // For UTF-8, convert directly to UTF-16 (USVString)
        if (std.mem.eql(u8, self.enc.whatwg_name, "utf-8")) {
            return try self.decodeUtf8ToUtf16(bytes, options);
        }

        // Step 5: Run the decoder
        // Create a decoder instance
        var decoder = self.enc.newDecoder();

        // Allocate or reuse UTF-16 output buffer
        const max_output_len = self.enc.maxUtf16Length(bytes.len);
        const output_buf = blk: {
            if (self.reusableUtf16Buf) |buf| {
                if (buf.len >= max_output_len) {
                    break :blk buf; // Reuse existing buffer!
                }
                // Need larger buffer - grow it
                self.reusableUtf16Buf = try self.allocator.realloc(buf, max_output_len);
                break :blk self.reusableUtf16Buf.?;
            }
            // First allocation
            self.reusableUtf16Buf = try self.allocator.alloc(u16, max_output_len);
            break :blk self.reusableUtf16Buf.?;
        };
        // No defer - we keep the buffer for reuse!

        // Decode to UTF-16
        const result = decoder.decode(bytes, output_buf, !self.doNotFlush);

        // Step 6: If fatal=true and there was an error, throw
        const streaming_mod = @import("streaming");
        if (self._fatal and result.status == streaming_mod.DecodeResult.Status.malformed) {
            return error.DecodingError;
        }

        // Step 7: Convert to USVString (scalar values only - replace unpaired surrogates)
        // Per WebIDL spec, USVString replaces unpaired surrogates with U+FFFD
        const utf16_slice = output_buf[0..result.code_units_written];

        // Use infra's convertToScalarValueString to ensure scalar values only
        return try infra.string.convertToScalarValueString(self.allocator, utf16_slice);
    }
    /// UTF-8 to UTF-16 decoding (WebIDL USVString output)
    /// Converts UTF-8 bytes to UTF-16 with scalar value string semantics
    fn decodeUtf8ToUtf16(
        self: *TextDecoder,
        input: []const u8,
        options: TextDecodeOptions,
    ) !webidl.USVString {
        _ = options; // Not used in this fast path

        // Valid UTF-8: convert to UTF-16
        // Use SIMD validation (5-10x faster than stdlib)
        const simd_validation = @import("utf8_simd");
        if (simd_validation.utf8ValidateSlice(input)) {
            // Valid UTF-8 â†’ UTF-16 conversion
            return try infra.string.utf8ToUtf16(self.allocator, input);
        }

        // Invalid UTF-8: clean it and convert to UTF-16
        // Replace invalid sequences with U+FFFD, then convert to UTF-16
        var output: std.ArrayListUnmanaged(u16) = .{};
        defer output.deinit(self.allocator);

        var i: usize = 0;
        while (i < input.len) {
            const cp_len = std.unicode.utf8ByteSequenceLength(input[i]) catch {
                if (self._fatal) return error.DecodingError;
                // U+FFFD in UTF-16: 0xFFFD
                try output.append(self.allocator, 0xFFFD);
                i += 1;
                continue;
            };

            if (i + cp_len > input.len) {
                if (self._fatal) return error.DecodingError;
                try output.append(self.allocator, 0xFFFD);
                break;
            }

            const cp = std.unicode.utf8Decode(input[i .. i + cp_len]) catch {
                if (self._fatal) return error.DecodingError;
                try output.append(self.allocator, 0xFFFD);
                i += 1;
                continue;
            };

            // Valid code point - encode to UTF-16
            if (cp <= 0xFFFF) {
                // BMP character (single UTF-16 code unit)
                try output.append(self.allocator, @as(u16, @intCast(cp)));
            } else {
                // Supplementary plane (surrogate pair)
                const hi = @as(u16, @intCast(0xD800 + ((cp - 0x10000) >> 10)));
                const low = @as(u16, @intCast(0xDC00 + ((cp - 0x10000) & 0x3FF)));
                try output.append(self.allocator, hi);
                try output.append(self.allocator, low);
            }
            i += cp_len;
        }

        return output.toOwnedSlice(self.allocator);
    }
};


// Tests
test "TextDecoder - basic UTF-8 decoding" {
    const allocator = std.testing.allocator;

    // WebIDL: label is DOMString (UTF-16)
    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    const input = "Hello, World!";
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input.len);
    defer arrayBuffer.deinit(allocator);
    @memcpy(arrayBuffer.data, input);

    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
    const output = try decoder.call_decode(buffer_source, .{});
    defer allocator.free(output);

    // WebIDL: output is USVString (UTF-16)
    const expected: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!' };
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - invalid encoding label" {
    const allocator = std.testing.allocator;

    // WebIDL: label is DOMString (UTF-16)
    const invalid_label: []const u16 = &.{ 'i', 'n', 'v', 'a', 'l', 'i', 'd', '-', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g' };
    const result = TextDecoder.init(allocator, invalid_label, .{});
    try std.testing.expectError(error.InvalidEncoding, result);
}

test "errorToWebIDL - InvalidEncoding maps to RangeError" {
    const allocator = std.testing.allocator;

    var result = try errorToWebIDL(allocator, error.InvalidEncoding);
    defer result.deinit(allocator);

    try std.testing.expect(result.hasFailed());
    const exception = result.getException().?;
    try std.testing.expectEqual(webidl.errors.SimpleException.RangeError, exception.simple.type);
    try std.testing.expectEqualStrings("The encoding label provided is invalid", exception.simple.message);
}

test "errorToWebIDL - ReplacementEncoding maps to RangeError" {
    const allocator = std.testing.allocator;

    var result = try errorToWebIDL(allocator, error.ReplacementEncoding);
    defer result.deinit(allocator);

    try std.testing.expect(result.hasFailed());
    const exception = result.getException().?;
    try std.testing.expectEqual(webidl.errors.SimpleException.RangeError, exception.simple.type);
    try std.testing.expectEqualStrings("The 'replacement' decoder may only be used with the Encoding API's decode() method", exception.simple.message);
}

test "errorToWebIDL - DecodingError maps to TypeError" {
    const allocator = std.testing.allocator;

    var result = try errorToWebIDL(allocator, error.DecodingError);
    defer result.deinit(allocator);

    try std.testing.expect(result.hasFailed());
    const exception = result.getException().?;
    try std.testing.expectEqual(webidl.errors.SimpleException.TypeError, exception.simple.type);
    try std.testing.expectEqualStrings("The encoded data was malformed", exception.simple.message);
}

test "TextDecoder - WebIDL encoding getter returns DOMString" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    const encoding = decoder.get_encoding();
    // Should return "utf-8" as UTF-16
    const expected: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    try std.testing.expectEqualSlices(u16, expected, encoding);
}

test "TextDecoder - WebIDL decode with non-ASCII UTF-8" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // UTF-8 input: "Hello, ä¸–ç•Œ" (Chinese "world")
    const input = "Hello, ä¸–ç•Œ";
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input.len);
    defer arrayBuffer.deinit(allocator);
    @memcpy(arrayBuffer.data, input);

    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
    const output = try decoder.call_decode(buffer_source, .{});
    defer allocator.free(output);

    // Expected UTF-16 output
    const expected: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o', ',', ' ', 0x4E16, 0x754C };
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - WebIDL decode with surrogate pair" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // UTF-8 input: "ðŸ˜€" (U+1F600 GRINNING FACE - requires surrogate pair in UTF-16)
    const input = "ðŸ˜€";
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input.len);
    defer arrayBuffer.deinit(allocator);
    @memcpy(arrayBuffer.data, input);

    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
    const output = try decoder.call_decode(buffer_source, .{});
    defer allocator.free(output);

    // Expected UTF-16 output: surrogate pair 0xD83D 0xDE00
    const expected: []const u16 = &.{ 0xD83D, 0xDE00 };
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - BOM stripping basic" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // UTF-8 BOM followed by "Hello"
    const input_with_bom = [_]u8{ 0xEF, 0xBB, 0xBF, 'H', 'e', 'l', 'l', 'o' };
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input_with_bom.len);
    defer arrayBuffer.deinit(allocator);
    @memcpy(arrayBuffer.data, &input_with_bom);

    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
    const output = try decoder.call_decode(buffer_source, .{ .stream = false });
    defer allocator.free(output);

    // Expected: just "Hello" in UTF-16, without BOM
    const expected: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o' };
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - BOM reset on stream end" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // UTF-8 BOM followed by "Hello"
    const input_with_bom = [_]u8{ 0xEF, 0xBB, 0xBF, 'H', 'e', 'l', 'l', 'o' };

    // Step 1: Streaming decode (stream:true) - should strip BOM
    {
        var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input_with_bom.len);
        defer arrayBuffer.deinit(allocator);
        @memcpy(arrayBuffer.data, &input_with_bom);

        const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
        const output1 = try decoder.call_decode(buffer_source, .{ .stream = true });
        defer allocator.free(output1);
        const expected1: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o' };
        try std.testing.expectEqualSlices(u16, expected1, output1);
    }

    // Step 2: Flush the stream (stream:false with empty input)
    // This sets doNotFlush=false, which triggers reset on next call
    {
        var arrayBuffer = try webidl.ArrayBuffer.init(allocator, 0);
        defer arrayBuffer.deinit(allocator);

        const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
        const output2 = try decoder.call_decode(buffer_source, .{ .stream = false });
        defer allocator.free(output2);
        const expected2: []const u16 = &.{};
        try std.testing.expectEqualSlices(u16, expected2, output2);
    }

    // Step 3: New decode with BOM - should strip BOM (fresh state)
    // Per WHATWG spec: doNotFlush is now false, so step 1 resets bomSeen
    {
        var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input_with_bom.len);
        defer arrayBuffer.deinit(allocator);
        @memcpy(arrayBuffer.data, &input_with_bom);

        const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
        const output3 = try decoder.call_decode(buffer_source, .{ .stream = false });
        defer allocator.free(output3);
        const expected3: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o' };
        try std.testing.expectEqualSlices(u16, expected3, output3);
    }
}

test "TextDecoder - UTF-16LE BOM stripping" {
    const allocator = std.testing.allocator;

    const utf16le_label: []const u16 = &.{ 'u', 't', 'f', '-', '1', '6', 'l', 'e' };
    var decoder = try TextDecoder.init(allocator, utf16le_label, .{});
    defer decoder.deinit();

    // UTF-16LE BOM (FF FE) followed by "H" (48 00)
    const input_with_bom = [_]u8{ 0xFF, 0xFE, 0x48, 0x00 };
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input_with_bom.len);
    defer arrayBuffer.deinit(allocator);
    @memcpy(arrayBuffer.data, &input_with_bom);

    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
    const output = try decoder.call_decode(buffer_source, .{ .stream = false });
    defer allocator.free(output);

    // Expected: just "H" in UTF-16, without BOM
    const expected: []const u16 = &.{'H'};
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - UTF-16BE BOM stripping" {
    const allocator = std.testing.allocator;

    const utf16be_label: []const u16 = &.{ 'u', 't', 'f', '-', '1', '6', 'b', 'e' };
    var decoder = try TextDecoder.init(allocator, utf16be_label, .{});
    defer decoder.deinit();

    // UTF-16BE BOM (FE FF) followed by "H" (00 48)
    const input_with_bom = [_]u8{ 0xFE, 0xFF, 0x00, 0x48 };
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, input_with_bom.len);
    defer arrayBuffer.deinit(allocator);
    @memcpy(arrayBuffer.data, &input_with_bom);

    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
    const output = try decoder.call_decode(buffer_source, .{ .stream = false });
    defer allocator.free(output);

    // Expected: just "H" in UTF-16, without BOM
    const expected: []const u16 = &.{'H'};
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - decode with AllowSharedBufferSource (ArrayBuffer)" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // Create ArrayBuffer with "Hello, World!"
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, 13);
    defer arrayBuffer.deinit(allocator);

    @memcpy(arrayBuffer.data, "Hello, World!");

    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer = &arrayBuffer };
    const output = try decoder.call_decode(buffer_source, .{});
    defer allocator.free(output);

    const expected: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!' };
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - decode with AllowSharedBufferSource (Uint8Array)" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // Create Uint8Array with "Hello"
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, 5);
    defer arrayBuffer.deinit(allocator);

    @memcpy(arrayBuffer.data, "Hello");

    const typed_array = try webidl.TypedArray(u8).init(&arrayBuffer, 0, 5);
    const arrayBuffer_view = webidl.ArrayBufferView{ .uint8_array = typed_array };
    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer_view = arrayBuffer_view };

    const output = try decoder.call_decode(buffer_source, .{});
    defer allocator.free(output);

    const expected: []const u16 = &.{ 'H', 'e', 'l', 'l', 'o' };
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - decode with AllowSharedBufferSource (SharedArrayBuffer)" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // Create SharedArrayBuffer with "World"
    var shared_buffer = try webidl.SharedArrayBuffer.init(allocator, 5);
    defer shared_buffer.deinit(allocator);

    @memcpy(shared_buffer.data, "World");

    const buffer_source = webidl.AllowSharedBufferSource{ .shared_arrayBuffer = &shared_buffer };
    const output = try decoder.call_decode(buffer_source, .{});
    defer allocator.free(output);

    const expected: []const u16 = &.{ 'W', 'o', 'r', 'l', 'd' };
    try std.testing.expectEqualSlices(u16, expected, output);
}

test "TextDecoder - decode with AllowSharedBufferSource (DataView)" {
    const allocator = std.testing.allocator;

    const utf8_label: []const u16 = &.{ 'u', 't', 'f', '-', '8' };
    var decoder = try TextDecoder.init(allocator, utf8_label, .{});
    defer decoder.deinit();

    // Create DataView with "Test"
    var arrayBuffer = try webidl.ArrayBuffer.init(allocator, 4);
    defer arrayBuffer.deinit(allocator);

    @memcpy(arrayBuffer.data, "Test");

    const data_view = try webidl.DataView.init(&arrayBuffer, 0, 4);
    const arrayBuffer_view = webidl.ArrayBufferView{ .data_view = data_view };
    const buffer_source = webidl.AllowSharedBufferSource{ .arrayBuffer_view = arrayBuffer_view };

    const output = try decoder.call_decode(buffer_source, .{});
    defer allocator.free(output);

    const expected: []const u16 = &.{ 'T', 'e', 's', 't' };
    try std.testing.expectEqualSlices(u16, expected, output);
}
