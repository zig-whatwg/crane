// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! TextDecoderStream class per WHATWG Encoding Standard
//!
//! Spec: https://encoding.spec.whatwg.org/#interface-textdecoderstream
//! Section: 5.2 "Interface TextDecoderStream"
//!
//! A TextDecoderStream uses a TextDecoder decoder internally to process a stream
//! of bytes into a stream of strings.

const std = @import("std");

const webidl = @import("webidl");
const encoding_mod = @import("../../src/encoding/root.zig");
const infra = @import("infra");
const TextDecoder = @import("text_decoder").TextDecoder;
const TextDecoderOptions = @import("text_decoder_options").TextDecoderOptions;
const ReadableStream = @import("../streams/readableStream").ReadableStream;
const WritableStream = @import("../streams/writableStream").WritableStream;
const TransformStream = @import("../streams/transform_stream").TransformStream;
const TransformStreamDefaultController = @import("../streams/transform_stream_default_controller").TransformStreamDefaultController;

const ByteQueue = encoding_mod.ByteQueue;
const ScalarQueue = encoding_mod.ScalarQueue;
const serializeIoQueue = encoding_mod.serialize_ioQueue.serializeIoQueue;
const processing = encoding_mod.processing;
/// TextDecoderStream WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface TextDecoderStream {
/// constructor(optional DOMString label = "utf-8", optional TextDecoderOptions options = {});
/// };
/// TextDecoderStream includes TextDecoderCommon;
/// TextDecoderStream includes GenericTransformStream;
/// ```
/// 
/// From spec:
/// - Includes TextDecoderCommon (encoding, fatal, ignoreBOM properties)
/// - Includes GenericTransformStream (readable, writable properties)
/// - Has an associated decoder (TextDecoder instance)
/// - Has an associated I/O queue (for buffering bytes between chunks)
/// - Has an associated transform (TransformStream)
pub const TextDecoderStream = struct {
    allocator: std.mem.Allocator,
    /// Associated decoder: TextDecoder instance used for decoding
    decoder: *TextDecoder,
    /// Associated transform: TransformStream that connects readable/writable
    transform: *TransformStream,
    /// Associated I/O queue: buffers bytes between chunks (WHATWG Encoding §5.2 step 6)
    ioQueue: ByteQueue,

    /// Constructor: new TextDecoderStream([label = "utf-8" [, options]])
    /// 
    /// Spec algorithm (§5.2 lines 936-958):
    /// 1. Let encoding be the result of getting an encoding from label.
    /// 2. If encoding is failure or replacement, then throw a RangeError.
    /// 3. Set this's encoding to encoding.
    /// 4. If options["fatal"] is true, then set this's error mode to "fatal".
    /// 5. Set this's ignore BOM to options["ignoreBOM"].
    /// 6. Set this's decoder to a new instance of this's encoding's decoder,
    /// and set this's I/O queue to a new I/O queue.
    /// 7. Let transformAlgorithm be an algorithm which takes a chunk argument
    /// and runs the decode and enqueue a chunk algorithm with this and chunk.
    /// 8. Let flushAlgorithm be an algorithm which takes no arguments and runs
    /// the flush and enqueue algorithm with this.
    /// 9. Let transformStream be a new TransformStream.
    /// 10. Set up transformStream with transformAlgorithm set to transformAlgorithm
    /// and flushAlgorithm set to flushAlgorithm.
    /// 11. Set this's transform to transformStream.
    pub fn init(
        allocator: std.mem.Allocator,
        label: webidl.DOMString,
        options: TextDecoderOptions,
    ) !TextDecoderStream {
        // Step 1-5: Create TextDecoder (handles all validation)
        const decoder = try allocator.create(TextDecoder);
        errdefer allocator.destroy(decoder);
        decoder.* = try TextDecoder.init(allocator, label, options);

        // Step 6: Create I/O queue for buffering bytes
        const ioQueue = ByteQueue.init(allocator);

        // Allocate TextDecoderStream on heap (needed for context pointer)
        const stream_ptr = try allocator.create(TextDecoderStream);
        errdefer allocator.destroy(stream_ptr);

        // Initialize with temporary values
        stream_ptr.* = TextDecoderStream{
            .allocator = allocator,
            .decoder = decoder,
            .transform = undefined, // Will be set below
            .ioQueue = ioQueue,
        };

        // Step 7-8: Create transformer with custom algorithms
        const transformer = TransformStream.Transformer{
            .transformFn = transformWrapper,
            .flushFn = flushWrapper,
            .context = stream_ptr,
        };

        // Step 9-10: Create TransformStream with custom algorithms
        const transform = try allocator.create(TransformStream);
        errdefer allocator.destroy(transform);
        transform.* = try TransformStream.initWithAlgorithms(allocator, transformer);

        // Step 11: Set transform
        stream_ptr.transform = transform;

        return stream_ptr.*;
    }
    pub fn deinit(self: *TextDecoderStream) void {
        self.ioQueue.deinit();
        self.decoder.deinit();
        self.allocator.destroy(self.decoder);
        self.transform.deinit();
        self.allocator.destroy(self.transform);
    }
    /// readonly attribute DOMString encoding
    /// 
    /// Returns encoding's name, lowercased.
    pub fn get_encoding(self: *const TextDecoderStream) webidl.DOMString {
        return self.decoder.get_encoding();
    }
    /// readonly attribute boolean fatal
    /// 
    /// Returns true if error mode is "fatal", and false otherwise.
    pub fn get_fatal(self: *const TextDecoderStream) webidl.boolean {
        return self.decoder.get_fatal();
    }
    /// readonly attribute boolean ignoreBOM
    /// 
    /// Returns the value of ignore BOM.
    pub fn get_ignoreBOM(self: *const TextDecoderStream) webidl.boolean {
        return self.decoder.get_ignoreBOM();
    }
    /// readonly attribute ReadableStream readable
    /// 
    /// Returns a ReadableStream whose chunks are strings resulting from
    /// running encoding's decoder on the chunks written to writable.
    pub fn get_readable(self: *const TextDecoderStream) *ReadableStream {
        return self.transform.readableStream;
    }
    /// readonly attribute WritableStream writable
    /// 
    /// Returns a WritableStream whose chunks must be BufferSource objects.
    pub fn get_writable(self: *const TextDecoderStream) *WritableStream {
        return self.transform.writableStream;
    }
    /// Transform wrapper: bridges TransformStream to decodeAndEnqueue
    /// 
    /// This function is called by the TransformStream when chunks are written.
    fn transformWrapper(
        controller: *TransformStreamDefaultController,
        chunk: webidl.JSValue,
        context: *anyopaque,
    ) !void {
        const self: *TextDecoderStream = @ptrCast(@alignCast(context));
        try decodeAndEnqueue(controller, chunk, self);
    }
    /// Flush wrapper: bridges TransformStream to flushAndEnqueue
    /// 
    /// This function is called by the TransformStream when the writable side closes.
    fn flushWrapper(
        controller: *TransformStreamDefaultController,
        context: *anyopaque,
    ) !void {
        const self: *TextDecoderStream = @ptrCast(@alignCast(context));
        try flushAndEnqueue(controller, self);
    }
    /// Decode and enqueue a chunk algorithm
    /// 
    /// WHATWG Encoding Standard §5.2 (lines 960-985)
    /// 
    /// Given a TextDecoderStream object decoder and a chunk, runs these steps:
    /// 
    /// 1. Let bufferSource be the result of converting chunk to an AllowSharedBufferSource.
    /// 2. Push a copy of bufferSource to decoder's I/O queue.
    /// 3. Let output be the I/O queue of scalar values « end-of-queue ».
    /// 4. While true:
    /// 1. Let item be the result of reading from decoder's I/O queue.
    /// 2. If item is end-of-queue:
    /// 1. Let outputChunk be the result of running serialize I/O queue
    /// with decoder and output.
    /// 2. If outputChunk is not the empty string, then enqueue outputChunk
    /// in decoder's transform.
    /// 3. Return.
    /// 3. Let result be the result of processing an item with item,
    /// decoder's decoder, decoder's I/O queue, output, and decoder's error mode.
    /// 4. If result is error, then throw a TypeError.
    fn decodeAndEnqueue(
        controller: *TransformStreamDefaultController,
        chunk: webidl.JSValue,
        decoderStream: *TextDecoderStream,
    ) !void {
        // Step 1: Convert chunk to AllowSharedBufferSource
        // In WebIDL, chunk should be AllowSharedBufferSource, but we get JSValue
        // We need to extract bytes from the buffer source
        const bytes = try jsValueToBytes(chunk);

        // Step 2: Push a copy of bufferSource to decoder's I/O queue
        for (bytes) |byte| {
            try decoderStream.ioQueue.push(byte);
        }

        // Step 3: Let output be the I/O queue of scalar values « end-of-queue »
        var output = ScalarQueue.init(decoderStream.allocator);
        defer output.deinit();

        // Get decoder instance from TextDecoder (for potential future use)
        _ = decoderStream.decoder.enc.newDecoder();

        // Step 4: While true
        while (true) {
            // Step 4.1: Let item be the result of reading from decoder's I/O queue
            const item_opt = decoderStream.ioQueue.read();

            // Step 4.2: If item is end-of-queue
            if (item_opt == null) {
                // No more items (streaming mode - waiting for more input)
                // Serialize and enqueue what we have
                if (output.remaining() > 0) {
                    const output_chunk = try serializeIoQueue(
                        decoderStream.allocator,
                        &output,
                        decoderStream.decoder.enc.whatwg_name,
                        decoderStream.decoder._ignoreBOM,
                        &decoderStream.decoder.bomSeen,
                    );
                    defer decoderStream.allocator.free(output_chunk);

                    if (output_chunk.len > 0) {
                        // Enqueue in transform's readable
                        const output_js = webidl.JSValue{ .string = output_chunk };
                        try controller.enqueueInternal(output_js);
                    }
                }
                return; // Done processing this chunk
            }

            const item = item_opt.?;

            if (item.isEndOfQueue()) {
                // Step 4.2.1: Serialize I/O queue
                const output_chunk = try serializeIoQueue(
                    decoderStream.allocator,
                    &output,
                    decoderStream.decoder.enc.whatwg_name,
                    decoderStream.decoder._ignoreBOM,
                    &decoderStream.decoder.bomSeen,
                );
                defer decoderStream.allocator.free(output_chunk);

                // Step 4.2.2: If outputChunk is not empty, enqueue
                if (output_chunk.len > 0) {
                    const output_js = webidl.JSValue{ .string = output_chunk };
                    try controller.enqueueInternal(output_js);
                }

                // Step 4.2.3: Return
                return;
            }

            // Step 4.3: Process an item
            // We need to use the decoder's handler to process the byte
            // For now, we'll decode byte-by-byte using the decoder
            // This is a simplified implementation that uses TextDecoder's existing logic

            // Instead of byte-by-byte processing, we'll collect all available bytes
            // and decode them together (this is an optimization that still maintains
            // correct streaming semantics)
            break; // Exit loop and use optimized path below
        }

        // Optimized path: Decode all collected bytes at once
        // This maintains streaming semantics while using the optimized TextDecoder
        const available_bytes = try decoderStream.ioQueue.toSlice(decoderStream.allocator);
        defer decoderStream.allocator.free(available_bytes);

        if (available_bytes.len > 0) {
            // Reset the queue (we've consumed all bytes)
            decoderStream.ioQueue.deinit();
            decoderStream.ioQueue = ByteQueue.init(decoderStream.allocator);

            // Decode with streaming mode
            const decoded = try decoderStream.decoder.decodeBytes(
                available_bytes,
                .{ .stream = true },
            );
            defer decoderStream.allocator.free(decoded);

            // Enqueue the decoded string
            if (decoded.len > 0) {
                const output_js = webidl.JSValue{ .string = decoded };
                try controller.enqueueInternal(output_js);
            }
        }
    }
    /// Flush and enqueue algorithm
    /// 
    /// WHATWG Encoding Standard §5.2 (lines 986-1004)
    /// 
    /// Given a TextDecoderStream object decoder, runs these steps:
    /// 
    /// 1. Let output be the I/O queue of scalar values « end-of-queue ».
    /// 2. While true:
    /// 1. Let item be the result of reading from decoder's I/O queue.
    /// 2. Let result be the result of processing an item with item,
    /// decoder's decoder, decoder's I/O queue, output, and decoder's error mode.
    /// 3. If result is finished:
    /// 1. Let outputChunk be the result of running serialize I/O queue
    /// with decoder and output.
    /// 2. If outputChunk is not the empty string, then enqueue outputChunk
    /// in decoder's transform.
    /// 3. Return.
    /// 4. Otherwise, if result is error, throw a TypeError.
    fn flushAndEnqueue(
        controller: *TransformStreamDefaultController,
        decoderStream: *TextDecoderStream,
    ) !void {
        // Flush any remaining bytes in the I/O queue
        const remaining_bytes = try decoderStream.ioQueue.toSlice(decoderStream.allocator);
        defer decoderStream.allocator.free(remaining_bytes);

        if (remaining_bytes.len > 0) {
            // Decode with stream=false (flush mode)
            const decoded = try decoderStream.decoder.decodeBytes(
                remaining_bytes,
                .{ .stream = false },
            );
            defer decoderStream.allocator.free(decoded);

            // Enqueue if not empty
            if (decoded.len > 0) {
                const output_js = webidl.JSValue{ .string = decoded };
                try controller.enqueueInternal(output_js);
            }
        }

        // Clear the I/O queue
        decoderStream.ioQueue.deinit();
        decoderStream.ioQueue = ByteQueue.init(decoderStream.allocator);
    }
    /// Helper: Convert JSValue to bytes
    /// 
    /// Extracts bytes from AllowSharedBufferSource (ArrayBuffer, TypedArray, etc.)
    fn jsValueToBytes(value: webidl.JSValue) ![]const u8 {
        // In a full implementation, this would:
        // 1. Check if value is ArrayBuffer
        // 2. Check if value is ArrayBufferView (TypedArray, DataView)
        // 3. Extract bytes accordingly
        //
        // For now, we'll return a placeholder
        // This will be properly implemented when WebIDL integration is complete

        // Temporary: assume value contains bytes directly
        // This is a simplification for the prototype
        _ = value;
        return &[_]u8{};
    }
};

