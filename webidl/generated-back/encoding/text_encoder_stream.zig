// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! TextEncoderStream class per WHATWG Encoding Standard
//!
//! Spec: https://encoding.spec.whatwg.org/#interface-textencoderstream
//! Section: 5.3 "Interface TextEncoderStream"
//!
//! A TextEncoderStream uses a UTF-8 encoder internally to process a stream
//! of strings into a stream of Uint8Array objects.

const std = @import("std");

const webidl = @import("webidl");
const infra = @import("infra");
const TextEncoder = @import("text_encoder").TextEncoder;
const ReadableStream = @import("../streams/readableStream").ReadableStream;
const WritableStream = @import("../streams/writableStream").WritableStream;
const TransformStream = @import("../streams/transform_stream").TransformStream;
const TransformStreamDefaultController = @import("../streams/transform_stream_default_controller").TransformStreamDefaultController;
/// TextEncoderStream WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface TextEncoderStream {
/// constructor();
/// };
/// TextEncoderStream includes TextEncoderCommon;
/// TextEncoderStream includes GenericTransformStream;
/// ```
/// 
/// From spec:
/// - Includes TextEncoderCommon (encoding property)
/// - Includes GenericTransformStream (readable, writable properties)
/// - Has an associated encoder (encoder instance, not TextEncoder object)
/// - Has an associated leading surrogate (null or a leading surrogate)
/// - Has an associated transform (TransformStream)
/// - Only supports UTF-8 encoding
pub const TextEncoderStream = struct {
    allocator: std.mem.Allocator,
    /// Associated encoder: TextEncoder instance used for encoding
    encoder: *TextEncoder,
    /// Associated leading surrogate: null or a leading surrogate, initially null
    /// 
    /// WHATWG Encoding Standard §5.3
    /// Used to handle unpaired surrogates across chunk boundaries.
    /// When a leading surrogate appears at the end of a chunk, it's stored here
    /// to be combined with a trailing surrogate in the next chunk.
    leadingSurrogate: ?u16,
    /// Associated transform: TransformStream that connects readable/writable
    transform: *TransformStream,

    /// Constructor: new TextEncoderStream()
    /// 
    /// Spec algorithm (§5.3 lines 1052-1064):
    /// 1. Set this's encoder to an instance of the UTF-8 encoder.
    /// 2. Let transformAlgorithm be an algorithm which takes a chunk argument
    /// and runs the encode and enqueue a chunk algorithm with this and chunk.
    /// 3. Let flushAlgorithm be an algorithm which runs the encode and flush
    /// algorithm with this.
    /// 4. Let transformStream be a new TransformStream.
    /// 5. Set up transformStream with transformAlgorithm set to transformAlgorithm
    /// and flushAlgorithm set to flushAlgorithm.
    /// 6. Set this's transform to transformStream.
    /// 
    /// Note: TextEncoderStream offers no label argument as it only supports UTF-8.
    pub fn init(allocator: std.mem.Allocator) !TextEncoderStream {
        // Step 1: Create UTF-8 encoder (TextEncoder always uses UTF-8)
        const encoder = try allocator.create(TextEncoder);
        errdefer allocator.destroy(encoder);
        encoder.* = TextEncoder.init(allocator);

        // Allocate TextEncoderStream on heap (needed for context pointer)
        const stream_ptr = try allocator.create(TextEncoderStream);
        errdefer allocator.destroy(stream_ptr);

        // Initialize with temporary values
        stream_ptr.* = TextEncoderStream{
            .allocator = allocator,
            .encoder = encoder,
            .leadingSurrogate = null, // Initially null
            .transform = undefined, // Will be set below
        };

        // Step 2-3: Create transformer with custom algorithms
        const transformer = TransformStream.Transformer{
            .transformFn = transformWrapper,
            .flushFn = flushWrapper,
            .context = stream_ptr,
        };

        // Step 4-5: Create TransformStream with custom algorithms
        const transform = try allocator.create(TransformStream);
        errdefer allocator.destroy(transform);
        transform.* = try TransformStream.initWithAlgorithms(allocator, transformer);

        // Step 6: Set transform
        stream_ptr.transform = transform;

        return stream_ptr.*;
    }
    pub fn deinit(self: *TextEncoderStream) void {
        self.encoder.deinit();
        self.allocator.destroy(self.encoder);
        self.transform.deinit();
        self.allocator.destroy(self.transform);
    }
    /// readonly attribute DOMString encoding
    /// 
    /// Returns "utf-8" (always).
    pub fn get_encoding(self: *const TextEncoderStream) webidl.DOMString {
        return self.encoder.get_encoding();
    }
    /// readonly attribute ReadableStream readable
    /// 
    /// Returns a ReadableStream whose chunks are Uint8Array objects
    /// resulting from running UTF-8's encoder on the chunks written to writable.
    pub fn get_readable(self: *const TextEncoderStream) *ReadableStream {
        return self.transform.readableStream;
    }
    /// readonly attribute WritableStream writable
    /// 
    /// Returns a WritableStream whose chunks must be strings.
    pub fn get_writable(self: *const TextEncoderStream) *WritableStream {
        return self.transform.writableStream;
    }
    /// Transform wrapper: bridges TransformStream to encodeAndEnqueue
    /// 
    /// This function is called by the TransformStream when chunks are written.
    fn transformWrapper(
        controller: *TransformStreamDefaultController,
        chunk: webidl.JSValue,
        context: *anyopaque,
    ) !void {
        const self: *TextEncoderStream = @ptrCast(@alignCast(context));
        try encodeAndEnqueue(controller, chunk, self);
    }
    /// Flush wrapper: bridges TransformStream to flushAndEnqueue
    /// 
    /// This function is called by the TransformStream when the writable side closes.
    fn flushWrapper(
        controller: *TransformStreamDefaultController,
        context: *anyopaque,
    ) !void {
        const self: *TextEncoderStream = @ptrCast(@alignCast(context));
        try flushAndEnqueue(controller, self);
    }
    /// Encode and enqueue a chunk algorithm
    /// 
    /// WHATWG Encoding Standard §5.3 (lines 1068-1097)
    /// 
    /// Given a TextEncoderStream object encoder and chunk, runs these steps:
    /// 
    /// 1. Let input be the result of converting chunk to a DOMString.
    /// 2. Convert input to an I/O queue of code units.
    /// 3. Let output be the I/O queue of bytes « end-of-queue ».
    /// 4. While true:
    /// 1. Let item be the result of reading from input.
    /// 2. If item is end-of-queue:
    /// 1. Convert output into a byte sequence.
    /// 2. If output is not empty:
    /// 1. Let chunk be the result of creating a Uint8Array object
    /// given output and encoder's relevant realm.
    /// 2. Enqueue chunk into encoder's transform.
    /// 3. Return.
    /// 3. Let result be the result of executing the convert code unit to
    /// scalar value algorithm with encoder, item and input.
    /// 4. If result is not continue, then process an item with result,
    /// encoder's encoder, input, output, and "fatal".
    fn encodeAndEnqueue(
        controller: *TransformStreamDefaultController,
        chunk: webidl.JSValue,
        encoderStream: *TextEncoderStream,
    ) !void {
        // Step 1: Convert chunk to DOMString
        // Extract UTF-16 string from JSValue
        const input_utf16 = try jsValueToString(chunk);

        // Step 2: Convert input to I/O queue of code units (UTF-16 code units)
        // We'll process code units directly instead of using I/O queue

        // Step 3: Output buffer for UTF-8 bytes
        var output = infra.List(u8).init(encoderStream.allocator);
        defer output.deinit();

        // Step 4: Process each code unit
        var i: usize = 0;
        while (i < input_utf16.len) {
            const code_unit = input_utf16[i];
            i += 1;

            // Step 4.3: Convert code unit to scalar value
            const scalar_value_opt = try convertCodeUnitToScalarValue(
                encoderStream,
                code_unit,
                input_utf16,
                &i,
            );

            // Step 4.4: If result is not continue, encode it
            if (scalar_value_opt) |scalar_value| {
                // Encode scalar value to UTF-8
                var utf8_buf: [4]u8 = undefined;
                const len = std.unicode.utf8Encode(scalar_value, &utf8_buf) catch {
                    // Should never happen for valid scalar values
                    continue;
                };

                try output.appendSlice(utf8_buf[0..len]);
            }
        }

        // Step 4.2: If output is not empty, create Uint8Array and enqueue
        if (output.items().len > 0) {
            // Create ArrayBuffer
            var arrayBuffer = try webidl.ArrayBuffer.init(
                encoderStream.allocator,
                output.items().len,
            );
            @memcpy(arrayBuffer.data, output.items());

            // Create Uint8Array
            const uint8_array = try webidl.TypedArray(u8).init(
                &arrayBuffer,
                0,
                output.items().len,
            );

            // Convert to JSValue and enqueue
            const output_js = webidl.JSValue{ .uint8_array = uint8_array };
            try controller.enqueueInternal(output_js);
        }
    }
    /// Convert code unit to scalar value algorithm
    /// 
    /// WHATWG Encoding Standard §5.3 (lines 1099-1117)
    /// 
    /// Given a TextEncoderStream object encoder, a code unit item, and an
    /// I/O queue of code units input, runs these steps:
    /// 
    /// 1. If encoder's leading surrogate is non-null:
    /// 1. Let leadingSurrogate be encoder's leading surrogate.
    /// 2. Set encoder's leading surrogate to null.
    /// 3. If item is a trailing surrogate, then return a scalar value from
    /// surrogates given leadingSurrogate and item.
    /// 4. Restore item to input.
    /// 5. Return U+FFFD (�).
    /// 2. If item is a leading surrogate, then set encoder's leading surrogate
    /// to item and return continue.
    /// 3. If item is a trailing surrogate, then return U+FFFD (�).
    /// 4. Return item.
    /// 
    /// Returns: null for continue, u21 code point otherwise
    fn convertCodeUnitToScalarValue(
        encoderStream: *TextEncoderStream,
        item: u16,
        _: []const u16,
        index: *usize,
    ) !?u21 {
        // Step 1: If encoder's leading surrogate is non-null
        if (encoderStream.leadingSurrogate) |leading| {
            // Step 1.2: Set encoder's leading surrogate to null
            encoderStream.leadingSurrogate = null;

            // Step 1.3: If item is a trailing surrogate
            if (infra.code_point.isTrailSurrogate(item)) {
                // Return scalar value from surrogates
                return try infra.code_point.decodeSurrogatePair(leading, item);
            }

            // Step 1.4: Restore item to input (decrement index)
            index.* -= 1;

            // Step 1.5: Return U+FFFD
            return 0xFFFD;
        }

        // Step 2: If item is a leading surrogate
        if (infra.code_point.isLeadSurrogate(item)) {
            // Set encoder's leading surrogate to item
            encoderStream.leadingSurrogate = item;
            // Return continue (null)
            return null;
        }

        // Step 3: If item is a trailing surrogate
        if (infra.code_point.isTrailSurrogate(item)) {
            // Return U+FFFD
            return 0xFFFD;
        }

        // Step 4: Return item (valid BMP code point)
        return @intCast(item);
    }
    /// Encode and flush algorithm
    /// 
    /// WHATWG Encoding Standard §5.3 (lines 1120-1129)
    /// 
    /// Given a TextEncoderStream object encoder, runs these steps:
    /// 
    /// 1. If encoder's leading surrogate is non-null:
    /// 1. Let chunk be the result of creating a Uint8Array object given
    /// « 0xEF, 0xBF, 0xBD » and encoder's relevant realm.
    /// 2. Enqueue chunk into encoder's transform.
    fn flushAndEnqueue(
        controller: *TransformStreamDefaultController,
        encoderStream: *TextEncoderStream,
    ) !void {
        // Step 1: If encoder's leading surrogate is non-null
        if (encoderStream.leadingSurrogate != null) {
            // Clear the leading surrogate
            encoderStream.leadingSurrogate = null;

            // Step 1.1: Create Uint8Array with U+FFFD bytes (0xEF, 0xBF, 0xBD)
            const fffd_bytes = [_]u8{ 0xEF, 0xBF, 0xBD };

            var arrayBuffer = try webidl.ArrayBuffer.init(
                encoderStream.allocator,
                3,
            );
            @memcpy(arrayBuffer.data, &fffd_bytes);

            const uint8_array = try webidl.TypedArray(u8).init(
                &arrayBuffer,
                0,
                3,
            );

            // Step 1.2: Enqueue chunk
            const output_js = webidl.JSValue{ .uint8_array = uint8_array };
            try controller.enqueueInternal(output_js);
        }
    }
    /// Helper: Convert JSValue to UTF-16 string
    /// 
    /// Extracts DOMString (UTF-16) from JSValue
    fn jsValueToString(value: webidl.JSValue) ![]const u16 {
        // In a full implementation, this would extract the string from JSValue
        // For now, we'll handle the string case
        switch (value) {
            .string => |s| return s,
            else => return &[_]u16{},
        }
    }
};

