// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Attr interface per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-attr
//! Section: 4.8 "Interface Attr"
//!
//! Attr nodes represent attributes. They are sometimes referred to as
//! "content attributes" to avoid confusion with IDL attributes.

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

// Forward declarations
const node_mod = @import("node");
pub const Node = node_mod.Node;

const element_mod = @import("element");
pub const Element = element_mod.Element;
/// Attr interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=Window]
/// interface Attr : Node {
/// readonly attribute DOMString? namespaceURI;
/// readonly attribute DOMString? prefix;
/// readonly attribute DOMString localName;
/// readonly attribute DOMString name;
/// [CEReactions] attribute DOMString value;
/// 
/// readonly attribute Element? ownerElement;
/// 
/// readonly attribute boolean specified; // useless; always returns true
/// };
/// ```
/// 
/// From spec:
/// - Attributes have a namespace (null or a non-empty string)
/// - Attributes have a namespace prefix (null or a non-empty string)
/// - Attributes have a local name (a non-empty string)
/// - Attributes have a value (a string)
/// - Attributes have an element (null or an element)
pub const Attr = struct {
    allocator: std.mem.Allocator,
    /// Namespace URI (null or non-empty string)
    /// 
    /// From spec: "Attributes have a namespace (null or a non-empty string)"
    namespaceUri: ?[]const u8,
    /// Namespace prefix (null or non-empty string)
    /// 
    /// From spec: "Attributes have a namespace prefix (null or a non-empty string)"
    prefix: ?[]const u8,
    /// Local name (non-empty string)
    /// 
    /// From spec: "Attributes have a local name (a non-empty string)"
    localName: []const u8,
    /// Value (string)
    /// 
    /// From spec: "Attributes have a value (a string)"
    valueStr: []const u8,
    /// Owner element (null or an element)
    /// 
    /// From spec: "Attributes have an element (null or an element)"
    ownerElement: ?*Element,

    /// Create a new Attr
    /// 
    /// Spec: § 4.8 "When an attribute is created"
    /// From spec: "When an attribute is created, its local name is given. Unless
    /// explicitly given when an attribute is created, its namespace, namespace
    /// prefix, and element are set to null, and its value is set to the empty string."
    pub fn init(
        allocator: std.mem.Allocator,
        localName: []const u8,
        namespaceUri: ?[]const u8,
        prefix: ?[]const u8,
        value: []const u8,
        ownerElement: ?*Element,
    ) !*Attr {
        const self = try allocator.create(Attr);
        errdefer allocator.destroy(self);

        // Allocate copy of local name
        const localName_copy = try allocator.dupe(u8, localName);
        errdefer allocator.free(localName_copy);

        // Allocate copy of namespace URI if provided
        const namespaceUri_copy = if (namespaceUri) |ns|
            try allocator.dupe(u8, ns)
        else
            null;
        errdefer if (namespaceUri_copy) |ns| allocator.free(ns);

        // Allocate copy of prefix if provided
        const prefix_copy = if (prefix) |p|
            try allocator.dupe(u8, p)
        else
            null;
        errdefer if (prefix_copy) |p| allocator.free(p);

        // Allocate copy of value
        const value_copy = try allocator.dupe(u8, value);
        errdefer allocator.free(value_copy);

        self.* = .{
            .allocator = allocator,
            .namespaceUri = namespaceUri_copy,
            .prefix = prefix_copy,
            .localName = localName_copy,
            .valueStr = value_copy,
            .ownerElement = ownerElement,
        };

        return self;
    }
    /// Free the Attr and its resources
    pub fn deinit(self: *Attr) void {
        // Free strings
        self.allocator.free(self.localName);
        if (self.namespaceUri) |ns| {
            self.allocator.free(ns);
        }
        if (self.prefix) |p| {
            self.allocator.free(p);
        }
        self.allocator.free(self.valueStr);

        // Free the attr itself
        self.allocator.destroy(self);
    }
    /// Get namespace URI
    /// 
    /// Spec: § 4.8 "The namespaceURI getter steps are to return this's namespace."
    pub fn getNamespaceURI(self: *const Attr) ?[]const u8 {
        return self.namespaceUri;
    }
    /// Get prefix
    /// 
    /// Spec: § 4.8 "The prefix getter steps are to return this's namespace prefix."
    pub fn getPrefix(self: *const Attr) ?[]const u8 {
        return self.prefix;
    }
    /// Get local name
    /// 
    /// Spec: § 4.8 "The localName getter steps are to return this's local name."
    pub fn getLocalName(self: *const Attr) []const u8 {
        return self.localName;
    }
    /// Get qualified name
    /// 
    /// Spec: § 4.8 "The name getter steps are to return this's qualified name."
    /// 
    /// From spec: "An attribute's qualified name is its local name if its
    /// namespace prefix is null, and its namespace prefix, followed by ':',
    /// followed by its local name, otherwise."
    pub fn getName(self: *const Attr) ![]const u8 {
        if (self.prefix) |p| {
            // Build "prefix:localName"
            const qualified = try std.fmt.allocPrint(
                self.allocator,
                "{s}:{s}",
                .{ p, self.localName },
            );
            return qualified;
        } else {
            // Return local name
            return try self.allocator.dupe(u8, self.localName);
        }
    }
    /// Get value
    /// 
    /// Spec: § 4.8 "The value getter steps are to return this's value."
    pub fn getValue(self: *const Attr) []const u8 {
        return self.valueStr;
    }
    /// Set value
    /// 
    /// Spec: § 4.8 "The value setter steps are to set an existing attribute
    /// value with this and the given value."
    /// 
    /// From spec: "To set an existing attribute value, given an attribute
    /// attribute and string value, run these steps:
    /// 1. If attribute's element is null, then set attribute's value to value.
    /// 2. Otherwise, change attribute to value."
    pub fn setValue(self: *Attr, value: []const u8) !void {
        // Free old value
        self.allocator.free(self.valueStr);

        // Allocate new value
        self.valueStr = try self.allocator.dupe(u8, value);

        // Step 1: If element is null, just set value (done above)
        // Step 2: Otherwise, change attribute to value
        // Note: "change attribute" is a more complex algorithm that involves
        // mutation observers, but for now we just update the value
        // TODO: Implement full "change attribute" algorithm when mutation
        // observers are implemented
    }
    /// Get owner element
    /// 
    /// Spec: § 4.8 "The ownerElement getter steps are to return this's element."
    pub fn getOwnerElement(self: *const Attr) ?*Element {
        return self.ownerElement;
    }
    /// Get specified (legacy attribute)
    /// 
    /// Spec: § 4.8 "The specified getter steps are to return true."
    /// 
    /// From spec: "readonly attribute boolean specified; // useless; always returns true"
    pub fn getSpecified(self: *const Attr) bool {
        _ = self;
        return true;
    }
};


// ===== Tests =====

test "Attr - initialization with minimal arguments" {
    const allocator = std.testing.allocator;

    const attr = try Attr.init(allocator, "class", null, null, "", null);
    defer attr.deinit();

    try std.testing.expectEqualStrings("class", attr.getLocalName());
    try std.testing.expectEqual(@as(?[]const u8, null), attr.getNamespaceURI());
    try std.testing.expectEqual(@as(?[]const u8, null), attr.getPrefix());
    try std.testing.expectEqualStrings("", attr.getValue());
    try std.testing.expectEqual(@as(?*Element, null), attr.getOwnerElement());
    try std.testing.expectEqual(true, attr.getSpecified());
}

test "Attr - initialization with namespace and prefix" {
    const allocator = std.testing.allocator;

    const attr = try Attr.init(
        allocator,
        "href",
        "http://www.w3.org/1999/xlink",
        "xlink",
        "http://example.com",
        null,
    );
    defer attr.deinit();

    try std.testing.expectEqualStrings("href", attr.getLocalName());
    try std.testing.expectEqualStrings("http://www.w3.org/1999/xlink", attr.getNamespaceURI().?);
    try std.testing.expectEqualStrings("xlink", attr.getPrefix().?);
    try std.testing.expectEqualStrings("http://example.com", attr.getValue());
}

test "Attr - getName with no prefix returns local name" {
    const allocator = std.testing.allocator;

    const attr = try Attr.init(allocator, "class", null, null, "foo", null);
    defer attr.deinit();

    const name = try attr.getName();
    defer allocator.free(name);

    try std.testing.expectEqualStrings("class", name);
}

test "Attr - getName with prefix returns qualified name" {
    const allocator = std.testing.allocator;

    const attr = try Attr.init(
        allocator,
        "href",
        "http://www.w3.org/1999/xlink",
        "xlink",
        "http://example.com",
        null,
    );
    defer attr.deinit();

    const name = try attr.getName();
    defer allocator.free(name);

    try std.testing.expectEqualStrings("xlink:href", name);
}

test "Attr - setValue updates value" {
    const allocator = std.testing.allocator;

    const attr = try Attr.init(allocator, "class", null, null, "foo", null);
    defer attr.deinit();

    try std.testing.expectEqualStrings("foo", attr.getValue());

    try attr.setValue("bar baz");

    try std.testing.expectEqualStrings("bar baz", attr.getValue());
}

test "Attr - getSpecified always returns true" {
    const allocator = std.testing.allocator;

    const attr = try Attr.init(allocator, "class", null, null, "", null);
    defer attr.deinit();

    try std.testing.expectEqual(true, attr.getSpecified());
}

test "Attr - memory safety with long strings" {
    const allocator = std.testing.allocator;

    const long_value = "a" ** 1000;
    const long_namespace = "http://example.com/" ++ ("x" ** 500);
    const long_localName = "attribute_" ++ ("y" ** 100);

    const attr = try Attr.init(
        allocator,
        long_localName,
        long_namespace,
        "prefix",
        long_value,
        null,
    );
    defer attr.deinit();

    try std.testing.expectEqualStrings(long_localName, attr.getLocalName());
    try std.testing.expectEqualStrings(long_namespace, attr.getNamespaceURI().?);
    try std.testing.expectEqualStrings(long_value, attr.getValue());
}

test "Attr - multiple setValue calls" {
    const allocator = std.testing.allocator;

    const attr = try Attr.init(allocator, "data-test", null, null, "initial", null);
    defer attr.deinit();

    try attr.setValue("second");
    try std.testing.expectEqualStrings("second", attr.getValue());

    try attr.setValue("third");
    try std.testing.expectEqualStrings("third", attr.getValue());

    try attr.setValue("fourth");
    try std.testing.expectEqualStrings("fourth", attr.getValue());
}
