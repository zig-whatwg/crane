// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! AbortSignal class per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-AbortSignal
//! Section: 3.1 "Interface AbortSignal"
//!
//! AbortSignal extends EventTarget and provides abort semantics for APIs
//! that need to support aborting ongoing operations.

const std = @import("std");

const webidl = @import("webidl");
const infra = @import("infra");

// Import EventTarget and Event from generated interface
const EventTarget = @import("event_target").EventTarget;
const Event = @import("event_target").Event;

/// DOM operation errors
const DOMError = error{
    /// OutOfMemory - memory allocation failed
    OutOfMemory,
};
/// AbortSignal WebIDL interface (extends EventTarget)
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface AbortSignal : EventTarget {
/// [NewObject] static AbortSignal abort(optional any reason);
/// [Exposed=(Window,Worker), NewObject] static AbortSignal timeout([EnforceRange] unsigned long long milliseconds);
/// [NewObject] static AbortSignal _any(sequence<AbortSignal> signals);
/// 
/// readonly attribute boolean aborted;
/// readonly attribute any reason;
/// undefined throwIfAborted();
/// 
/// attribute EventHandler onabort;
/// };
/// ```
/// 
/// From spec (§3.1):
/// - Has an associated **abort reason** (JavaScript value) - initially undefined
/// - Has associated **abort algorithms** (set of algorithms) - initially empty
/// - Has a **dependent** flag (boolean) - initially false
/// - Has associated **source signals** (weak set of AbortSignal) - initially empty
/// - Has associated **dependent signals** (weak set of AbortSignal) - initially empty
pub const AbortSignal = struct {
    allocator: std.mem.Allocator,
    /// Abort reason (JavaScript value)
    /// Initially undefined, set when signal is aborted
    abortReason: webidl.JSValue,
    /// Abort algorithms (set of algorithms to execute when aborted)
    /// Initially empty
    abortAlgorithms: infra.List(AbortAlgorithm),
    /// Dependent flag (boolean)
    /// Initially false
    dependent: bool,
    /// Source signals (weak set of AbortSignal objects)
    /// Initially empty
    /// TODO: Implement as weak references when available
    sourceSignals: infra.List(*AbortSignal),
    /// Dependent signals (weak set of AbortSignal objects)
    /// Initially empty
    /// TODO: Implement as weak references when available
    dependentSignals: infra.List(*AbortSignal),

    /// Constructor (internal)
    /// 
    /// Note: AbortSignal objects are created via static methods (abort, timeout, any),
    /// not directly constructed by users.
    pub fn init(allocator: std.mem.Allocator) !AbortSignal {
        return AbortSignal{
            .allocator = allocator,
            .abortReason = .{ .undefined = {} },
            .abortAlgorithms = infra.List(AbortAlgorithm).init(allocator),
            .dependent = false,
            .sourceSignals = infra.List(*AbortSignal).init(allocator),
            .dependentSignals = infra.List(*AbortSignal).init(allocator),
        };
    }
    pub fn deinit(self: *AbortSignal) void {
        self.abortAlgorithms.deinit();
        self.sourceSignals.deinit();
        self.dependentSignals.deinit();
    }

    /// IDL: static AbortSignal abort(optional any reason);
    /// 
    /// Returns an AbortSignal instance whose abort reason is set to reason
    /// if not undefined; otherwise to an "AbortError" DOMException.
    /// 
    /// Spec: § 3.1 static abort(reason) method steps:
    /// 1. Let signal be a new AbortSignal object.
    /// 2. Set signal's abort reason to reason if it is given;
    /// otherwise to a new "AbortError" DOMException.
    /// 3. Return signal.
    pub fn call_abort(
        allocator: std.mem.Allocator,
        reason: ?webidl.JSValue,
    ) !*AbortSignal {
        // Step 1: Let signal be a new AbortSignal object
        var signal = try allocator.create(AbortSignal);
        errdefer allocator.destroy(signal);

        signal.* = try AbortSignal.init(allocator);
        errdefer signal.deinit();

        // Step 2: Set signal's abort reason
        signal.abortReason = if (reason) |r|
            r
        else
            // TODO: Create proper DOMException when DOM errors are implemented
            // For now, use a string marker
            webidl.JSValue{ .string = "AbortError" };

        // Step 3: Return signal
        return signal;
    }
    /// IDL: static AbortSignal timeout([EnforceRange] unsigned long long milliseconds);
    /// 
    /// Returns an AbortSignal instance which will be aborted in milliseconds.
    /// Its abort reason will be set to a "TimeoutError" DOMException.
    /// 
    /// Spec: § 3.1 static timeout(milliseconds) method steps:
    /// 1. Let signal be a new AbortSignal object.
    /// 2. Let global be signal's relevant global object.
    /// 3. Run steps after a timeout given global, "AbortSignal-timeout",
    /// milliseconds, and queue a task to signal abort with "TimeoutError".
    /// 4. Return signal.
    /// 
    /// NOTE: Full implementation requires event loop integration to schedule
    /// the timeout. For now, we return a signal that can be manually aborted.
    /// TODO: Integrate with event loop for automatic timeout
    pub fn call_timeout(
        allocator: std.mem.Allocator,
        milliseconds: u64,
    ) !*AbortSignal {
        _ = milliseconds; // TODO: Schedule timeout with event loop

        // Step 1: Let signal be a new AbortSignal object
        const signal = try allocator.create(AbortSignal);
        errdefer allocator.destroy(signal);

        signal.* = try AbortSignal.init(allocator);

        // Signal starts non-aborted; would be aborted after timeout
        return signal;
    }
    /// IDL: static AbortSignal _any(sequence<AbortSignal> signals);
    /// 
    /// Returns an AbortSignal instance which will be aborted once any of
    /// signals is aborted. Its abort reason will be set to whichever one
    /// of signals caused it to be aborted.
    /// 
    /// Spec: § 3.1 static any(signals) method steps:
    /// Return the result of creating a dependent abort signal from signals
    /// using AbortSignal and the current realm.
    /// 
    /// NOTE: Full implementation requires tracking source/dependent signals.
    /// This is a complex feature involving weak references and signal chains.
    /// TODO: Implement full composite signal logic
    pub fn call_any(
        allocator: std.mem.Allocator,
        signals: webidl.Sequence(*AbortSignal),
    ) !*AbortSignal {
        _ = signals; // TODO: Implement createDependentAbortSignal

        const signal = try allocator.create(AbortSignal);
        errdefer allocator.destroy(signal);

        signal.* = try AbortSignal.init(allocator);
        return signal;
    }
    /// IDL: readonly attribute boolean aborted;
    /// 
    /// Returns true if signal's AbortController has signaled to abort;
    /// otherwise false.
    /// 
    /// Spec: § 3.1 aborted getter steps:
    /// Return true if signal is aborted; otherwise false.
    /// 
    /// Note: A signal is aborted when its abort reason is not undefined.
    pub fn get_aborted(self: *const AbortSignal) webidl.boolean {
        // Signal is aborted if abort reason is not undefined
        return self.abortReason != .undefined;
    }
    /// IDL: readonly attribute any reason;
    /// 
    /// Returns signal's abort reason.
    /// 
    /// Spec: § 3.1 reason getter steps:
    /// Return signal's abort reason.
    pub fn get_reason(self: *const AbortSignal) webidl.JSValue {
        return self.abortReason;
    }
    /// IDL: undefined throwIfAborted();
    /// 
    /// Throws signal's abort reason, if signal's AbortController has
    /// signaled to abort; otherwise, does nothing.
    /// 
    /// Spec: § 3.1 throwIfAborted() method steps:
    /// If this is aborted, then throw this's abort reason.
    pub fn call_throwIfAborted(self: *const AbortSignal) !void {
        if (self.get_aborted()) {
            // TODO: Throw the actual abort reason as a JavaScript exception
            // For now, return an error
            return error.AbortError;
        }
    }
    /// Signal abort (internal algorithm)
    /// 
    /// Spec: § 3.1 "To signal abort, given an AbortSignal signal and
    /// an optional reason:"
    /// 
    /// 1. If signal is aborted, then return.
    /// 2. Set signal's abort reason to reason if it is given;
    /// otherwise to a new "AbortError" DOMException.
    /// 3. Let dependentSignalsToAbort be a new list.
    /// 4. For each dependentSignal of signal's dependent signals:
    /// - If dependentSignal is not aborted, set its abort reason
    /// and append to dependentSignalsToAbort.
    /// 5. Run the abort steps for signal.
    /// 6. For each dependentSignal, run the abort steps.
    pub fn signalAbort(self: *AbortSignal, reason: ?webidl.JSValue) !void {
        // Step 1: If signal is aborted, return
        if (self.get_aborted()) {
            return;
        }

        // Step 2: Set signal's abort reason
        self.abortReason = reason orelse webidl.JSValue{ .string = "AbortError" };

        // Step 3: Let dependentSignalsToAbort be a new list
        var dependentSignalsToAbort = infra.List(*AbortSignal).init(self.allocator);
        defer dependentSignalsToAbort.deinit();

        // Step 4: For each dependentSignal of signal's dependent signals
        for (self.dependentSignals.items()) |dependentSignal| {
            if (!dependentSignal.get_aborted()) {
                dependentSignal.abortReason = self.abortReason;
                try dependentSignalsToAbort.append(dependentSignal);
            }
        }

        // Step 5: Run the abort steps for signal
        try self.runAbortSteps();

        // Step 6: For each dependentSignal, run the abort steps
        for (dependentSignalsToAbort.items()) |dependentSignal| {
            try dependentSignal.runAbortSteps();
        }
    }
    /// Run the abort steps (internal algorithm)
    /// 
    /// Spec: § 3.1 "To run the abort steps for an AbortSignal signal:"
    /// 
    /// 1. For each algorithm of signal's abort algorithms: run algorithm.
    /// 2. Empty signal's abort algorithms.
    /// 3. Fire an event named "abort" at signal.
    fn runAbortSteps(self: *AbortSignal) !void {
        // Step 1: Run each abort algorithm
        for (self.abortAlgorithms.items()) |algorithm| {
            algorithm(self.abortReason);
        }

        // Step 2: Empty abort algorithms
        self.abortAlgorithms.clear();

        // Step 3: Fire "abort" event
        // Create and dispatch abort event
        var event = try Event.init(self.allocator, "abort");
        defer event.deinit();

        // Get EventTarget base (self is already an EventTarget via extension)
        // Cast self to EventTarget to call dispatchEvent
        const event_target: *EventTarget = @ptrCast(self);
        _ = try event_target.call_dispatchEvent(&event);
    }
    /// Add an abort algorithm (internal)
    /// 
    /// Spec: § 3.1 "To add an algorithm to an AbortSignal signal:"
    /// 
    /// 1. If signal is aborted, then return.
    /// 2. Append algorithm to signal's abort algorithms.
    pub fn addAbortAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) !void {
        // Step 1: If signal is aborted, return
        if (self.get_aborted()) {
            return;
        }

        // Step 2: Append algorithm
        try self.abortAlgorithms.append(algorithm);
    }
    /// Remove an abort algorithm (internal)
    /// 
    /// Spec: § 3.1 "To remove an algorithm from an AbortSignal signal:"
    /// 
    /// Remove algorithm from signal's abort algorithms.
    pub fn removeAbortAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) !void {
        // Find and remove the algorithm
        for (self.abortAlgorithms.items(), 0..) |algo, i| {
            if (algo == algorithm) {
                _ = try self.abortAlgorithms.remove(i);
                return;
            }
        }
    }
};


/// AbortSignal algorithm function type
///
/// Abort algorithms are callbacks that execute when the signal is aborted.
/// They receive the abort reason as a parameter.
pub const AbortAlgorithm = *const fn (reason: webidl.JSValue) void;

// Export Event for consistency (re-export from event_target)
pub const AbortError = error{
    AbortError,
};
