// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Event interface per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-event
//! Section: 2.4 "Interface Event"
//!
//! Event objects are dispatched to objects implementing EventTarget.

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

// Forward declaration for EventTarget (circular dependency)
// Use module import to avoid file conflicts
const event_target_mod = @import("event_target");
pub const EventTarget = event_target_mod.EventTarget;

/// EventInit dictionary per WHATWG DOM Standard
///
/// Spec: https://dom.spec.whatwg.org/#dictdef-eventinit
/// Section: 2.4 "Interface Event"
///
/// IDL:
/// ```webidl
/// dictionary EventInit {
///   boolean bubbles = false;
///   boolean cancelable = false;
///   boolean composed = false;
/// };
/// ```
pub const EventInit = struct {
    /// Whether the event bubbles through the tree (default: false)
    bubbles: bool = false,

    /// Whether the event can be canceled (default: false)
    cancelable: bool = false,

    /// Whether the event crosses shadow DOM boundaries (default: false)
    composed: bool = false,
};

/// DOM operation errors
const DOMError = error{
    /// InvalidStateError - Object in invalid state for operation
    InvalidStateError,
};

/// Event path struct
///
/// From spec: "A path is a list of structs. Each struct consists of an
/// invocation target (an EventTarget object), an invocation-target-in-shadow-tree
/// (a boolean), a shadow-adjusted target (a potential event target), a relatedTarget
/// (a potential event target), a touch target list (a list of potential event targets),
/// a root-of-closed-tree (a boolean), and a slot-in-closed-tree (a boolean)."
pub const PathEntry = struct {
    invocationTarget: *EventTarget,
    invocationTarget_in_shadow_tree: bool,
    shadowAdjustedTarget: ?*EventTarget,
    relatedTarget: ?*EventTarget,
    touchTargetList: infra.List(?*EventTarget),
    rootOfClosedTree: bool,
    slotInClosedTree: bool,

    pub fn deinit(self: *PathEntry) void {
        self.touchTargetList.deinit();
    }
};

/// Event phase constants
///
/// From spec: "The eventPhase attribute must return the value it was initialized to,
/// which must be one of the following..."
pub const EventPhase = struct {
    /// NONE (numeric value 0) - Events not currently dispatched are in this phase
    pub const NONE: u16 = 0;

    /// CAPTURING_PHASE (numeric value 1) - When an event is dispatched to an object
    /// that participates in a tree it will be in this phase before it reaches its target
    pub const CAPTURING_PHASE: u16 = 1;

    /// AT_TARGET (numeric value 2) - When an event is dispatched it will be in this
    /// phase on its target
    pub const AT_TARGET: u16 = 2;

    /// BUBBLING_PHASE (numeric value 3) - When an event is dispatched to an object
    /// that participates in a tree it will be in this phase after it reaches its target
    pub const BUBBLING_PHASE: u16 = 3;
};
/// Event interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface Event {
/// constructor(DOMString type, optional EventInit eventInitDict = {});
/// 
/// readonly attribute DOMString type;
/// readonly attribute EventTarget? target;
/// readonly attribute EventTarget? srcElement; // legacy
/// readonly attribute EventTarget? currentTarget;
/// sequence<EventTarget> composedPath();
/// 
/// const unsigned short NONE = 0;
/// const unsigned short CAPTURING_PHASE = 1;
/// const unsigned short AT_TARGET = 2;
/// const unsigned short BUBBLING_PHASE = 3;
/// readonly attribute unsigned short eventPhase;
/// 
/// undefined stopPropagation();
/// attribute boolean cancelBubble; // legacy alias of .stopPropagation()
/// undefined stopImmediatePropagation();
/// 
/// readonly attribute boolean bubbles;
/// readonly attribute boolean cancelable;
/// attribute boolean returnValue;  // legacy
/// undefined preventDefault();
/// readonly attribute boolean defaultPrevented;
/// readonly attribute boolean composed;
/// 
/// [LegacyUnforgeable] readonly attribute boolean isTrusted;
/// readonly attribute DOMHighResTimeStamp timeStamp;
/// 
/// undefined initEvent(DOMString type, optional boolean bubbles = false, optional boolean cancelable = false); // legacy
/// };
/// ```
pub const Event = struct {
    allocator: std.mem.Allocator,
    /// Event type (e.g., "click", "load", "error")
    /// 
    /// From spec: "When an event is created the attribute must be initialized
    /// to the empty string."
    typeStr: []const u8,
    /// Target to which the event is dispatched
    /// 
    /// From spec: "An event has an associated target (a potential event target).
    /// Unless stated otherwise it is null."
    target: ?*EventTarget,
    /// Object whose event listener's callback is currently being invoked
    /// 
    /// From spec: "When an event is created the attribute must be initialized
    /// to null."
    currentTarget: ?*EventTarget,
    /// Event phase (NONE, CAPTURING_PHASE, AT_TARGET, BUBBLING_PHASE)
    /// 
    /// From spec: "Initially the attribute must be initialized to NONE."
    eventPhase: u16,
    /// Whether the event bubbles
    /// 
    /// From spec: "True if event goes through its target's ancestors in
    /// reverse tree order; otherwise false."
    bubbles: bool,
    /// Whether the event can be canceled
    /// 
    /// From spec: "True can indicate that part of the operation during which
    /// event was dispatched, can be canceled by invoking preventDefault()."
    cancelable: bool,
    /// Whether the event invokes listeners past ShadowRoot boundaries
    /// 
    /// From spec: "True if event invokes listeners past a ShadowRoot node
    /// that is the root of its target; otherwise false."
    composedFlag: bool,
    /// Whether the event was dispatched by the user agent
    /// 
    /// From spec: "Returns true if event was dispatched by the user agent,
    /// and false otherwise."
    isTrusted: bool,
    /// Timestamp of when the event was created (milliseconds)
    /// 
    /// From spec: "Returns the event's timestamp as the number of milliseconds
    /// measured relative to the time origin."
    timeStamp: f64,
    /// Stop propagation flag
    /// 
    /// From spec: "Each event has the following associated flags that are all
    /// initially unset: stop propagation flag"
    stop_propagation_flag: bool,
    /// Stop immediate propagation flag
    /// 
    /// From spec: "stop immediate propagation flag"
    stop_immediate_propagation_flag: bool,
    /// Canceled flag
    /// 
    /// From spec: "canceled flag"
    canceled_flag: bool,
    /// In passive listener flag
    /// 
    /// From spec: "in passive listener flag"
    in_passive_listener_flag: bool,
    /// Initialized flag
    /// 
    /// From spec: "initialized flag"
    initialized_flag: bool,
    /// Dispatch flag
    /// 
    /// From spec: "dispatch flag"
    dispatch_flag: bool,
    /// Event path
    /// 
    /// From spec: "An event has an associated path. A path is a list of structs...
    /// A path is initially the empty list."
    path: infra.List(PathEntry),

    /// Create a new Event
    /// 
    /// Spec: Event constructor algorithm
    /// From spec: "Returns a new event whose type attribute value is set to type.
    /// The eventInitDict argument allows for setting the bubbles and cancelable
    /// attributes via object members of the same name."
    pub fn init(allocator: std.mem.Allocator, event_type: []const u8, init_dict: EventInit) !*Event {
        const self = try allocator.create(Event);
        errdefer allocator.destroy(self);

        // Allocate copy of type string
        const type_copy = try allocator.dupe(u8, event_type);
        errdefer allocator.free(type_copy);

        // Initialize path list
        var path = infra.List(PathEntry).init(allocator);
        errdefer path.deinit();

        // Get current timestamp (using monotonic time in milliseconds)
        const now_ns = std.time.nanoTimestamp();
        const now_ms = @as(f64, @floatFromInt(now_ns)) / 1_000_000.0;

        self.* = .{
            .allocator = allocator,
            .typeStr = type_copy,
            .target = null,
            .currentTarget = null,
            .eventPhase = EventPhase.NONE,
            .bubbles = init_dict.bubbles,
            .cancelable = init_dict.cancelable,
            .composedFlag = init_dict.composed,
            .isTrusted = false, // From spec: "When an event is created the attribute must be initialized to false"
            .timeStamp = now_ms,
            .stop_propagation_flag = false,
            .stop_immediate_propagation_flag = false,
            .canceled_flag = false,
            .in_passive_listener_flag = false,
            .initialized_flag = false,
            .dispatch_flag = false,
            .path = path,
        };

        return self;
    }
    /// Free the event and its resources
    pub fn deinit(self: *Event) void {
        // Free path entries
        for (self.path.items()) |*entry| {
            entry.deinit();
        }
        self.path.deinit();

        // Free type string
        self.allocator.free(self.typeStr);

        // Free the event itself
        self.allocator.destroy(self);
    }
    /// Get event type
    /// 
    /// Spec: § 2.4 "The type attribute must return the value it was initialized to."
    pub fn getType(self: *const Event) []const u8 {
        return self.typeStr;
    }
    /// Get target
    /// 
    /// Spec: § 2.4 "The target getter steps are to return this's target."
    pub fn getTarget(self: *const Event) ?*EventTarget {
        return self.target;
    }
    /// Get srcElement (legacy alias for target)
    /// 
    /// Spec: § 2.4 "The srcElement getter steps are to return this's target."
    pub fn getSrcElement(self: *const Event) ?*EventTarget {
        return self.target;
    }
    /// Get currentTarget
    /// 
    /// Spec: § 2.4 "The currentTarget attribute must return the value it was
    /// initialized to."
    pub fn getCurrentTarget(self: *const Event) ?*EventTarget {
        return self.currentTarget;
    }
    /// Get event phase
    /// 
    /// Spec: § 2.4 "The eventPhase attribute must return the value it was
    /// initialized to, which must be one of the following..."
    pub fn getEventPhase(self: *const Event) u16 {
        return self.eventPhase;
    }
    /// Get bubbles flag
    /// 
    /// Spec: § 2.4 "The bubbles and cancelable attributes must return the
    /// values they were initialized to."
    pub fn getBubbles(self: *const Event) bool {
        return self.bubbles;
    }
    /// Get cancelable flag
    /// 
    /// Spec: § 2.4 "The bubbles and cancelable attributes must return the
    /// values they were initialized to."
    pub fn getCancelable(self: *const Event) bool {
        return self.cancelable;
    }
    /// Get composed flag
    /// 
    /// Spec: § 2.4 "The composed getter steps are to return true if this's
    /// composed flag is set; otherwise false."
    pub fn getComposed(self: *const Event) bool {
        return self.composedFlag;
    }
    /// Get isTrusted flag
    /// 
    /// Spec: § 2.4 "The isTrusted attribute must return the value it was
    /// initialized to."
    pub fn getIsTrusted(self: *const Event) bool {
        return self.isTrusted;
    }
    /// Get timestamp
    /// 
    /// Spec: § 2.4 "The timeStamp attribute must return the value it was
    /// initialized to."
    pub fn getTimeStamp(self: *const Event) f64 {
        return self.timeStamp;
    }
    /// Get defaultPrevented flag
    /// 
    /// Spec: § 2.4 "The defaultPrevented getter steps are to return true if
    /// this's canceled flag is set; otherwise false."
    pub fn getDefaultPrevented(self: *const Event) bool {
        return self.canceled_flag;
    }
    /// Get cancelBubble (legacy)
    /// 
    /// Spec: § 2.4 "The cancelBubble getter steps are to return true if this's
    /// stop propagation flag is set; otherwise false."
    pub fn getCancelBubble(self: *const Event) bool {
        return self.stop_propagation_flag;
    }
    /// Set cancelBubble (legacy)
    /// 
    /// Spec: § 2.4 "The cancelBubble setter steps are to set this's stop
    /// propagation flag if the given value is true; otherwise do nothing."
    pub fn setCancelBubble(self: *Event, value: bool) void {
        if (value) {
            self.stop_propagation_flag = true;
        }
    }
    /// Get returnValue (legacy)
    /// 
    /// Spec: § 2.4 "The returnValue getter steps are to return false if this's
    /// canceled flag is set; otherwise true."
    pub fn getReturnValue(self: *const Event) bool {
        return !self.canceled_flag;
    }
    /// Set returnValue (legacy)
    /// 
    /// Spec: § 2.4 "The returnValue setter steps are to set the canceled flag
    /// with this if the given value is false; otherwise do nothing."
    pub fn setReturnValue(self: *Event, value: bool) void {
        if (!value) {
            self.setCanceledFlag();
        }
    }
    /// Stop propagation
    /// 
    /// Spec: § 2.4 "The stopPropagation() method steps are to set this's stop
    /// propagation flag."
    pub fn stopPropagation(self: *Event) void {
        self.stop_propagation_flag = true;
    }
    /// Stop immediate propagation
    /// 
    /// Spec: § 2.4 "The stopImmediatePropagation() method steps are to set
    /// this's stop propagation flag and this's stop immediate propagation flag."
    pub fn stopImmediatePropagation(self: *Event) void {
        self.stop_propagation_flag = true;
        self.stop_immediate_propagation_flag = true;
    }
    /// Prevent default action
    /// 
    /// Spec: § 2.4 "The preventDefault() method steps are to set the canceled
    /// flag with this."
    pub fn preventDefault(self: *Event) void {
        self.setCanceledFlag();
    }
    /// Set the canceled flag (internal helper)
    /// 
    /// Spec: § 2.4 "To set the canceled flag, given an event event, if event's
    /// cancelable attribute value is true and event's in passive listener flag
    /// is unset, then set event's canceled flag, and do nothing otherwise."
    fn setCanceledFlag(self: *Event) void {
        if (self.cancelable and !self.in_passive_listener_flag) {
            self.canceled_flag = true;
        }
    }
    /// Get composed path
    /// 
    /// Spec: § 2.4 composedPath() algorithm (steps 1-17)
    /// 
    /// Returns the invocation target objects of event's path (objects on which
    /// listeners will be invoked), except for any nodes in shadow trees of which
    /// the shadow root's mode is "closed" that are not reachable from event's
    /// currentTarget.
    pub fn composedPath(self: *Event, allocator: std.mem.Allocator) !infra.List(*EventTarget) {
        // Step 1: Let composedPath be an empty list
        var composed_path = infra.List(*EventTarget).init(allocator);
        errdefer composed_path.deinit();

        // Step 2: Let path be this's path
        const path = self.path;

        // Step 3: If path is empty, then return composedPath
        if (path.len() == 0) {
            return composed_path;
        }

        // Step 4: Let currentTarget be this's currentTarget attribute value
        const currentTarget = self.currentTarget;

        // Step 5: Assert: currentTarget is an EventTarget object
        // (In Zig, this is enforced by the type system if currentTarget is non-null)
        if (currentTarget == null) {
            // Path is not empty but currentTarget is null - return empty path
            return composed_path;
        }

        // Step 6: Append currentTarget to composedPath
        try composed_path.append(currentTarget.?);

        // Step 7: Let currentTargetIndex be 0
        var currentTarget_index: usize = 0;

        // Step 8: Let currentTargetHiddenSubtreeLevel be 0
        var currentTarget_hidden_subtree_level: i32 = 0;

        // Step 9: Let index be path's size − 1
        var index: i32 = @as(i32, @intCast(path.len())) - 1;

        // Step 10: While index is greater than or equal to 0
        while (index >= 0) : (index -= 1) {
            const entry = path.get(@intCast(index));

            // Step 10.1: If path[index]'s root-of-closed-tree is true, then
            // increase currentTargetHiddenSubtreeLevel by 1
            if (entry.rootOfClosedTree) {
                currentTarget_hidden_subtree_level += 1;
            }

            // Step 10.2: If path[index]'s invocation target is currentTarget,
            // then set currentTargetIndex to index and break
            if (entry.invocationTarget == currentTarget.?) {
                currentTarget_index = @intCast(index);
                break;
            }

            // Step 10.3: If path[index]'s slot-in-closed-tree is true, then
            // decrease currentTargetHiddenSubtreeLevel by 1
            if (entry.slotInClosedTree) {
                currentTarget_hidden_subtree_level -= 1;
            }
        }

        // Step 11: Let currentHiddenLevel and maxHiddenLevel be
        // currentTargetHiddenSubtreeLevel
        var current_hidden_level = currentTarget_hidden_subtree_level;
        var max_hidden_level = currentTarget_hidden_subtree_level;

        // Step 12: Set index to currentTargetIndex − 1
        index = @as(i32, @intCast(currentTarget_index)) - 1;

        // Step 13: While index is greater than or equal to 0
        while (index >= 0) : (index -= 1) {
            const entry = path.get(@intCast(index));

            // Step 13.1: If path[index]'s root-of-closed-tree is true, then
            // increase currentHiddenLevel by 1
            if (entry.rootOfClosedTree) {
                current_hidden_level += 1;
            }

            // Step 13.2: If currentHiddenLevel is less than or equal to
            // maxHiddenLevel, then prepend path[index]'s invocation target
            // to composedPath
            if (current_hidden_level <= max_hidden_level) {
                try composed_path.prepend(entry.invocationTarget);
            }

            // Step 13.3: If path[index]'s slot-in-closed-tree is true
            if (entry.slotInClosedTree) {
                // Step 13.3.1: Decrease currentHiddenLevel by 1
                current_hidden_level -= 1;

                // Step 13.3.2: If currentHiddenLevel is less than maxHiddenLevel,
                // then set maxHiddenLevel to currentHiddenLevel
                if (current_hidden_level < max_hidden_level) {
                    max_hidden_level = current_hidden_level;
                }
            }
        }

        // Step 14: Set currentHiddenLevel and maxHiddenLevel to
        // currentTargetHiddenSubtreeLevel
        current_hidden_level = currentTarget_hidden_subtree_level;
        max_hidden_level = currentTarget_hidden_subtree_level;

        // Step 15: Set index to currentTargetIndex + 1
        index = @as(i32, @intCast(currentTarget_index)) + 1;

        // Step 16: While index is less than path's size
        while (index < @as(i32, @intCast(path.len()))) : (index += 1) {
            const entry = path.get(@intCast(index));

            // Step 16.1: If path[index]'s slot-in-closed-tree is true, then
            // increase currentHiddenLevel by 1
            if (entry.slotInClosedTree) {
                current_hidden_level += 1;
            }

            // Step 16.2: If currentHiddenLevel is less than or equal to
            // maxHiddenLevel, then append path[index]'s invocation target
            // to composedPath
            if (current_hidden_level <= max_hidden_level) {
                try composed_path.append(entry.invocationTarget);
            }

            // Step 16.3: If path[index]'s root-of-closed-tree is true
            if (entry.rootOfClosedTree) {
                // Step 16.3.1: Decrease currentHiddenLevel by 1
                current_hidden_level -= 1;

                // Step 16.3.2: If currentHiddenLevel is less than maxHiddenLevel,
                // then set maxHiddenLevel to currentHiddenLevel
                if (current_hidden_level < max_hidden_level) {
                    max_hidden_level = current_hidden_level;
                }
            }
        }

        // Step 17: Return composedPath
        return composed_path;
    }
    /// Initialize event (legacy)
    /// 
    /// Spec: § 2.4 initEvent() method
    /// 
    /// From spec: "initEvent() is redundant with event constructors and incapable
    /// of setting composed. It has to be supported for legacy content."
    pub fn initEvent(self: *Event, event_type: []const u8, bubbles_arg: bool, cancelable_arg: bool) !void {
        // Step 1: If this's dispatch flag is set, then return
        if (self.dispatch_flag) {
            return;
        }

        // Step 2: Initialize this with type, bubbles, and cancelable
        try self.initialize(event_type, bubbles_arg, cancelable_arg);
    }
    /// Initialize an event (internal algorithm)
    /// 
    /// Spec: § 2.4 "To initialize an event" algorithm (steps 1-7)
    fn initialize(self: *Event, event_type: []const u8, bubbles_arg: bool, cancelable_arg: bool) !void {
        // Step 1: Set event's initialized flag
        self.initialized_flag = true;

        // Step 2: Unset event's stop propagation flag, stop immediate
        // propagation flag, and canceled flag
        self.stop_propagation_flag = false;
        self.stop_immediate_propagation_flag = false;
        self.canceled_flag = false;

        // Step 3: Set event's isTrusted attribute to false
        self.isTrusted = false;

        // Step 4: Set event's target to null
        self.target = null;

        // Step 5: Set event's type attribute to type
        // Free old type string and allocate new one
        self.allocator.free(self.typeStr);
        self.typeStr = try self.allocator.dupe(u8, event_type);

        // Step 6: Set event's bubbles attribute to bubbles
        self.bubbles = bubbles_arg;

        // Step 7: Set event's cancelable attribute to cancelable
        self.cancelable = cancelable_arg;
    }
};


// ===== Tests =====

test "Event - constructor with defaults" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{});
    defer event.deinit();

    try std.testing.expectEqualStrings("click", event.getType());
    try std.testing.expectEqual(@as(?*EventTarget, null), event.getTarget());
    try std.testing.expectEqual(@as(?*EventTarget, null), event.getCurrentTarget());
    try std.testing.expectEqual(EventPhase.NONE, event.getEventPhase());
    try std.testing.expectEqual(false, event.getBubbles());
    try std.testing.expectEqual(false, event.getCancelable());
    try std.testing.expectEqual(false, event.getComposed());
    try std.testing.expectEqual(false, event.getIsTrusted());
    try std.testing.expectEqual(false, event.getDefaultPrevented());
}

test "Event - constructor with EventInit" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "submit", .{
        .bubbles = true,
        .cancelable = true,
        .composed = true,
    });
    defer event.deinit();

    try std.testing.expectEqualStrings("submit", event.getType());
    try std.testing.expectEqual(true, event.getBubbles());
    try std.testing.expectEqual(true, event.getCancelable());
    try std.testing.expectEqual(true, event.getComposed());
}

test "Event - stopPropagation sets flag" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{});
    defer event.deinit();

    try std.testing.expectEqual(false, event.stop_propagation_flag);

    event.stopPropagation();

    try std.testing.expectEqual(true, event.stop_propagation_flag);
    try std.testing.expectEqual(false, event.stop_immediate_propagation_flag);
}

test "Event - stopImmediatePropagation sets both flags" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{});
    defer event.deinit();

    try std.testing.expectEqual(false, event.stop_propagation_flag);
    try std.testing.expectEqual(false, event.stop_immediate_propagation_flag);

    event.stopImmediatePropagation();

    try std.testing.expectEqual(true, event.stop_propagation_flag);
    try std.testing.expectEqual(true, event.stop_immediate_propagation_flag);
}

test "Event - preventDefault on cancelable event" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{ .cancelable = true });
    defer event.deinit();

    try std.testing.expectEqual(false, event.getDefaultPrevented());

    event.preventDefault();

    try std.testing.expectEqual(true, event.getDefaultPrevented());
}

test "Event - preventDefault on non-cancelable event does nothing" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{ .cancelable = false });
    defer event.deinit();

    try std.testing.expectEqual(false, event.getDefaultPrevented());

    event.preventDefault();

    // Should still be false because event is not cancelable
    try std.testing.expectEqual(false, event.getDefaultPrevented());
}

test "Event - preventDefault in passive listener does nothing" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{ .cancelable = true });
    defer event.deinit();

    // Simulate being in a passive listener
    event.in_passive_listener_flag = true;

    event.preventDefault();

    // Should still be false because we're in a passive listener
    try std.testing.expectEqual(false, event.getDefaultPrevented());
}

test "Event - cancelBubble legacy attribute" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{});
    defer event.deinit();

    try std.testing.expectEqual(false, event.getCancelBubble());

    event.setCancelBubble(true);

    try std.testing.expectEqual(true, event.getCancelBubble());
    try std.testing.expectEqual(true, event.stop_propagation_flag);

    // Setting to false should do nothing
    event.setCancelBubble(false);

    try std.testing.expectEqual(true, event.getCancelBubble());
}

test "Event - returnValue legacy attribute" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{ .cancelable = true });
    defer event.deinit();

    try std.testing.expectEqual(true, event.getReturnValue());

    event.setReturnValue(false);

    try std.testing.expectEqual(false, event.getReturnValue());
    try std.testing.expectEqual(true, event.getDefaultPrevented());

    // Setting to true should do nothing
    event.setReturnValue(true);

    try std.testing.expectEqual(false, event.getReturnValue());
}

test "Event - srcElement returns target" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{});
    defer event.deinit();

    try std.testing.expectEqual(event.getTarget(), event.getSrcElement());
}

test "Event - timestamp is set" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{});
    defer event.deinit();

    const timestamp = event.getTimeStamp();
    try std.testing.expect(timestamp > 0);
}

test "Event - composedPath returns empty when path is empty" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{});
    defer event.deinit();

    var composed = try event.composedPath(allocator);
    defer composed.deinit();

    try std.testing.expectEqual(@as(usize, 0), composed.len());
}

test "Event - initEvent changes type and flags" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{
        .bubbles = false,
        .cancelable = false,
    });
    defer event.deinit();

    try event.initEvent("submit", true, true);

    try std.testing.expectEqualStrings("submit", event.getType());
    try std.testing.expectEqual(true, event.getBubbles());
    try std.testing.expectEqual(true, event.getCancelable());
    try std.testing.expectEqual(false, event.getIsTrusted()); // Should be reset to false
}

test "Event - initEvent does nothing when dispatch flag is set" {
    const allocator = std.testing.allocator;

    const event = try Event.init(allocator, "click", .{
        .bubbles = false,
        .cancelable = false,
    });
    defer event.deinit();

    // Simulate event being dispatched
    event.dispatch_flag = true;

    try event.initEvent("submit", true, true);

    // Should still be "click" because initEvent was blocked
    try std.testing.expectEqualStrings("click", event.getType());
    try std.testing.expectEqual(false, event.getBubbles());
    try std.testing.expectEqual(false, event.getCancelable());
}

test "Event - phase constants" {
    try std.testing.expectEqual(@as(u16, 0), EventPhase.NONE);
    try std.testing.expectEqual(@as(u16, 1), EventPhase.CAPTURING_PHASE);
    try std.testing.expectEqual(@as(u16, 2), EventPhase.AT_TARGET);
    try std.testing.expectEqual(@as(u16, 3), EventPhase.BUBBLING_PHASE);
}
