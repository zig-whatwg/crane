// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Console Supporting Types
//!
//! This file defines supporting types for the Console WHATWG implementation.
//! These types are NOT WebIDL interfacees - they're plain Zig types.
//!
//! Spec: https://console.spec.whatwg.org/

const std = @import("std");
const infra = @import("infra");
const webidl = @import("webidl");

const Allocator = std.mem.Allocator;

/// A group represents a collapsible/expandable section in the console output.
///
/// WHATWG Console Standard lines 178-179:
/// "A group is an implementation-defined, potentially-interactive view for output
/// produced by calls to Printer, with one further level of indentation than its parent."
///
/// Groups are maintained on a stack (groupStack) where only the last group
/// receives output from Printer calls.
pub const Group = struct {
    /// Optional label for the group.
    /// If null, an implementation-chosen default label is used.
    label: ?webidl.DOMString,

    /// Whether the group is collapsed by default (groupCollapsed) or expanded (group).
    /// This is a hint for interactive environments (browser DevTools).
    collapsed: bool,

    /// Create a new expanded group with optional label.
    pub fn init(label: ?webidl.DOMString) Group {
        return .{
            .label = label,
            .collapsed = false,
        };
    }

    /// Create a new collapsed group with optional label.
    pub fn initCollapsed(label: ?webidl.DOMString) Group {
        return .{
            .label = label,
            .collapsed = true,
        };
    }
};

/// A console message stored in the message buffer.
///
/// Messages are buffered to provide message history and enable lazy formatting.
/// This follows the browser pattern where messages are stored and formatted
/// only when DevTools is opened or when explicitly requested.
///
/// Phase 3 (Lazy Formatting): Store raw args, format on demand.
/// See BROWSER_PATTERNS.md Phase 2-3 for details.
pub const Message = struct {
    /// The log level/severity of this message.
    logLevel: LogLevel,

    /// When the message was created (high-precision timestamp).
    timestamp: infra.Moment,

    /// Raw arguments to be formatted lazily.
    /// Stored as owned slice - must be freed in deinit().
    args: []const webidl.JSValue,

    /// Group indentation level (captured at message creation time).
    indent: usize,

    /// Owned strings that need to be freed with this message.
    /// This tracks dynamically allocated strings in args to prevent leaks.
    /// Strings in this list are freed in deinit().
    ownedStrings: infra.List([]const u8),

    /// Create a new message with raw arguments (Phase 3 lazy formatting).
    pub fn init(logLevel: LogLevel, timestamp: infra.Moment, args: []const webidl.JSValue, indent: usize, allocator: std.mem.Allocator) !Message {
        // Clone the args slice so we own it
        const owned_args = try allocator.dupe(webidl.JSValue, args);
        return .{
            .logLevel = logLevel,
            .timestamp = timestamp,
            .args = owned_args,
            .indent = indent,
            .ownedStrings = infra.List([]const u8).init(allocator),
        };
    }

    /// Create a new message and take ownership of specified strings.
    /// The strings in ownedStrings_to_track will be freed when the message is destroyed.
    pub fn initWithOwnedStrings(
        logLevel: LogLevel,
        timestamp: infra.Moment,
        args: []const webidl.JSValue,
        indent: usize,
        ownedStrings_to_track: []const []const u8,
        allocator: std.mem.Allocator,
    ) !Message {
        var msg = try init(logLevel, timestamp, args, indent, allocator);
        errdefer msg.deinit(allocator);

        // Add all owned strings to tracking list
        for (ownedStrings_to_track) |owned_str| {
            try msg.ownedStrings.append(owned_str);
        }

        return msg;
    }

    /// Format the message for display.
    /// This is where lazy formatting happens - only when actually needed.
    pub fn format(self: *const Message, allocator: std.mem.Allocator) ![]const u8 {
        // Format args to string using infra.List (not std.ArrayList)
        var result = infra.List(u8).init(allocator);
        errdefer result.deinit();

        // Add indentation (2 spaces per level)
        var indent_count: usize = 0;
        while (indent_count < self.indent) : (indent_count += 1) {
            try result.appendSlice("  ");
        }

        // Format level tag
        const level_tag = try std.fmt.allocPrint(allocator, "[{s}] ", .{@tagName(self.logLevel)});
        defer allocator.free(level_tag);
        try result.appendSlice(level_tag);

        // Convert each JSValue arg to string
        for (self.args, 0..) |arg, i| {
            if (i > 0) try result.append(' ');

            const arg_str = switch (arg) {
                .string => |s| s,
                .number => |n| {
                    const temp = try std.fmt.allocPrint(allocator, "{d}", .{n});
                    defer allocator.free(temp);
                    try result.appendSlice(temp);
                    continue;
                },
                .boolean => |b| if (b) "true" else "false",
                .null => "null",
                .undefined => "undefined",
            };
            try result.appendSlice(arg_str);
        }

        // Return owned copy of the formatted string
        const items_slice = result.items();
        const owned = try allocator.dupe(u8, items_slice);
        result.deinit();
        return owned;
    }

    /// Free the args slice and any owned strings.
    pub fn deinit(self: *Message, allocator: std.mem.Allocator) void {
        // Free all owned strings
        var i: usize = 0;
        while (i < self.ownedStrings.size()) : (i += 1) {
            const owned_str = self.ownedStrings.get(i).?;
            allocator.free(owned_str);
        }
        self.ownedStrings.deinit();

        // Free the args array
        allocator.free(self.args);
    }

    /// Add a string to the owned strings list.
    /// This string will be freed when the message is destroyed.
    /// Use this when passing dynamically allocated strings to logger/printer.
    pub fn takeOwnership(self: *Message, owned_str: []const u8) !void {
        try self.ownedStrings.append(owned_str);
    }
};

/// A circular buffer for storing console messages.
///
/// Follows the browser pattern of buffering up to N messages (default 1000).
/// When the buffer is full, the oldest message is discarded (FIFO).
///
/// This provides message history for DevTools and enables lazy formatting.
///
/// See BROWSER_PATTERNS.md Phase 2 for details.
pub const CircularMessageBuffer = struct {
    const Self = @This();

    allocator: std.mem.Allocator,
    buffer: []?Message,
    maxSize: usize,
    head: usize, // Next write position
    tail: usize, // Next read position
    count: usize, // Current number of messages

    /// Initialize an empty circular buffer with specified maximum size.
    pub fn init(allocator: std.mem.Allocator, maxSize: usize) !Self {
        const buffer = try allocator.alloc(?Message, maxSize);
        @memset(buffer, null);

        return .{
            .allocator = allocator,
            .buffer = buffer,
            .maxSize = maxSize,
            .head = 0,
            .tail = 0,
            .count = 0,
        };
    }

    /// Free all messages and the buffer.
    pub fn deinit(self: *Self) void {
        self.clear();
        self.allocator.free(self.buffer);
    }

    /// Add a message to the buffer.
    /// If buffer is full, the oldest message is freed and discarded.
    pub fn push(self: *Self, message: Message) void {
        // If buffer is full, free the oldest message
        if (self.count == self.maxSize) {
            if (self.buffer[self.tail]) |*old_msg| {
                old_msg.deinit(self.allocator);
            }
            self.tail = (self.tail + 1) % self.maxSize;
            self.count -= 1;
        }

        // Add new message
        self.buffer[self.head] = message;
        self.head = (self.head + 1) % self.maxSize;
        self.count += 1;
    }

    /// Get a message at index (0 = oldest, count-1 = newest).
    /// Returns null if index is out of bounds.
    pub fn get(self: *const Self, index: usize) ?*const Message {
        if (index >= self.count) return null;
        const actual_index = (self.tail + index) % self.maxSize;
        if (self.buffer[actual_index]) |*msg| {
            return msg;
        }
        return null;
    }

    /// Remove and return the oldest message (FIFO).
    /// Caller is responsible for calling deinit() on the returned message.
    pub fn pop(self: *Self) ?Message {
        if (self.count == 0) return null;

        const message = self.buffer[self.tail];
        self.buffer[self.tail] = null;
        self.tail = (self.tail + 1) % self.maxSize;
        self.count -= 1;

        return message;
    }

    /// Clear all messages from the buffer.
    pub fn clear(self: *Self) void {
        while (self.pop()) |msg| {
            var msg_mut = msg;
            msg_mut.deinit(self.allocator);
        }
    }

    /// Get the current number of messages in the buffer.
    pub fn size(self: *const Self) usize {
        return self.count;
    }

    /// Check if the buffer is empty.
    pub fn isEmpty(self: *const Self) bool {
        return self.count == 0;
    }

    /// Check if the buffer is full.
    pub fn isFull(self: *const Self) bool {
        return self.count == self.maxSize;
    }
};

/// Log level severity for Printer operations.
///
/// WHATWG Console Standard lines 373-383:
/// Each console function uses a unique value for the logLevel parameter,
/// allowing implementations to customize output. Common groupings:
/// - log: log(), trace(), dir(), dirxml(), group(), groupCollapsed(), debug(), timeLog()
/// - info: count(), info(), timeEnd()
/// - warn: warn(), countReset()
/// - error: error(), assert()
///
/// Note: We use explicit names to avoid conflicts with Zig keywords (error â†’ error_level).
pub const LogLevel = enum {
    // Logging methods
    assert_level, // assert() - avoid "assert" keyword conflict
    clear,
    debug,
    error_level, // error() - avoid "error" keyword conflict
    info,
    log,
    warn,
    dir,
    dirxml,
    trace,

    // Counting methods
    count,
    count_reset,

    // Grouping methods
    group,
    group_collapsed,

    // Timing methods
    time,
    time_log,
    time_end,

    // Table method
    table,

    /// Get the severity grouping for this log level.
    /// This is informative for implementations that want to group similar log levels.
    pub fn getSeverity(self: LogLevel) Severity {
        return switch (self) {
            .log, .trace, .dir, .dirxml, .group, .group_collapsed, .debug, .time_log => .log,
            .count, .info, .time_end => .info,
            .warn, .count_reset => .warn,
            .error_level, .assert_level => .@"error",
            .clear, .time, .table => .log, // Implementation-specific defaults
        };
    }

    pub const Severity = enum {
        log,
        info,
        warn,
        @"error",
    };
};

/// Represents a single frame in a JavaScript call stack.
///
/// Used by console.trace() to display the call stack.
/// Frames are ordered from innermost (most recent) to outermost.
///
/// See: RUNTIME_INTERFACE_DESIGN.md - Stack Traces section
pub const StackFrame = struct {
    /// Function name (null if anonymous)
    functionName: ?[]const u8,

    /// File path or URL (null if unknown)
    fileName: ?[]const u8,

    /// Line number (1-based, 0 if unknown)
    lineNumber: u32,

    /// Column number (1-based, 0 if unknown)
    columnNumber: u32,

    /// Format stack frame for display.
    /// Example: "at myFunction (file:///app.js:15:10)"
    pub fn format(self: *const StackFrame, allocator: Allocator) ![]const u8 {
        const func_name = self.functionName orelse "<anonymous>";

        if (self.fileName) |file| {
            return try std.fmt.allocPrint(
                allocator,
                "    at {s} ({s}:{d}:{d})",
                .{ func_name, file, self.lineNumber, self.columnNumber },
            );
        } else {
            return try std.fmt.allocPrint(
                allocator,
                "    at {s}",
                .{func_name},
            );
        }
    }
};

/// Runtime integration interface for JavaScript engines.
///
/// This interface allows the console library to interact with any JavaScript
/// runtime (V8, JavaScriptCore, SpiderMonkey, etc.) through a vtable pattern.
///
/// # Lifetime
/// - The RuntimeInterface is borrowed by Console (not owned)
/// - Runtime must outlive all Console instances using it
/// - Console.deinit() does NOT free the runtime (caller's responsibility)
///
/// # Thread Safety
/// - RuntimeInterface must be used from the same thread that created it
/// - No synchronization is provided by the console library
/// - Runtime is responsible for thread safety of its operations
///
/// See: RUNTIME_INTERFACE_DESIGN.md for complete specification
pub const RuntimeInterface = struct {
    /// Function pointers for runtime operations
    vtable: *const VTable,

    /// Opaque pointer to runtime-specific context
    /// Cast to your runtime's context type in vtable implementations
    context: *anyopaque,
};

/// Virtual function table for runtime operations.
///
/// Each function receives the opaque context as first parameter.
/// The context should be cast to the runtime's specific context type:
///
///   const my_ctx: *MyRuntimeContext = @ptrCast(@alignCast(ctx));
///
/// # Error Handling
/// - Functions should return Zig errors for failures
/// - Do NOT panic or abort on errors
/// - Return null for optional operations that fail
///
/// # Memory Management
/// - Allocated memory is owned by the caller (console library)
/// - Runtime must NOT retain pointers after function returns
/// - Allocator is provided for all allocations
///
/// See: RUNTIME_INTERFACE_DESIGN.md - VTable section
pub const VTable = struct {
    // ========================================================================
    // Type Checking (Required)
    // ========================================================================

    /// Check if a JSValue is a JavaScript Array.
    ///
    /// # Spec Reference
    /// ECMAScript: IsArray(argument)
    /// https://tc39.es/ecma262/#sec-isarray
    isArray: *const fn (ctx: *anyopaque, value: webidl.JSValue) bool,

    /// Check if a JSValue is a JavaScript Object (non-null, non-primitive).
    ///
    /// # Spec Reference
    /// ECMAScript: Type(x) = Object
    /// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
    isObject: *const fn (ctx: *anyopaque, value: webidl.JSValue) bool,

    /// Check if a JSValue is a JavaScript Symbol.
    ///
    /// # Spec Reference
    /// ECMAScript: Type(x) = Symbol
    /// https://tc39.es/ecma262/#sec-ecmascript-language-types-symbol-type
    isSymbol: *const fn (ctx: *anyopaque, value: webidl.JSValue) bool,

    // ========================================================================
    // Type Conversion (Required for Format Specifiers)
    // ========================================================================

    /// Convert JSValue to string using ECMAScript ToString.
    ///
    /// # Spec Reference
    /// ECMAScript: ToString(argument)
    /// https://tc39.es/ecma262/#sec-tostring
    ///
    /// WHATWG Console: Format specifier %s
    /// https://console.spec.whatwg.org/#formatter
    ///
    /// # Returns
    /// UTF-8 encoded string. Caller owns memory (must free).
    toString: *const fn (
        ctx: *anyopaque,
        value: webidl.JSValue,
        allocator: Allocator,
    ) anyerror![]const u8,

    /// Convert JSValue to integer using ECMAScript parseInt.
    ///
    /// # Spec Reference
    /// ECMAScript: parseInt(string, radix)
    /// https://tc39.es/ecma262/#sec-parseint-string-radix
    ///
    /// WHATWG Console: Format specifiers %d, %i
    /// https://console.spec.whatwg.org/#formatter
    ///
    /// # Returns
    /// Integer value (base 10).
    /// If value is a Symbol, return 0 (represents NaN in i32).
    toInteger: *const fn (ctx: *anyopaque, value: webidl.JSValue) anyerror!i32,

    /// Convert JSValue to float using ECMAScript parseFloat.
    ///
    /// # Spec Reference
    /// ECMAScript: parseFloat(string)
    /// https://tc39.es/ecma262/#sec-parsefloat-string
    ///
    /// WHATWG Console: Format specifier %f
    /// https://console.spec.whatwg.org/#formatter
    ///
    /// # Returns
    /// Floating point value.
    /// If value is a Symbol, return NaN.
    toFloat: *const fn (ctx: *anyopaque, value: webidl.JSValue) anyerror!f64,

    // ========================================================================
    // Object Introspection (Optional - for console.table, console.dir)
    // ========================================================================

    /// Get a property value from an object by key.
    ///
    /// # Spec Reference
    /// ECMAScript: Get(O, P)
    /// https://tc39.es/ecma262/#sec-get-o-p
    ///
    /// # Returns
    /// Property value if it exists, null otherwise.
    /// This is optional. If not implemented, return null.
    getProperty: *const fn (
        ctx: *anyopaque,
        object: webidl.JSValue,
        key: []const u8,
    ) ?webidl.JSValue,

    /// Get all enumerable property keys from an object.
    ///
    /// # Spec Reference
    /// ECMAScript: EnumerableOwnPropertyNames(O, kind)
    /// https://tc39.es/ecma262/#sec-enumerableownpropertynames
    ///
    /// # Returns
    /// Array of UTF-8 property key strings. Caller owns memory.
    /// Each string must be freed individually, then the array.
    /// This is optional. If not implemented, return empty array.
    getKeys: *const fn (
        ctx: *anyopaque,
        object: webidl.JSValue,
        allocator: Allocator,
    ) anyerror![][]const u8,

    /// Get the length of an array or array-like object.
    ///
    /// # Spec Reference
    /// ECMAScript: LengthOfArrayLike(obj)
    /// https://tc39.es/ecma262/#sec-lengthofarraylike
    ///
    /// # Returns
    /// Length as u32. Returns 0 if not array-like.
    getLength: *const fn (ctx: *anyopaque, array: webidl.JSValue) anyerror!u32,

    // ========================================================================
    // Stack Traces (Optional - for console.trace)
    // ========================================================================

    /// Capture the current JavaScript call stack.
    ///
    /// # Spec Reference
    /// WHATWG Console: console.trace()
    /// https://console.spec.whatwg.org/#trace
    ///
    /// # Returns
    /// Array of StackFrame structs. Caller owns memory.
    /// Frames are ordered from innermost (most recent) to outermost.
    /// This is optional. If not implemented, return empty array.
    captureStackTrace: *const fn (
        ctx: *anyopaque,
        allocator: Allocator,
    ) anyerror![]StackFrame,

    // ========================================================================
    // DOM Operations (Optional - for console.dirxml)
    // ========================================================================

    /// Check if a JSValue is a DOM Node.
    ///
    /// # Spec Reference
    /// WHATWG Console: console.dirxml()
    /// https://console.spec.whatwg.org/#dirxml
    ///
    /// DOM Standard: Node interface
    /// https://dom.spec.whatwg.org/#interface-node
    ///
    /// # Returns
    /// true if value is a DOM Node (Element, Document, Text, etc.), false otherwise.
    /// This is optional. If not in a DOM environment, return false.
    isDOMNode: *const fn (ctx: *anyopaque, value: webidl.JSValue) bool,

    /// Convert DOM Node to XML/HTML tree representation.
    ///
    /// # Spec Reference
    /// WHATWG Console: console.dirxml() - DOM tree representation
    /// https://console.spec.whatwg.org/#dirxml
    ///
    /// DOM Standard: Serializing (outerHTML, innerHTML)
    /// https://dom.spec.whatwg.org/#concept-serialize
    ///
    /// # Returns
    /// XML/HTML string representation of the DOM node. Caller owns memory (must free).
    /// For Element nodes: outerHTML representation
    /// For Text nodes: text content with appropriate escaping
    /// For Document nodes: full document serialization
    /// This is optional. If not implemented or fails, return empty string.
    toDOMString: *const fn (
        ctx: *anyopaque,
        node: webidl.JSValue,
        allocator: Allocator,
    ) anyerror![]const u8,
};

test "Group - init expanded" {
    const allocator = std.testing.allocator;
    // DOMString is infra.String ([]const u16), so we use infra.string.utf8ToUtf16
    const label = try infra.string.utf8ToUtf16(allocator, "Test Group");
    defer allocator.free(label);

    const group = Group.init(label);
    try std.testing.expect(group.label != null);
    try std.testing.expect(!group.collapsed);
}

test "Group - init collapsed" {
    const allocator = std.testing.allocator;
    // DOMString is infra.String ([]const u16), so we use infra.string.utf8ToUtf16
    const label = try infra.string.utf8ToUtf16(allocator, "Test Group");
    defer allocator.free(label);

    const group = Group.initCollapsed(label);
    try std.testing.expect(group.label != null);
    try std.testing.expect(group.collapsed);
}

test "Group - init without label" {
    const group = Group.init(null);
    try std.testing.expect(group.label == null);
    try std.testing.expect(!group.collapsed);
}

test "LogLevel - severity groupings" {
    try std.testing.expectEqual(LogLevel.Severity.log, LogLevel.log.getSeverity());
    try std.testing.expectEqual(LogLevel.Severity.log, LogLevel.debug.getSeverity());
    try std.testing.expectEqual(LogLevel.Severity.log, LogLevel.trace.getSeverity());
    try std.testing.expectEqual(LogLevel.Severity.log, LogLevel.time_log.getSeverity());

    try std.testing.expectEqual(LogLevel.Severity.info, LogLevel.info.getSeverity());
    try std.testing.expectEqual(LogLevel.Severity.info, LogLevel.count.getSeverity());
    try std.testing.expectEqual(LogLevel.Severity.info, LogLevel.time_end.getSeverity());

    try std.testing.expectEqual(LogLevel.Severity.warn, LogLevel.warn.getSeverity());
    try std.testing.expectEqual(LogLevel.Severity.warn, LogLevel.count_reset.getSeverity());

    try std.testing.expectEqual(LogLevel.Severity.@"error", LogLevel.error_level.getSeverity());
    try std.testing.expectEqual(LogLevel.Severity.@"error", LogLevel.assert_level.getSeverity());
}

test "CircularMessageBuffer - basic push and pop" {
    const allocator = std.testing.allocator;
    var buffer = try CircularMessageBuffer.init(allocator, 5);
    defer buffer.deinit();

    // Create a test JSValue (Phase 3: store args)
    const test_value = webidl.JSValue{ .string = "test" };
    const args = &[_]webidl.JSValue{test_value};

    const msg1 = try Message.init(.log, infra.Moment.now(), args, 0, allocator);
    buffer.push(msg1);

    try std.testing.expectEqual(@as(usize, 1), buffer.size());
    try std.testing.expect(!buffer.isEmpty());

    const popped = buffer.pop();
    try std.testing.expect(popped != null);
    try std.testing.expectEqual(@as(usize, 1), popped.?.args.len);

    var popped_mut = popped.?;
    popped_mut.deinit(allocator);
}

test "CircularMessageBuffer - circular overflow" {
    const allocator = std.testing.allocator;
    var buffer = try CircularMessageBuffer.init(allocator, 3);
    defer buffer.deinit();

    const test_value = webidl.JSValue{ .string = "test" };
    const args = &[_]webidl.JSValue{test_value};

    // Fill buffer
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    try std.testing.expect(buffer.isFull());

    // Overflow: should free oldest (Message 1) and add Message 4
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    try std.testing.expectEqual(@as(usize, 3), buffer.size());

    // Should now have 3 messages
    var msg1 = buffer.pop().?;
    msg1.deinit(allocator);

    var msg2 = buffer.pop().?;
    msg2.deinit(allocator);

    var msg3 = buffer.pop().?;
    msg3.deinit(allocator);
}

test "CircularMessageBuffer - get by index" {
    const allocator = std.testing.allocator;
    var buffer = try CircularMessageBuffer.init(allocator, 5);
    defer buffer.deinit();

    const test_value = webidl.JSValue{ .string = "test" };
    const args = &[_]webidl.JSValue{test_value};

    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));

    const msg0 = buffer.get(0);
    try std.testing.expect(msg0 != null);
    try std.testing.expectEqual(@as(usize, 1), msg0.?.args.len);

    const msg2 = buffer.get(2);
    try std.testing.expect(msg2 != null);
    try std.testing.expectEqual(@as(usize, 1), msg2.?.args.len);

    const out_of_bounds = buffer.get(10);
    try std.testing.expect(out_of_bounds == null);
}

test "CircularMessageBuffer - clear" {
    const allocator = std.testing.allocator;
    var buffer = try CircularMessageBuffer.init(allocator, 5);
    defer buffer.deinit();

    const test_value = webidl.JSValue{ .string = "test" };
    const args = &[_]webidl.JSValue{test_value};

    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));
    buffer.push(try Message.init(.log, infra.Moment.now(), args, 0, allocator));

    try std.testing.expectEqual(@as(usize, 3), buffer.size());

    buffer.clear();
    try std.testing.expectEqual(@as(usize, 0), buffer.size());
    try std.testing.expect(buffer.isEmpty());
}
