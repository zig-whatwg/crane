// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! WritableStreamDefaultController class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#ws-default-controller-class
//!
//! Controls a WritableStream's state and internal queue.

const std = @import("std");
const webidl = @import("webidl");

pub const common = @import("common");
pub const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
pub const eventLoop = @import("event_loop");
pub const AsyncPromise = @import("async_promise").AsyncPromise;
pub const WritableStream = @import("writable_stream").WritableStream;
pub const WritableStreamDefaultController = struct {
    // ========================================================================
    // WritableStreamDefaultController fields
    // ========================================================================
    allocator: std.mem.Allocator,
    /// [[abortAlgorithm]]: Promise-returning algorithm for abort
    abortAlgorithm: common.AbortAlgorithm,
    /// [[closeAlgorithm]]: Promise-returning algorithm for close
    closeAlgorithm: common.CloseAlgorithm,
    /// [[queue]]: Queue-with-sizes for internal chunk queue
    queue: QueueWithSizes,
    /// [[started]]: boolean - underlying sink has finished starting
    started: bool,
    /// [[strategyHWM]]: High water mark for backpressure
    strategyHwm: f64,
    /// [[strategySizeAlgorithm]]: Algorithm to calculate chunk size
    strategySizeAlgorithm: common.SizeAlgorithm,
    /// [[stream]]: The WritableStream instance controlled
    stream: ?*anyopaque,
    /// [[writeAlgorithm]]: Promise-returning algorithm for write
    writeAlgorithm: common.WriteAlgorithm,
    /// Event loop for async operations
    eventLoop: eventLoop.EventLoop,
    /// Optional transform controller for TransformStream integration
    /// When set, writes are routed through the transform controller instead of writeAlgorithm
    /// This enables TransformStream to intercept writes and transform them
    transformController: ?*anyopaque,

    pub fn init(
        allocator: std.mem.Allocator,
        abortAlgorithm: common.AbortAlgorithm,
        closeAlgorithm: common.CloseAlgorithm,
        writeAlgorithm: common.WriteAlgorithm,
        strategyHwm: f64,
        strategySizeAlgorithm: common.SizeAlgorithm,
        loop: eventLoop.EventLoop,
    ) WritableStreamDefaultController {
        return .{
            .allocator = allocator,
            .abortAlgorithm = abortAlgorithm,
            .closeAlgorithm = closeAlgorithm,
            .queue = QueueWithSizes.init(allocator),
            .started = false,
            .strategyHwm = strategyHwm,
            .strategySizeAlgorithm = strategySizeAlgorithm,
            .stream = null,
            .writeAlgorithm = writeAlgorithm,
            .eventLoop = loop,
            .transformController = null,
        };
    }
    pub fn deinit(self: *WritableStreamDefaultController) void {
        self.queue.deinit();
    }
    // ========================================================================
    // WritableStreamDefaultController methods
    // ========================================================================

    pub fn errorStream(self: *WritableStreamDefaultController, e: ?webidl.JSValue) void {
        const error_value = if (e) |err| common.JSValue.fromWebIDL(err) else common.JSValue.undefined_value();
        self.errorInternal(error_value);
    }
    /// WritableStreamDefaultControllerError(controller, error)
    /// 
    /// Spec: § 5.7.3 "Error the controller"
    fn errorInternal(self: *WritableStreamDefaultController, error_value: common.JSValue) void {
        // Spec step 1: Let stream be controller.[[stream]]
        const stream_ptr: *WritableStream = @ptrCast(@alignCast(self.stream.?));

        // Spec step 2: Assert: stream.[[state]] is "writable"
        std.debug.assert(stream_ptr.state == .writable);

        // Spec step 3: Perform ! WritableStreamDefaultControllerClearAlgorithms(controller)
        self.clearAlgorithms();

        // Spec step 4: Perform ! WritableStreamStartErroring(stream, error)
        stream_ptr.startErroring(error_value);
    }
    fn clearAlgorithms(self: *WritableStreamDefaultController) void {
        self.abortAlgorithm = common.defaultAbortAlgorithm();
        self.closeAlgorithm = common.defaultCloseAlgorithm();
        self.writeAlgorithm = common.defaultWriteAlgorithm();
        self.strategySizeAlgorithm = common.defaultSizeAlgorithm();
    }
    /// [[AbortSteps]](reason)
    /// 
    /// Spec: § 5.2.6 "Controller's abort steps"
    pub fn abortSteps(self: *WritableStreamDefaultController, reason: ?common.JSValue) common.Promise(void) {
        // Spec step 1: Let result be the result of performing this.[[abortAlgorithm]], passing reason
        const result = self.abortAlgorithm.call(reason);

        // Spec step 2: Perform ! WritableStreamDefaultControllerClearAlgorithms(this)
        self.clearAlgorithms();

        // Spec step 3: Return result
        return result;
    }
    /// [[ErrorSteps]]()
    /// 
    /// Spec: § 5.2.7 "Controller's error steps"
    pub fn errorSteps(self: *WritableStreamDefaultController) void {
        // Spec step 1: Perform ! ResetQueue(this)
        self.queue.resetQueue();
    }
    /// WritableStreamDefaultControllerClose(controller)
    /// 
    /// Spec: § 5.7.2 "Close the controller"
    pub fn closeInternal(self: *WritableStreamDefaultController) void {
        // Spec step 1: Perform ! EnqueueValueWithSize(controller, close sentinel, 0)
        self.queue.enqueueValueWithSize(common.JSValue.closeSentinel(), 0) catch {
            // EnqueueValueWithSize should not fail for close sentinel
            return;
        };

        // Spec step 2: Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)
        self.advanceQueueIfNeeded();
    }
    /// WritableStreamDefaultControllerErrorIfNeeded(controller, error)
    /// 
    /// Spec: § 5.7.4 "Error the controller if writable"
    pub fn errorIfNeeded(self: *WritableStreamDefaultController, error_value: common.JSValue) void {
        // Spec step 1: If controller.[[stream]].[[state]] is "writable", perform ! WritableStreamDefaultControllerError(controller, error)
        const stream_ptr: *WritableStream = @ptrCast(@alignCast(self.stream.?));
        if (stream_ptr.state == .writable) {
            self.errorInternal(error_value);
        }
    }
    /// WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)
    /// 
    /// Spec: § 5.7.1 "Process the next chunk in the queue if ready"
    fn advanceQueueIfNeeded(self: *WritableStreamDefaultController) void {
        // Simplified implementation - in full version, this would:
        // 1. Check if controller is not started or queue is empty
        // 2. Check if there's an in-flight write
        // 3. Dequeue next chunk and process it
        // For now, this is a no-op placeholder
        _ = self;
    }
    pub fn calculateDesiredSize(self: *const WritableStreamDefaultController) ?f64 {
        return self.strategyHwm - self.queue.queue_total_size;
    }
    /// Process a write (internal method for queue processing)
    /// 
    /// This is called by WritableStreamDefaultControllerAdvanceQueueIfNeeded
    /// to process the next chunk in the queue. If this controller is part of
    /// a TransformStream, it routes through the transform controller.
    pub fn processWrite(self: *WritableStreamDefaultController, chunk: common.JSValue) common.Promise(void) {
        // Check if this is part of a TransformStream
        // If so, route through the transform controller instead of write algorithm
        if (self.transformController) |transform_ctrl_ptr| {
            const TransformStreamDefaultController = @import("transform_stream_default_controller").TransformStreamDefaultController;
            const transform_ctrl: *TransformStreamDefaultController = @ptrCast(@alignCast(transform_ctrl_ptr));

            // Route through transform controller's performTransform
            return transform_ctrl.performTransform(chunk);
        }

        // Normal case: use the write algorithm
        return self.writeAlgorithm.call(chunk);
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "WritableStreamDefaultController",
        .kind = .interface,
        .exposed = &.{.global},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

