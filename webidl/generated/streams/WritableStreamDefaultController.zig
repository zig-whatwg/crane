// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortAlgorithm = @import("abort_algorithm").AbortAlgorithm;
const AbortController = @import("dom").AbortController;
const AbortSteps = @import("abort_steps").AbortSteps;
const Algorithm = @import("algorithm").Algorithm;
const Algorithms = @import("algorithms").Algorithms;
const Allocator = @import("std.mem").Allocator;
const Assert = @import("assert").Assert;
const AsyncPromise = @import("async_promise").AsyncPromise;
const Cast = @import("cast").Cast;
const Check = @import("check").Check;
const Close = @import("close").Close;
const CloseAlgorithm = @import("close_algorithm").CloseAlgorithm;
const Controller = @import("controller").Controller;
const Dequeue = @import("dequeue").Dequeue;
const DesiredSize = @import("desired_size").DesiredSize;
const EnqueueValueWithSize = @import("enqueue_value_with_size").EnqueueValueWithSize;
const ErrorSteps = @import("error_steps").ErrorSteps;
const Erroring = @import("erroring").Erroring;
const EventLoop = @import("event_loop").EventLoop;
const For = @import("for").For;
const Hwm = @import("hwm").Hwm;
const If = @import("if").If;
const Instance = @import("instance").Instance;
const Interface = @import("interface").Interface;
const Internal = @import("internal").Internal;
const JSValue = @import("j_s_value").JSValue;
const Let = @import("let").Let;
const Loop = @import("loop").Loop;
const Methods = @import("methods").Methods;
const Normal = @import("normal").Normal;
const Perform = @import("perform").Perform;
const Process = @import("process").Process;
const Promise = @import("promise").Promise;
const Queue = @import("queue").Queue;
const QueueIfNeeded = @import("queue_if_needed").QueueIfNeeded;
const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
const ResetQueue = @import("reset_queue").ResetQueue;
const Return = @import("return").Return;
const Route = @import("route").Route;
const Sentinel = @import("sentinel").Sentinel;
const Simplified = @import("simplified").Simplified;
const SizeAlgorithm = @import("size_algorithm").SizeAlgorithm;
const Spec = @import("spec").Spec;
const Steps = @import("steps").Steps;
const The = @import("the").The;
const This = @import("this").This;
const Transform = @import("transform").Transform;
const TransformStream = @import("transform_stream").TransformStream;
const TransformStreamDefaultController = @import("transform_stream_default_controller").TransformStreamDefaultController;
const ValueWithSize = @import("value_with_size").ValueWithSize;
const WebIDL = @import("web_i_d_l").WebIDL;
const WritableStream = @import("writable_stream").WritableStream;
const WritableStreamDefaultControllerAdvanceQueueIfNeeded = @import("writable_stream_default_controller_advance_queue_if_needed").WritableStreamDefaultControllerAdvanceQueueIfNeeded;
const WritableStreamDefaultControllerClearAlgorithms = @import("writable_stream_default_controller_clear_algorithms").WritableStreamDefaultControllerClearAlgorithms;
const WritableStreamDefaultControllerClose = @import("writable_stream_default_controller_close").WritableStreamDefaultControllerClose;
const WritableStreamDefaultControllerError = @import("writable_stream_default_controller_error").WritableStreamDefaultControllerError;
const WritableStreamStartErroring = @import("writable_stream_start_erroring").WritableStreamStartErroring;
const Write = @import("write").Write;
const WriteAlgorithm = @import("write_algorithm").WriteAlgorithm;
const anyopaque = @import("anyopaque").anyopaque;
const common = @import("common").common;
const common.AbortAlgorithm = @import("common._abort_algorithm").common.AbortAlgorithm;
const common.CloseAlgorithm = @import("common._close_algorithm").common.CloseAlgorithm;
const common.SizeAlgorithm = @import("common._size_algorithm").common.SizeAlgorithm;
const common.WriteAlgorithm = @import("common._write_algorithm").common.WriteAlgorithm;
const eventLoop = @import("event_loop").eventLoop;
const eventLoop.EventLoop = @import("event_loop._event_loop").eventLoop.EventLoop;
const std = @import("std");
const std.mem.Allocator = @import("std.mem._allocator").std.mem.Allocator;
const webidl = @import("webidl");


pub const WritableStreamDefaultController = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    abortController: AbortController,
    abortAlgorithm: common.AbortAlgorithm,
    closeAlgorithm: common.CloseAlgorithm,
    queue: QueueWithSizes,
    started: bool,
    strategyHwm: f64,
    strategySizeAlgorithm: common.SizeAlgorithm,
    stream: ?*anyopaque,
    writeAlgorithm: common.WriteAlgorithm,
    eventLoop: eventLoop.EventLoop,
    transformController: ?*anyopaque,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        abortAlgorithm: common.AbortAlgorithm,
        closeAlgorithm: common.CloseAlgorithm,
        writeAlgorithm: common.WriteAlgorithm,
        strategyHwm: f64,
        strategySizeAlgorithm: common.SizeAlgorithm,
        loop: eventLoop.EventLoop,
    ) !WritableStreamDefaultController {

        return .{
            .allocator = allocator,
            .abortController = try AbortController.init(allocator),
            .abortAlgorithm = abortAlgorithm,
            .closeAlgorithm = closeAlgorithm,
            .queue = QueueWithSizes.init(allocator),
            .started = false,
            .strategyHwm = strategyHwm,
            .strategySizeAlgorithm = strategySizeAlgorithm,
            .stream = null,
            .writeAlgorithm = writeAlgorithm,
            .eventLoop = loop,
            .transformController = null,
        };
    
    }

    pub fn deinit(self: *WritableStreamDefaultController) void {
        self.abortController.deinit();
        self.queue.deinit();
    }

    // ============================================================================
    // WebIDL Interface: Instance Methods
    // ============================================================================

    /// undefined error(optional any e)
    /// Spec: § 5.4.3 "The error(e) method steps are:"
    pub fn call_error(self: *WritableStreamDefaultController, e: ?webidl.JSValue) void {
        const error_value = if (e) |err| common.JSValue.fromWebIDL(err) else common.JSValue.undefined_value();
        self.errorInternal(error_value);
    }

    // ============================================================================
    // Internal Algorithms
    // ============================================================================

    /// WritableStreamDefaultControllerError(controller, error)
    ///
    /// Spec: § 5.7.3 "Error the controller"
    fn errorInternal(self: *WritableStreamDefaultController, error_value: common.JSValue) void {
        // Spec step 1: Let stream be controller.[[stream]]
        const stream_ptr: *WritableStream = @ptrCast(@alignCast(self.stream.?));

        // Spec step 2: Assert: stream.[[state]] is "writable"
        std.debug.assert(stream_ptr.state == .writable);

        // Spec step 3: Perform ! WritableStreamDefaultControllerClearAlgorithms(controller)
        self.clearAlgorithms();

        // Spec step 4: Perform ! WritableStreamStartErroring(stream, error)
        stream_ptr.startErroring(error_value);
    }

    fn clearAlgorithms(self: *WritableStreamDefaultController) void {
        self.abortAlgorithm = common.defaultAbortAlgorithm();
        self.closeAlgorithm = common.defaultCloseAlgorithm();
        self.writeAlgorithm = common.defaultWriteAlgorithm();
        self.strategySizeAlgorithm = common.defaultSizeAlgorithm();
    }

    /// [[AbortSteps]](reason)
    ///
    /// Spec: § 5.2.6 "Controller's abort steps"
    pub fn abortSteps(self: *WritableStreamDefaultController, reason: ?common.JSValue) common.Promise(void) {
        // Spec step 1: Let result be the result of performing this.[[abortAlgorithm]], passing reason
        const result = self.abortAlgorithm.call(reason);

        // Spec step 2: Perform ! WritableStreamDefaultControllerClearAlgorithms(this)
        self.clearAlgorithms();

        // Spec step 3: Return result
        return result;
    }

    /// [[ErrorSteps]]()
    ///
    /// Spec: § 5.2.7 "Controller's error steps"
    pub fn errorSteps(self: *WritableStreamDefaultController) void {
        // Spec step 1: Perform ! ResetQueue(this)
        self.queue.resetQueue();
    }

    /// WritableStreamDefaultControllerClose(controller)
    ///
    /// Spec: § 5.7.2 "Close the controller"
    pub fn closeInternal(self: *WritableStreamDefaultController) void {

        // Spec step 1: Perform ! EnqueueValueWithSize(controller, close sentinel, 0)
        self.queue.enqueueValueWithSize(common.JSValue.closeSentinel(), 0) catch {
            // EnqueueValueWithSize should not fail for close sentinel
            return;
        };

        // Spec step 2: Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)
        self.advanceQueueIfNeeded();
    
    }

    pub fn errorIfNeeded(self: *WritableStreamDefaultController, error_value: common.JSValue) void {

        // Spec step 1: If controller.[[stream]].[[state]] is "writable", perform ! WritableStreamDefaultControllerError(controller, error)
        const stream_ptr: *WritableStream = @ptrCast(@alignCast(self.stream.?));
        if (stream_ptr.state == .writable) {
            self.errorInternal(error_value);
        }
    
    }

    fn advanceQueueIfNeeded(self: *WritableStreamDefaultController) void {
        // Simplified implementation - in full version, this would:
        // 1. Check if controller is not started or queue is empty
        // 2. Check if there's an in-flight write
        // 3. Dequeue next chunk and process it
        // For now, this is a no-op placeholder
        _ = self;
    }

    pub fn calculateDesiredSize(self: *const WritableStreamDefaultController) ?f64 {
        return self.strategyHwm - self.queue.queue_total_size;
    }

    /// Process a write (internal method for queue processing)
    ///
    /// This is called by WritableStreamDefaultControllerAdvanceQueueIfNeeded
    /// to process the next chunk in the queue. If this controller is part of
    /// a TransformStream, it routes through the transform controller.
    pub fn processWrite(self: *WritableStreamDefaultController, chunk: common.JSValue) common.Promise(void) {

        // Check if this is part of a TransformStream
        // If so, route through the transform controller instead of write algorithm
        if (self.transformController) |transform_ctrl_ptr| {
            const TransformStreamDefaultController = @import("transform_stream_default_controller").TransformStreamDefaultController;
            const transform_ctrl: *TransformStreamDefaultController = @ptrCast(@alignCast(transform_ctrl_ptr));

            // Route through transform controller's performTransform
            return transform_ctrl.performTransform(chunk);
        }

        // Normal case: use the write algorithm
        return self.writeAlgorithm.call(chunk);
    
    }

};


