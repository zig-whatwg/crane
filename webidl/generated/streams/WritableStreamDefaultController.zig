// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortController = @import("dom").AbortController;
const Algorithm = @import("algorithm").Algorithm;
const Allocator = @import("std.mem").Allocator;
const AsyncPromise = @import("async_promise").AsyncPromise;
const Controller = @import("controller").Controller;
const JSValue = @import("j_s_value").JSValue;
const Loop = @import("loop").Loop;
const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
const WritableStream = @import("writable_stream").WritableStream;
const common = @import("common").common;
const eventLoop = @import("event_loop").eventLoop;
const std = @import("std");
const webidl = @import("webidl");


pub const WritableStreamDefaultController = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    abortController: AbortController,
    abortAlgorithm: common.AbortAlgorithm,
    closeAlgorithm: common.CloseAlgorithm,
    queue: QueueWithSizes,
    started: bool,
    strategyHwm: f64,
    strategySizeAlgorithm: common.SizeAlgorithm,
    stream: ?*anyopaque,
    writeAlgorithm: common.WriteAlgorithm,
    eventLoop: eventLoop.EventLoop,
    transformController: ?*anyopaque,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        abortAlgorithm: common.AbortAlgorithm,
        closeAlgorithm: common.CloseAlgorithm,
        writeAlgorithm: common.WriteAlgorithm,
        strategyHwm: f64,
        strategySizeAlgorithm: common.SizeAlgorithm,
        loop: eventLoop.EventLoop,
    ) !WritableStreamDefaultController {

        return .{
            .allocator = allocator,
            .abortController = try AbortController.init(allocator),
            .abortAlgorithm = abortAlgorithm,
            .closeAlgorithm = closeAlgorithm,
            .queue = QueueWithSizes.init(allocator),
            .started = false,
            .strategyHwm = strategyHwm,
            .strategySizeAlgorithm = strategySizeAlgorithm,
            .stream = null,
            .writeAlgorithm = writeAlgorithm,
            .eventLoop = loop,
            .transformController = null,
        };
    
    }

    pub fn deinit(self: *WritableStreamDefaultController) void {

        self.abortController.deinit();
        self.queue.deinit();
    
    }

    pub fn call_error(self: *WritableStreamDefaultController, e: ?webidl.JSValue) void {

        const error_value = if (e) |err| common.JSValue.fromWebIDL(err) else common.JSValue.undefined_value();
        self.errorInternal(error_value);
    
    }

    fn errorInternal(self: *WritableStreamDefaultController, error_value: common.JSValue) void {

        // Spec step 1: Let stream be controller.[[stream]]
        const stream_ptr: *WritableStream = @ptrCast(@alignCast(self.stream.?));

        // Spec step 2: Assert: stream.[[state]] is "writable"
        std.debug.assert(stream_ptr.state == .writable);

        // Spec step 3: Perform ! WritableStreamDefaultControllerClearAlgorithms(controller)
        self.clearAlgorithms();

        // Spec step 4: Perform ! WritableStreamStartErroring(stream, error)
        stream_ptr.startErroring(error_value);
    
    }

    fn clearAlgorithms(self: *WritableStreamDefaultController) void {

        self.abortAlgorithm = common.defaultAbortAlgorithm();
        self.closeAlgorithm = common.defaultCloseAlgorithm();
        self.writeAlgorithm = common.defaultWriteAlgorithm();
        self.strategySizeAlgorithm = common.defaultSizeAlgorithm();
    
    }

    pub fn abortSteps(self: *WritableStreamDefaultController, reason: ?common.JSValue) common.Promise(void) {

        // Spec step 1: Let result be the result of performing this.[[abortAlgorithm]], passing reason
        const result = self.abortAlgorithm.call(reason);

        // Spec step 2: Perform ! WritableStreamDefaultControllerClearAlgorithms(this)
        self.clearAlgorithms();

        // Spec step 3: Return result
        return result;
    
    }

    pub fn errorSteps(self: *WritableStreamDefaultController) void {

        // Spec step 1: Perform ! ResetQueue(this)
        self.queue.resetQueue();
    
    }

    pub fn closeInternal(self: *WritableStreamDefaultController) void {

        // Spec step 1: Perform ! EnqueueValueWithSize(controller, close sentinel, 0)
        self.queue.enqueueValueWithSize(common.JSValue.closeSentinel(), 0) catch {
            // EnqueueValueWithSize should not fail for close sentinel
            return;
        };

        // Spec step 2: Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)
        self.advanceQueueIfNeeded();
    
    }

    pub fn errorIfNeeded(self: *WritableStreamDefaultController, error_value: common.JSValue) void {

        // Spec step 1: If controller.[[stream]].[[state]] is "writable", perform ! WritableStreamDefaultControllerError(controller, error)
        const stream_ptr: *WritableStream = @ptrCast(@alignCast(self.stream.?));
        if (stream_ptr.state == .writable) {
            self.errorInternal(error_value);
        }
    
    }

    fn advanceQueueIfNeeded(self: *WritableStreamDefaultController) void {

        // Simplified implementation - in full version, this would:
        // 1. Check if controller is not started or queue is empty
        // 2. Check if there's an in-flight write
        // 3. Dequeue next chunk and process it
        // For now, this is a no-op placeholder
        _ = self;
    
    }

    pub fn calculateDesiredSize(self: *const WritableStreamDefaultController) ?f64 {

        return self.strategyHwm - self.queue.queue_total_size;
    
    }

    pub fn processWrite(self: *WritableStreamDefaultController, chunk: common.JSValue) common.Promise(void) {

        // Check if this is part of a TransformStream
        // If so, route through the transform controller instead of write algorithm
        if (self.transformController) |transform_ctrl_ptr| {
            const TransformStreamDefaultController = @import("transform_stream_default_controller").TransformStreamDefaultController;
            const transform_ctrl: *TransformStreamDefaultController = @ptrCast(@alignCast(transform_ctrl_ptr));

            // Route through transform controller's performTransform
            return transform_ctrl.performTransform(chunk);
        }

        // Normal case: use the write algorithm
        return self.writeAlgorithm.call(chunk);
    
    }

};


