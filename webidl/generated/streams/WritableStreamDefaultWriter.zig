// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const AsyncPromise = @import("async_promise").AsyncPromise;
const Attr = @import("attr").Attr;
const Event = @import("event").Event;
const WritableStream = @import("writable_stream").WritableStream;
const common = @import("common").common;
const eventLoop = @import("event_loop").eventLoop;
const std = @import("std");
const webidl = @import("webidl");

pub const WritableStreamDefaultWriter = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    closedPromise: *AsyncPromise(void),
    readyPromise: ?*AsyncPromise(void),
    stream: ?*WritableStream,
    eventLoop: eventLoop.EventLoop,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        stream: *WritableStream,
        loop: eventLoop.EventLoop,
    ) !WritableStreamDefaultWriter {

        const closedPromise = try AsyncPromise(void).init(allocator, loop);
        const readyPromise = try AsyncPromise(void).init(allocator, loop);

        if (!stream.backpressure) {
            readyPromise.fulfill({});
        }

        return .{
            .allocator = allocator,
            .closedPromise = closedPromise,
            .readyPromise = readyPromise,
            .stream = stream,
            .eventLoop = loop,
        };
    
    }

    pub fn deinit(_: *WritableStreamDefaultWriter) void {}

    // ============================================================================
    // WebIDL Interface: Readonly Attributes
    // ============================================================================

    /// readonly attribute Promise<undefined> closed
    /// Spec: https://streams.spec.whatwg.org/#default-writer-closed
    pub fn get_closed(self: *const WritableStreamDefaultWriter) webidl.Promise(void) {

        if (self.closedPromise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else if (self.closedPromise.isRejected()) {
            const err_msg = self.closedPromise.state.rejected.toString();
            return webidl.Promise(void).rejected(err_msg);
        } else {
            return webidl.Promise(void).pending();
        }
    
    }

    pub fn get_desiredSize(self: *const WritableStreamDefaultWriter) ?f64 {

        if (self.stream == null) {
            return null;
        }
        return self.getDesiredSizeInternal();
    
    }

    pub fn get_ready(self: *const WritableStreamDefaultWriter) webidl.Promise(void) {

        if (self.readyPromise) |promise| {
            if (promise.isFulfilled()) {
                return webidl.Promise(void).fulfilled({});
            } else if (promise.isRejected()) {
                const err_msg = promise.state.rejected.toString();
                return webidl.Promise(void).rejected(err_msg);
            } else {
                return webidl.Promise(void).pending();
            }
        }
        return webidl.Promise(void).fulfilled({});
    
    }

    pub fn call_abort(self: *WritableStreamDefaultWriter, reason: ?webidl.JSValue) !*AsyncPromise(void) {

        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Writer released"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        const reason_value = if (reason) |r| common.JSValue.fromWebIDL(r) else null;
        return self.abortInternal(reason_value);
    
    }

    pub fn call_close(self: *WritableStreamDefaultWriter) !*AsyncPromise(void) {

        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Writer released"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        return self.closeInternal();
    
    }

    pub fn call_releaseLock(self: *WritableStreamDefaultWriter) void {

        if (self.stream == null) {
            return;
        }
        self.releaseInternal();
    
    }

    pub fn call_write(self: *WritableStreamDefaultWriter, chunk: ?webidl.JSValue) !*AsyncPromise(void) {

        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Writer released"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        const chunkValue = if (chunk) |c| c else webidl.JSValue{ .undefined = {} };
        return self.writeInternal(common.JSValue.fromWebIDL(chunkValue));
    
    }

    fn getDesiredSizeInternal(self: *const WritableStreamDefaultWriter) ?f64 {
        _ = self;
        return 1.0; // Placeholder
    }

    fn abortInternal(self: *WritableStreamDefaultWriter, reason: ?common.JSValue) !*AsyncPromise(void) {

        _ = reason;
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        promise.fulfill({});
        return promise;
    
    }

    fn closeInternal(self: *WritableStreamDefaultWriter) !*AsyncPromise(void) {

        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        promise.fulfill({});
        return promise;
    
    }

    pub fn writeInternal(self: *WritableStreamDefaultWriter, chunk: common.JSValue) !*AsyncPromise(void) {

        _ = chunk;
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        promise.fulfill({});
        return promise;
    
    }

    fn releaseInternal(self: *WritableStreamDefaultWriter) void {

        if (self.stream) |stream| {
            stream.writer = .none;
            self.stream = null;
        }
    
    }

};


