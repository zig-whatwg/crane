// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! WritableStreamDefaultWriter class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#default-writer-class
//!
//! Allows writing chunks to a WritableStream.

const std = @import("std");
const webidl = @import("webidl");

pub const common = @import("common");
pub const eventLoop = @import("event_loop");
pub const AsyncPromise = @import("async_promise").AsyncPromise;

pub const WritableStream = @import("writable_stream").WritableStream;
pub const WritableStreamDefaultWriter = struct {
    // ========================================================================
    // WritableStreamDefaultWriter fields
    // ========================================================================
    allocator: std.mem.Allocator,
    /// [[closedPromise]]: Promise that fulfills when stream closes
    closedPromise: *AsyncPromise(void),
    /// [[readyPromise]]: Promise that fulfills when stream is ready for writes
    readyPromise: ?*AsyncPromise(void),
    /// [[stream]]: The WritableStream being written to (or undefined if released)
    stream: ?*WritableStream,
    /// Event loop for async operations
    eventLoop: eventLoop.EventLoop,

    pub fn init(
        allocator: std.mem.Allocator,
        stream: *WritableStream,
        loop: eventLoop.EventLoop,
    ) !WritableStreamDefaultWriter {
        const closedPromise = try AsyncPromise(void).init(allocator, loop);
        const readyPromise = try AsyncPromise(void).init(allocator, loop);

        if (!stream.backpressure) {
            readyPromise.fulfill({});
        }

        return .{
            .allocator = allocator,
            .closedPromise = closedPromise,
            .readyPromise = readyPromise,
            .stream = stream,
            .eventLoop = loop,
        };
    }
    pub fn deinit(_: *WritableStreamDefaultWriter) void {}
    // ========================================================================
    // WritableStreamDefaultWriter methods
    // ========================================================================

    /// readonly attribute Promise<undefined> closed
    /// Spec: https://streams.spec.whatwg.org/#default-writer-closed
    pub fn get_closed(self: *const WritableStreamDefaultWriter) webidl.Promise(void) {
        if (self.closedPromise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else if (self.closedPromise.isRejected()) {
            const err_str = switch (self.closedPromise.state.rejected) {
                .string => |s| s,
                else => "Unknown error",
            };
            return webidl.Promise(void).rejected(err_str);
        } else {
            return webidl.Promise(void).pending();
        }
    }
    /// readonly attribute unrestricted double? desiredSize
    /// Spec: https://streams.spec.whatwg.org/#default-writer-desired-size
    pub fn get_desiredSize(self: *const WritableStreamDefaultWriter) ?f64 {
        if (self.stream == null) {
            return null;
        }
        return self.getDesiredSizeInternal();
    }
    /// readonly attribute Promise<undefined> ready
    /// Spec: https://streams.spec.whatwg.org/#default-writer-ready
    pub fn get_ready(self: *const WritableStreamDefaultWriter) webidl.Promise(void) {
        if (self.readyPromise) |promise| {
            if (promise.isFulfilled()) {
                return webidl.Promise(void).fulfilled({});
            } else if (promise.isRejected()) {
                const err_str = switch (promise.state.rejected) {
                    .string => |s| s,
                    else => "Unknown error",
                };
                return webidl.Promise(void).rejected(err_str);
            } else {
                return webidl.Promise(void).pending();
            }
        }
        return webidl.Promise(void).fulfilled({});
    }
    /// Promise<undefined> abort(optional any reason)
    /// Spec: https://streams.spec.whatwg.org/#default-writer-abort
    pub fn call_abort(self: *WritableStreamDefaultWriter, reason: ?webidl.JSValue) !*AsyncPromise(void) {
        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            promise.reject(common.JSValue{ .string = "Writer released" });
            return promise;
        }

        const reason_value = if (reason) |r| common.JSValue.fromWebIDL(r) else null;
        return self.abortInternal(reason_value);
    }
    /// Promise<undefined> close()
    /// Spec: https://streams.spec.whatwg.org/#default-writer-close
    pub fn call_close(self: *WritableStreamDefaultWriter) !*AsyncPromise(void) {
        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            promise.reject(common.JSValue{ .string = "Writer released" });
            return promise;
        }

        return self.closeInternal();
    }
    /// undefined releaseLock()
    /// Spec: https://streams.spec.whatwg.org/#default-writer-release-lock
    pub fn call_releaseLock(self: *WritableStreamDefaultWriter) void {
        if (self.stream == null) {
            return;
        }
        self.releaseInternal();
    }
    /// Promise<undefined> write(optional any chunk)
    /// Spec: https://streams.spec.whatwg.org/#default-writer-write
    pub fn call_write(self: *WritableStreamDefaultWriter, chunk: ?webidl.JSValue) !*AsyncPromise(void) {
        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            promise.reject(common.JSValue{ .string = "Writer released" });
            return promise;
        }

        const chunkValue = if (chunk) |c| c else webidl.JSValue{ .undefined = {} };
        return self.writeInternal(common.JSValue.fromWebIDL(chunkValue));
    }
    fn getDesiredSizeInternal(self: *const WritableStreamDefaultWriter) ?f64 {
        _ = self;
        return 1.0; // Placeholder
    }
    fn abortInternal(self: *WritableStreamDefaultWriter, reason: ?common.JSValue) !*AsyncPromise(void) {
        _ = reason;
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        promise.fulfill({});
        return promise;
    }
    fn closeInternal(self: *WritableStreamDefaultWriter) !*AsyncPromise(void) {
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        promise.fulfill({});
        return promise;
    }
    pub fn writeInternal(self: *WritableStreamDefaultWriter, chunk: common.JSValue) !*AsyncPromise(void) {
        _ = chunk;
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        promise.fulfill({});
        return promise;
    }
    fn releaseInternal(self: *WritableStreamDefaultWriter) void {
        if (self.stream) |stream| {
            stream.writer = .none;
            self.stream = null;
        }
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "WritableStreamDefaultWriter",
        .kind = .interface,
        .exposed = &.{.global},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

