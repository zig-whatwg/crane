// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocate = @import("allocate").Allocate;
const Allocator = @import("std.mem").Allocator;
const Already = @import("already").Already;
const ArrayBufferView = @import("array_buffer_view").ArrayBufferView;
const Assert = @import("assert").Assert;
const Assertion = @import("assertion").Assertion;
const AsyncPromise = @import("async_promise").AsyncPromise;
const AsyncPromise(void) = @import("async_promise(void)").AsyncPromise(void);
const BYOB = @import("b_y_o_b").BYOB;
const Buffer = @import("buffer").Buffer;
const ByteLength = @import("byte_length").ByteLength;
const Call = @import("call").Call;
const Cancel = @import("cancel").Cancel;
const Cast = @import("cast").Cast;
const Create = @import("create").Create;
const Delegate = @import("delegate").Delegate;
const Detached = @import("detached").Detached;
const DictionaryParsing = @import("dict_parsing");
const EventLoop = @import("event_loop").EventLoop;
const Exception = @import("exception").Exception;
const Failed = @import("failed").Failed;
const Fulfill = @import("fulfill").Fulfill;
const Fulfilled = @import("fulfilled").Fulfilled;
const Generic = @import("generic").Generic;
const Get = @import("get").Get;
const If = @import("if").If;
const Internal = @import("internal").Internal;
const Into = @import("into").Into;
const IntoRequest = @import("into_request").IntoRequest;
const IntoRequests = @import("into_requests").IntoRequests;
const JSValue = @import("j_s_value").JSValue;
const Length = @import("length").Length;
const Let = @import("let").Let;
const Loop = @import("loop").Loop;
const Not = @import("not").Not;
const Note = @import("note").Note;
const Otherwise = @import("otherwise").Otherwise;
const Parse = @import("parse").Parse;
const Perform = @import("perform").Perform;
const Promise = @import("promise").Promise;
const PromiseContext = @import("promise_context").PromiseContext;
const PromiseIsHandled = @import("promise_is_handled").PromiseIsHandled;
const Ptr = @import("ptr").Ptr;
const Pull = @import("pull").Pull;
const Read = @import("read").Read;
const ReadIntoRequest = @import("read_into_request").ReadIntoRequest;
const ReadIntoRequestModule = @import("read_into_request").ReadIntoRequestModule;
const ReadResult = @import("read_result").ReadResult;
const ReadableByteStreamController = @import("readable_byte_stream_controller").ReadableByteStreamController;
const ReadableStream = @import("readable_stream").ReadableStream;
const ReadableStreamBYOBReaderRead = @import("readable_stream_b_y_o_b_reader_read").ReadableStreamBYOBReaderRead;
const ReadableStreamBYOBReaderReadOptions = @import("readable_stream_b_y_o_b_reader_read_options").ReadableStreamBYOBReaderReadOptions;
const ReadableStreamCancel = @import("readable_stream_cancel").ReadableStreamCancel;
const ReadableStreamGenericReader = @import("readable_stream_generic_reader").ReadableStreamGenericReader;
const ReadableStreamReaderGenericCancel = @import("readable_stream_reader_generic_cancel").ReadableStreamReaderGenericCancel;
const ReadableStreamReaderGenericRelease = @import("readable_stream_reader_generic_release").ReadableStreamReaderGenericRelease;
const Reader = @import("reader").Reader;
const Reject = @import("reject").Reject;
const Rejected = @import("rejected").Rejected;
const Release = @import("release").Release;
const ReleaseSteps = @import("release_steps").ReleaseSteps;
const Return = @import("return").Return;
const Set = @import("set").Set;
const Spec = @import("spec").Spec;
const Step = @import("step").Step;
const Steps = @import("steps").Steps;
const Stream = @import("stream").Stream;
const The = @import("the").The;
const This = @import("this").This;
const TypeError = @import("type_error").TypeError;
const Unknown = @import("unknown").Unknown;
const Value = @import("value").Value;
const View = @import("view").View;
const ViewedArrayBuffer = @import("viewed_array_buffer").ViewedArrayBuffer;
const We = @import("we").We;
const WebIDL = @import("web_i_d_l").WebIDL;
const common = @import("common").common;
const eventLoop = @import("event_loop").eventLoop;
const eventLoop.EventLoop = @import("event_loop._event_loop").eventLoop.EventLoop;
const std = @import("std");
const std.mem.Allocator = @import("std.mem._allocator").std.mem.Allocator;
const webidl = @import("webidl");


pub const ReadableStreamBYOBReader = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    closedPromise: *AsyncPromise(void),
    stream: ?*ReadableStream,
    eventLoop: eventLoop.EventLoop,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        stream: *ReadableStream,
        loop: eventLoop.EventLoop,
    ) !ReadableStreamBYOBReader {

        const closedPromise = try AsyncPromise(void).init(allocator, loop);

        return .{
            .allocator = allocator,
            .closedPromise = closedPromise,
            .stream = stream,
            .eventLoop = loop,
            .readIntoRequests = std.ArrayList(*AsyncPromise(common.ReadResult)){},
        };
    
    }

    pub fn deinit(self: *ReadableStreamBYOBReader) void {
        self.readIntoRequests.deinit(self.allocator);
    }

    /// Read data into the provided view
    ///
    /// Spec: ยง 4.5.3 "The read(view, options) method steps are:"
    pub fn call_read(
        self: *ReadableStreamBYOBReader,
        view: webidl.ArrayBufferView,
        options: ?webidl.JSValue,
    ) !*AsyncPromise(common.ReadResult) {

        const allocator = self.allocator;
        const loop = self.eventLoop;

        // Step 1: If view.[[ByteLength]] is 0, reject with TypeError
        if (view.getByteLength() == 0) {
            const promise = try AsyncPromise(common.ReadResult).init(allocator, loop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try allocator.dupe(u8, "View byte length is 0"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        // Step 2: If buffer byte length is 0, reject with TypeError
        const buffer = view.getViewedArrayBuffer();
        if (buffer.byteLength() == 0) {
            const promise = try AsyncPromise(common.ReadResult).init(allocator, loop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try allocator.dupe(u8, "Buffer byte length is 0"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        // Step 3: If buffer is detached, reject with TypeError
        if (view.isDetached()) {
            const promise = try AsyncPromise(common.ReadResult).init(allocator, loop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try allocator.dupe(u8, "Buffer is detached"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        // Step 4: If stream is undefined, reject with TypeError
        if (self.stream == null) {
            const promise = try AsyncPromise(common.ReadResult).init(allocator, loop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try allocator.dupe(u8, "Reader released"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        // Step 5: Parse options (default min = 1)
        const min: u64 = if (options) |opt| blk: {
            const parsed = DictionaryParsing.parseReadableStreamBYOBReaderReadOptions(allocator, opt) catch {
                const promise = try AsyncPromise(common.ReadResult).init(allocator, loop);
                const exception = webidl.errors.Exception{
                    .simple = .{
                        .type = .TypeError,
                        .message = try allocator.dupe(u8, "Failed to parse options"),
                    },
                };
                promise.reject(exception);
                return promise;
            };
            break :blk parsed.min;
        } else 1;

        // Step 6: Return ReadableStreamBYOBReaderRead(this, view, min)
        return try self.readInternal(view, min);
    
    }

    fn readInternal(
        self: *ReadableStreamBYOBReader,
        view: webidl.ArrayBufferView,
        min: u64,
    ) !*AsyncPromise(common.ReadResult) {

        const allocator = self.allocator;
        const loop = self.eventLoop;
        const promise = try AsyncPromise(common.ReadResult).init(allocator, loop);

        // Step 1: Let stream be reader.[[stream]]
        const stream_ptr = self.stream orelse {
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try allocator.dupe(u8, "Reader has no stream"),
                },
            };
            promise.reject(exception);
            return promise;
        };

        // Cast to actual ReadableStream type
        const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

        // Step 3: Set stream.[[disturbed]] to true
        stream.disturbed = true;

        // Step 4: If stream is errored, reject promise
        if (stream.state == .errored) {
            const storedError = stream.storedError orelse common.JSValue{ .string = "Stream errored" };
            const exception = try storedError.toException(self.allocator);
            promise.reject(exception);
            return promise;
        }

        // Step 5: Call controller.pullInto()
        // Create ReadIntoRequest that will fulfill our promise
        const PromiseContext = struct {
            promisePtr: *AsyncPromise(common.ReadResult),
            allocator: std.mem.Allocator,

            fn chunkSteps(ctx: ?*anyopaque, chunk: ReadIntoRequestModule.ArrayBufferView) void {
                const context: *@This() = @ptrCast(@alignCast(ctx.?));
                // Fulfill promise with the filled view
                context.promisePtr.fulfill(.{
                    .value = common.JSValue{ .bytes = chunk.data },
                    .done = false,
                });
            }

            fn closeSteps(ctx: ?*anyopaque) void {
                const context: *@This() = @ptrCast(@alignCast(ctx.?));
                // Fulfill promise with done=true
                context.promisePtr.fulfill(.{
                    .value = common.JSValue{ .undefined = {} },
                    .done = true,
                });
            }

            fn errorSteps(ctx: ?*anyopaque, e: ReadIntoRequestModule.Value) void {
                const context: *@This() = @ptrCast(@alignCast(ctx.?));
                // Reject promise with error
                const err_value = switch (e) {
                    .string => |s| common.JSValue{ .string = s },
                    else => common.JSValue{ .string = "Unknown error" },
                };
                const exception = err_value.toException(context.allocator) catch return;
                context.promisePtr.reject(exception);
            }
        };

        // Allocate context for the callback closures
        const ctx = try allocator.create(PromiseContext);
        ctx.* = .{ .promisePtr = promise, .allocator = allocator };

        const readIntoRequest = ReadIntoRequest.init(
            allocator,
            PromiseContext.chunkSteps,
            PromiseContext.closeSteps,
            PromiseContext.errorSteps,
            ctx,
        );

        // Get the byte stream controller and call pullInto
        // Note: stream.controller should be *ReadableByteStreamController for BYOB
        const controller: *ReadableByteStreamController = @ptrCast(@alignCast(stream.controller));

        controller.pullInto(view, min, readIntoRequest) catch {
            allocator.destroy(ctx);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try allocator.dupe(u8, "Pull into failed"),
                },
            };
            promise.reject(exception);
            return promise;
        };

        return promise;
    
    }

    pub fn call_releaseLock(self: *ReadableStreamBYOBReader) void {

        if (self.stream == null) {
            return;
        }
        // Delegate to mixin's generic release
        self.genericRelease();
    
    }

    pub fn get_closed(self: *const ReadableStreamGenericReader) webidl.Promise(void) {

        if (self.closedPromise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else if (self.closedPromise.isRejected()) {
            const err_msg = self.closedPromise.state.rejected.toString();
            return webidl.Promise(void).rejected(err_msg);
        } else {
            return webidl.Promise(void).pending();
        }
    
    }

    pub fn call_cancel(self: *ReadableStreamGenericReader, reason: ?webidl.JSValue) !*AsyncPromise(void) {

        // Step 1: If this.[[stream]] is undefined, return a promise rejected with a TypeError exception.
        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Reader released"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        const reason_value = if (reason) |r| common.JSValue.fromWebIDL(r) else null;

        // Step 2: Return ! ReadableStreamReaderGenericCancel(this, reason).
        return self.genericCancel(reason_value);
    
    }

    fn genericCancel(self: *ReadableStreamGenericReader, reason: ?common.JSValue) !*AsyncPromise(void) {
        // Step 1: Let stream be reader.[[stream]].
        const stream = self.stream.?;

        // Step 2: Assert: stream is not undefined.
        // (Assertion is implicit - .? will panic if stream is null)

        // Step 3: Return ! ReadableStreamCancel(stream, reason).
        return stream.cancelInternal(reason);
    }

    /// ReadableStreamReaderGenericRelease(reader)
    ///
    /// Spec: ยง 4.2.6 "Generic release implementation shared by all reader types"
    pub fn genericRelease(self: *ReadableStreamGenericReader) void {

        // Step 1: Let stream be reader.[[stream]].
        const stream = self.stream.?;

        // Step 2: Assert: stream.[[reader]] is reader.
        // (We can't directly assert this due to type differences, but logically true)

        // Step 3: If stream.[[state]] is "readable", reject reader.[[closedPromise]] with a TypeError exception.
        if (stream.state == .readable) {
            self.closedPromise.reject(webidl.errors.Exception.typeError(self.allocator, "Reader released before stream closed") catch return);
        }

        // Step 4: Otherwise, set reader.[[closedPromise]] to a promise rejected with a TypeError exception.
        // (Already done in step 3 for readable state, and for other states the promise is already settled)

        // Step 5: Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
        // (Not applicable in our implementation - we don't track PromiseIsHandled)

        // Step 6: Perform ! stream.[[controller]].[[ReleaseSteps]]().
        stream.controller.releaseSteps();

        // Step 7: Set stream.[[reader]] to undefined.
        stream.reader = .none;

        // Step 8: Set reader.[[stream]] to undefined.
        self.stream = null;
    
    }

};


