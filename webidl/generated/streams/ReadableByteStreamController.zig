// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortController = @import("dom").AbortController;
const Allocator = @import("std.mem").Allocator;
const AsyncPromise = @import("async_promise").AsyncPromise;
const Element = @import("element").Element;
const Event = @import("event").Event;
const PullIntoDescriptorModule = @import("pull_into_descriptor").PullIntoDescriptorModule;
const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
const ReadIntoRequestModule = @import("read_into_request").ReadIntoRequestModule;
const ReadableStreamBYOBRequest = @import("readable_stream_byob_request").ReadableStreamBYOBRequest;
const ViewConstruction = @import("view_construction").ViewConstruction;
const common = @import("common").common;
const eventLoop = @import("event_loop").eventLoop;
const std = @import("std");
const webidl = @import("webidl");


/// Byte stream queue entry per WHATWG Streams Standard § 4.7.2
///
/// Represents a queued chunk in a byte stream with its buffer and byte range.
const ByteStreamQueueEntry = struct {
    /// The ArrayBuffer containing the queued bytes
    buffer: *ArrayBuffer,
    /// Byte offset into the buffer where this chunk starts
    byteOffset: u64,
    /// Length in bytes of this chunk
    byteLength: u64,
};

pub const ReadableByteStreamController = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    abortController: AbortController,
    autoAllocateChunkSize: ?u64,
    byobRequest: ?*ReadableStreamBYOBRequest,
    cancelAlgorithm: common.CancelAlgorithm,
    closeRequested: bool,
    pullAgain: bool,
    pullAlgorithm: common.PullAlgorithm,
    pulling: bool,
    pendingPullIntos: std.ArrayList(*PullIntoDescriptor),
    byteQueue: std.ArrayList(ByteStreamQueueEntry),
    queueTotalSize: f64,
    started: bool,
    strategyHwm: f64,
    stream: ?*anyopaque,
    eventLoop: eventLoop.EventLoop,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        cancelAlgorithm: common.CancelAlgorithm,
        pullAlgorithm: common.PullAlgorithm,
        strategyHwm: f64,
        autoAllocateChunkSize: ?u64,
        loop: eventLoop.EventLoop,
    ) !ReadableByteStreamController {

        return .{
            .allocator = allocator,
            .abortController = try AbortController.init(allocator),
            .autoAllocateChunkSize = autoAllocateChunkSize,
            .byobRequest = null,
            .cancelAlgorithm = cancelAlgorithm,
            .closeRequested = false,
            .pullAgain = false,
            .pullAlgorithm = pullAlgorithm,
            .pulling = false,
            .pendingPullIntos = .empty,
            .byteQueue = .empty,
            .queueTotalSize = 0.0,
            .started = false,
            .strategyHwm = strategyHwm,
            .stream = null,
            .eventLoop = loop,
        };
    
    }

    pub fn deinit(self: *ReadableByteStreamController) void {

        self.abortController.deinit();

        // Clean up byte queue buffers
        for (self.byteQueue.items) |entry| {
            entry.buffer.deinit(self.allocator);
            self.allocator.destroy(entry.buffer);
        }
        self.byteQueue.deinit(self.allocator);

        // Clean up pending pull-intos
        for (self.pendingPullIntos.items) |descriptor| {
            descriptor.buffer.deinit(self.allocator);
            self.allocator.destroy(descriptor.buffer);
            self.allocator.destroy(descriptor);
        }
        self.pendingPullIntos.deinit(self.allocator);

        // Clean up BYOB request
        if (self.byobRequest) |req| {
            self.allocator.destroy(req);
        }
    
    }

    pub fn get_byobRequest(self: *const ReadableByteStreamController) ?*ReadableStreamBYOBRequest {

        return self.byobRequest;
    
    }

    pub fn get_desiredSize(self: *const ReadableByteStreamController) ?f64 {

        // If stream is closed, return 0
        if (self.closeRequested and self.byteQueue.items.len == 0) {
            return 0.0;
        }

        // Return highWaterMark - queueTotalSize
        return self.strategyHwm - self.queueTotalSize;
    
    }

    pub fn call_close(self: *ReadableByteStreamController) !void {

        // Step 1: If closeRequested is true, throw TypeError
        if (self.closeRequested) {
            return error.TypeError;
        }

        // Step 2: If stream state is not "readable", throw TypeError
        const stream_ptr = self.stream orelse return error.NoStream;
        const ReadableStreamModule = @import("readable_stream");
        const stream: *ReadableStreamModule.ReadableStream = @ptrCast(@alignCast(stream_ptr));

        if (stream.state != .readable) {
            return error.TypeError;
        }

        // Step 3: Perform ReadableByteStreamControllerClose
        self.closeInternal();
    
    }

    pub fn call_enqueue(self: *ReadableByteStreamController, chunk: webidl.ArrayBufferView) !void {

        // Step 1: If chunk ByteLength is 0, throw TypeError
        if (chunk.getByteLength() == 0) {
            return error.TypeError;
        }

        // Step 2: If buffer ByteLength is 0, throw TypeError
        const buffer = chunk.getViewedArrayBuffer();
        if (buffer.byteLength() == 0) {
            return error.TypeError;
        }

        // Step 3: If closeRequested is true, throw TypeError
        if (self.closeRequested) {
            return error.TypeError;
        }

        // Step 4: If stream state is not "readable", throw TypeError
        const stream_ptr = self.stream orelse return error.NoStream;
        const ReadableStreamModule = @import("readable_stream");
        const stream: *ReadableStreamModule.ReadableStream = @ptrCast(@alignCast(stream_ptr));

        if (stream.state != .readable) {
            return error.TypeError;
        }

        // Step 5: Perform ReadableByteStreamControllerEnqueue
        try self.enqueueInternal(chunk);
    
    }

    pub fn call_error(self: *ReadableByteStreamController, e: webidl.JSValue) void {

        const error_value = common.JSValue.fromWebIDL(e);
        self.errorInternal(error_value);
    
    }

    pub fn pullSteps(
        self: *ReadableByteStreamController,
        reader: *anyopaque,
    ) !*AsyncPromise(common.ReadResult) {

        _ = reader; // Not used in this implementation

        // Step 1: Let stream be this.[[stream]].
        const stream_ptr = self.stream orelse {
            const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Stream not initialized"),
                },
            };
            promise.reject(exception);
            return promise;
        };
        const ReadableStreamModule = @import("readable_stream");
        _ = ReadableStreamModule; // For future use
        _ = stream_ptr; // Stream ptr available if needed

        // Step 2: Assert: ! ReadableStreamHasDefaultReader(stream) is true.
        // (We assume this is true when called from a default reader)

        // Step 3: If this.[[queueTotalSize]] > 0,
        if (self.queueTotalSize > 0) {
            // Step 3.1: Assert: ! ReadableStreamGetNumReadRequests(stream) is 0.
            // (Implicit - if queue has data, no pending requests)

            // Step 3.2: Perform ! ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest).
            const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);

            // Dequeue a chunk from the byte queue
            if (self.byteQueue.items.len > 0) {
                const entry = self.byteQueue.orderedRemove(0);

                // Update queue total size
                self.queueTotalSize -= @as(f64, @floatFromInt(entry.byteLength));

                // Create Uint8Array view of the chunk
                const chunk_data = entry.buffer.data[entry.byteOffset..][0..@intCast(entry.byteLength)];
                const chunk_value = common.JSValue{ .bytes = chunk_data };

                // Clean up the buffer
                entry.buffer.deinit(self.allocator);
                self.allocator.destroy(entry.buffer);

                // Fulfill promise with the chunk
                promise.fulfill(.{
                    .value = chunk_value,
                    .done = false,
                });
            } else {
                // Shouldn't happen if queueTotalSize > 0
                const exception = webidl.errors.Exception{
                    .simple = .{
                        .type = .TypeError,
                        .message = try self.allocator.dupe(u8, "Queue size mismatch"),
                    },
                };
                promise.reject(exception);
            }

            // Step 3.3: Return.
            return promise;
        }

        // Step 4: Let autoAllocateChunkSize be this.[[autoAllocateChunkSize]].
        const auto_allocate_chunk_size = self.autoAllocateChunkSize;

        // Step 5: If autoAllocateChunkSize is not undefined,
        if (auto_allocate_chunk_size) |chunk_size| {
            // Step 5.1: Let buffer be Construct(%ArrayBuffer%, « autoAllocateChunkSize »).
            const buffer = ArrayBuffer.init(self.allocator, chunk_size) catch {
                // Step 5.2: If buffer is an abrupt completion,
                const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
                const exception = webidl.errors.Exception{
                    .simple = .{
                        .type = .TypeError,
                        .message = try self.allocator.dupe(u8, "Failed to allocate buffer"),
                    },
                };
                promise.reject(exception);
                return promise;
            };

            const buffer_ptr = try self.allocator.create(ArrayBuffer);
            buffer_ptr.* = buffer;

            // Step 5.3: Let pullIntoDescriptor be a new pull-into descriptor with
            const pull_into_descriptor = try self.allocator.create(PullIntoDescriptor);
            pull_into_descriptor.* = PullIntoDescriptor.init(
                buffer_ptr,
                chunk_size,
                0, // byte offset
                chunk_size, // byte length
                1, // minimum fill (at least 1 byte)
                1, // element size (Uint8Array)
                ViewConstructor.uint8_array,
                .default, // reader type = "default"
            );

            // Step 5.4: Append pullIntoDescriptor to this.[[pendingPullIntos]].
            try self.pendingPullIntos.append(self.allocator, pull_into_descriptor);
        }

        // Step 6: Perform ! ReadableStreamAddReadRequest(stream, readRequest).
        const pending_promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);

        // Add to stream's read requests (this would normally be on the reader)
        // For now, we create a promise that will be fulfilled when data arrives
        // TODO: Properly integrate with reader's readRequests queue

        // Step 7: Perform ! ReadableByteStreamControllerCallPullIfNeeded(this).
        self.callPullIfNeeded();

        // Return the pending promise
        return pending_promise;
    
    }

    pub fn pullInto(
        self: *ReadableByteStreamController,
        view: webidl.ArrayBufferView,
        min: u64,
        readIntoRequest: ReadIntoRequest,
    ) !void {

        // Step 1: Let stream be controller.[[stream]]
        const stream = self.stream orelse return error.NoStream;
        _ = stream; // TODO: Use when stream integration is ready

        // Steps 2-4: Determine element size and constructor from view
        const element_size: u64 = view.getElementSize();

        // Map TypedArrayName to ViewConstructor
        const ctor = if (view.getTypedArrayName()) |name| blk: {
            break :blk switch (name) {
                .Int8Array => ViewConstructor.int8_array,
                .Uint8Array => ViewConstructor.uint8_array,
                .Uint8ClampedArray => ViewConstructor.uint8_clamped_array,
                .Int16Array => ViewConstructor.int16_array,
                .Uint16Array => ViewConstructor.uint16_array,
                .Int32Array => ViewConstructor.int32_array,
                .Uint32Array => ViewConstructor.uint32_array,
                .BigInt64Array => ViewConstructor.bigint64_array,
                .BigUint64Array => ViewConstructor.biguint64_array,
                .Float32Array => ViewConstructor.float32_array,
                .Float64Array => ViewConstructor.float64_array,
            };
        } else ViewConstructor.data_view;

        // Step 5: Calculate minimum fill
        const minimum_fill = min * element_size;

        // Steps 8-9: Extract byteOffset and byteLength
        const byteOffset: u64 = @intCast(view.getByteOffset());
        const byteLength: u64 = @intCast(view.getByteLength());

        // Step 10: Transfer the ArrayBuffer
        const view_buffer = view.getViewedArrayBuffer();

        // Convert webidl.ArrayBuffer to internal ArrayBuffer
        const internal_buffer = try self.allocator.create(ArrayBuffer);
        internal_buffer.* = .{
            .data = view_buffer.data,
            .byte_length = view_buffer.data.len,
            .detached = view_buffer.detached,
        };

        const transferred_buffer = try internal_buffer.transfer();
        const buffer_ptr = try self.allocator.create(ArrayBuffer);
        buffer_ptr.* = transferred_buffer;
        self.allocator.destroy(internal_buffer);

        // Step 13: Create pull-into descriptor
        const pullIntoDescriptor = try self.allocator.create(PullIntoDescriptor);
        pullIntoDescriptor.* = PullIntoDescriptor.init(
            buffer_ptr,
            buffer_ptr.byte_length,
            byteOffset,
            byteLength,
            minimum_fill,
            element_size,
            ctor,
            .byob,
        );

        // Step 17: Append descriptor to pending list
        try self.pendingPullIntos.append(self.allocator, pullIntoDescriptor);

        // Store the readIntoRequest for later fulfillment
        // TODO: Add to stream's readIntoRequests list
        _ = readIntoRequest;

        // Step 19: Call pull if needed
        // TODO: Implement callPullIfNeeded when stream integration is ready
    
    }

    pub fn respond(self: *ReadableByteStreamController, bytesWritten: u64) !void {

        // Step 1: Assert controller.[[pendingPullIntos]] is not empty
        if (self.pendingPullIntos.items.len == 0) {
            return error.InvalidState;
        }

        // Step 2: Let firstDescriptor be controller.[[pendingPullIntos]][0]
        const firstDescriptor = self.pendingPullIntos.items[0];

        // Step 3: Let state be controller.[[stream]].[[state]]
        const stream_ptr = self.stream orelse return error.NoStream;
        const ReadableStreamModule = @import("readable_stream");
        const stream: *ReadableStreamModule.ReadableStream = @ptrCast(@alignCast(stream_ptr));
        const state = stream.state;

        // Step 4: If state is "closed"
        if (state == .closed) {
            // Step 4.1: If bytesWritten is not 0, throw TypeError
            if (bytesWritten != 0) {
                return error.TypeError;
            }
        } else {
            // Step 5: Otherwise (state is "readable")
            // Step 5.1: Assert state is "readable"
            if (state != .readable) {
                return error.InvalidState;
            }

            // Step 5.2: If bytesWritten is 0, throw TypeError
            if (bytesWritten == 0) {
                return error.TypeError;
            }

            // Step 5.3: If firstDescriptor's bytes filled + bytesWritten > firstDescriptor's byte length, throw RangeError
            if (firstDescriptor.bytes_filled + bytesWritten > firstDescriptor.byte_length) {
                return error.RangeError;
            }
        }

        // Step 6: Set firstDescriptor's buffer to ! TransferArrayBuffer(firstDescriptor's buffer)
        const old_buffer = firstDescriptor.buffer;
        const transferred = try old_buffer.transfer();
        const transferred_ptr = try self.allocator.create(ArrayBuffer);
        transferred_ptr.* = transferred;
        firstDescriptor.buffer = transferred_ptr;
        self.allocator.destroy(old_buffer);

        // Step 7: Perform ? ReadableByteStreamControllerRespondInternal(controller, bytesWritten)
        try self.respondInternal(bytesWritten);
    
    }

    pub fn call_respond(self: *ReadableByteStreamController, bytesWritten: u64) !void {

        return self.respond(bytesWritten);
    
    }

    pub fn respondWithNewView(self: *ReadableByteStreamController, view: webidl.ArrayBufferView) !void {

        // Step 1: Assert: controller.[[pendingPullIntos]] is not empty
        if (self.pendingPullIntos.items.len == 0) {
            return error.InvalidState;
        }

        // Step 2: Assert: ! IsDetachedBuffer(view.[[ViewedArrayBuffer]]) is false
        if (view.isDetached()) {
            return error.DetachedBuffer;
        }

        // Step 3: Let firstDescriptor be controller.[[pendingPullIntos]][0]
        const firstDescriptor = self.pendingPullIntos.items[0];

        // Step 4: Let state be controller.[[stream]].[[state]]
        const stream_ptr = self.stream orelse return error.NoStream;
        const ReadableStreamModule = @import("readable_stream");
        const stream: *ReadableStreamModule.ReadableStream = @ptrCast(@alignCast(stream_ptr));
        const state = stream.state;

        // Step 5: If state is "closed"
        if (state == .closed) {
            // Step 5.1: If view.[[ByteLength]] is not 0, throw TypeError
            if (view.getByteLength() != 0) {
                return error.TypeError;
            }
        } else {
            // Step 6: Otherwise (state is "readable")
            // Step 6.1: Assert: state is "readable"
            if (state != .readable) {
                return error.InvalidState;
            }

            // Step 6.2: If view.[[ByteLength]] is 0, throw TypeError
            if (view.getByteLength() == 0) {
                return error.TypeError;
            }
        }

        // Extract view properties
        const view_byteOffset: u64 = @intCast(view.getByteOffset());
        const view_byteLength: u64 = @intCast(view.getByteLength());
        const view_buffer = view.getViewedArrayBuffer();

        // Step 7: If firstDescriptor's byte offset + firstDescriptor's bytes filled is not view.[[ByteOffset]], throw RangeError
        if (firstDescriptor.byte_offset + firstDescriptor.bytes_filled != view_byteOffset) {
            return error.RangeError;
        }

        // Step 8: If firstDescriptor's buffer byte length is not view.[[ViewedArrayBuffer]].[[ByteLength]], throw RangeError
        if (firstDescriptor.buffer.byte_length != view_buffer.data.len) {
            return error.RangeError;
        }

        // Step 9: If firstDescriptor's bytes filled + view.[[ByteLength]] > firstDescriptor's byte length, throw RangeError
        if (firstDescriptor.bytes_filled + view_byteLength > firstDescriptor.byte_length) {
            return error.RangeError;
        }

        // Step 10: Let viewByteLength be view.[[ByteLength]]
        const viewByteLength = view_byteLength;

        // Step 11: Set firstDescriptor's buffer to ? TransferArrayBuffer(view.[[ViewedArrayBuffer]])
        const internal_buffer = try self.allocator.create(ArrayBuffer);
        internal_buffer.* = .{
            .data = view_buffer.data,
            .byte_length = view_buffer.data.len,
            .detached = view_buffer.detached,
        };
        const transferred = try internal_buffer.transfer();

        // Free old buffer before replacing
        firstDescriptor.buffer.deinit(self.allocator);
        self.allocator.destroy(firstDescriptor.buffer);

        const transferred_ptr = try self.allocator.create(ArrayBuffer);
        transferred_ptr.* = transferred;
        firstDescriptor.buffer = transferred_ptr;
        self.allocator.destroy(internal_buffer);

        // Step 12: Perform ? ReadableByteStreamControllerRespondInternal(controller, viewByteLength)
        try self.respondInternal(viewByteLength);
    
    }

    pub fn call_respondWithNewView(self: *ReadableByteStreamController, view: webidl.ArrayBufferView) !void {

        return self.respondWithNewView(view);
    
    }

    pub fn callPullIfNeeded(self: *ReadableByteStreamController) void {

        // Step 1: Determine if pull should be called
        const should_pull = self.shouldCallPull();

        // Step 2: If not needed, return
        if (!should_pull) {
            return;
        }

        // Step 3: If already pulling, set pullAgain flag
        if (self.pulling) {
            self.pullAgain = true;
            return;
        }

        // Step 5: Set pulling flag
        self.pulling = true;

        // Step 6: Call pull algorithm
        const pull_result = self.pullAlgorithm.call();

        // Step 7: On fulfillment
        if (pull_result.isFulfilled()) {
            self.pulling = false;

            // Step 7.2: If pullAgain, call again
            if (self.pullAgain) {
                self.pullAgain = false;
                self.callPullIfNeeded();
            }
        }

        // Step 8: On rejection
        if (pull_result.isRejected()) {
            const exception = pull_result.error_value orelse webidl.errors.Exception.typeError(self.allocator, "Pull failed") catch return;
            const error_value = common.JSValue{ .string = exception.toString() };
            self.errorInternal(error_value);
        }
    
    }

    pub fn handleQueueDrain(self: *ReadableByteStreamController) void {

        // Step 2: If queue is empty and close requested, close the stream
        if (self.queueTotalSize == 0.0 and self.closeRequested) {
            self.clearAlgorithms();

            const stream_ptr = self.stream orelse return;
            const ReadableStreamModule = @import("readable_stream");
            const stream: *ReadableStreamModule.ReadableStream = @ptrCast(@alignCast(stream_ptr));
            stream.closeInternal();
        } else {
            // Step 3: Otherwise, call pull if needed
            self.callPullIfNeeded();
        }
    
    }

    pub fn processReadRequestsUsingQueue(self: *ReadableByteStreamController) !void {

        // Step 1: Get stream
        const stream_ptr = self.stream orelse return;
        const ReadableStreamModule = @import("readable_stream");
        const stream: *ReadableStreamModule.ReadableStream = @ptrCast(@alignCast(stream_ptr));

        // Step 3: Process all read requests
        while (stream.getNumReadRequests() > 0) {
            // Step 3.1: If queue is empty, return
            if (self.queueTotalSize == 0) {
                return;
            }

            // Step 3.4: Fill read request from queue
            try self.fillReadRequestFromQueue();
        }
    
    }

    pub fn call_getBYOBRequest(self: *ReadableByteStreamController) !?*ReadableStreamBYOBRequest {

        // Step 1: If byobRequest is null and pendingPullIntos is not empty
        if (self.byobRequest == null and self.pendingPullIntos.items.len > 0) {
            const firstDescriptor = self.pendingPullIntos.items[0];

            // Create Uint8Array view for the BYOB request
            const view_byteOffset = firstDescriptor.byte_offset + firstDescriptor.bytes_filled;
            const view_byteLength = firstDescriptor.byte_length - firstDescriptor.bytes_filled;

            // Convert internal ArrayBuffer to webidl.ArrayBuffer
            var webidl_buffer = webidl.ArrayBuffer{
                .data = firstDescriptor.buffer.data,
                .detached = firstDescriptor.buffer.detached,
            };

            const Uint8ArrayType = webidl.TypedArray(u8);
            const uint8_view = try Uint8ArrayType.init(
                &webidl_buffer,
                view_byteOffset,
                view_byteLength,
            );
            const view = webidl.ArrayBufferView{ .uint8_array = uint8_view };

            // Create BYOB request
            const byobRequest = try self.allocator.create(ReadableStreamBYOBRequest);
            errdefer self.allocator.destroy(byobRequest);

            // Initialize BYOB request with controller and view
            byobRequest.* = try ReadableStreamBYOBRequest.init(
                self.allocator,
                @ptrCast(self),
                view,
            );

            self.byobRequest = byobRequest;
        }

        // Step 2: Return the request
        return self.byobRequest;
    
    }

    pub fn tee(self: *ReadableByteStreamController) !struct {
 branch1: *anyopaque, branch2: *anyopaque 
    }

};


