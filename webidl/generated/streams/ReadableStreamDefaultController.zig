// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortController = @import("dom").AbortController;
pub const Algorithm = @import("algorithm").Algorithm;
const Allocator = std.mem.Allocator;
const AsyncPromise = @import("async_promise").AsyncPromise;
pub const Controller = @import("controller").Controller;
pub const Exception = @import("exception").Exception;
pub const JSValue = @import("j_s_value").JSValue;
pub const Loop = @import("loop").Loop;
const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
const ReadableStream = @import("readable_stream").ReadableStream;
const ReadableStreamDefaultReader = @import("readable_stream_default_reader").ReadableStreamDefaultReader;
pub const Requests = @import("requests").Requests;
pub const SizeAlgorithm = @import("size_algorithm").SizeAlgorithm;
const Value = @import("queue_with_sizes").Value;
const common = @import("common");
const eventLoop = @import("event_loop");
const std = @import("std");
const webidl = @import("webidl");


/// ReadableStreamDefaultController WebIDL interface
///
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface ReadableStreamDefaultController {
///   readonly attribute unrestricted double? desiredSize;
///
///   undefined close();
///   undefined enqueue(optional any chunk);
///   undefined error(optional any e);
/// };
/// ```

pub const ReadableStreamDefaultController = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    abortController: AbortController,
    cancelAlgorithm: common.CancelAlgorithm,
    closeRequested: bool,
    pullAgain: bool,
    pullAlgorithm: common.PullAlgorithm,
    pulling: bool,
    queue: QueueWithSizes,
    started: bool,
    strategyHwm: f64,
    strategySizeAlgorithm: common.SizeAlgorithm,
    stream: ?*anyopaque,
    eventLoop: eventLoop.EventLoop,

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "ReadableStreamDefaultController",
        .kind = .interface,
    };

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        cancelAlgorithm: common.CancelAlgorithm,
        pullAlgorithm: common.PullAlgorithm,
        strategyHwm: f64,
        strategySizeAlgorithm: common.SizeAlgorithm,
        loop: eventLoop.EventLoop,
    ) !ReadableStreamDefaultController {

        return .{
            .allocator = allocator,
            .abortController = try AbortController.init(allocator),
            .cancelAlgorithm = cancelAlgorithm,
            .closeRequested = false,
            .pullAgain = false,
            .pullAlgorithm = pullAlgorithm,
            .pulling = false,
            .queue = QueueWithSizes.init(allocator),
            .started = false,
            .strategyHwm = strategyHwm,
            .strategySizeAlgorithm = strategySizeAlgorithm,
            .stream = null,
            .eventLoop = loop,
        };
    
    }

    pub fn deinit(self: *ReadableStreamDefaultController) void {

        self.abortController.deinit();
        self.queue.deinit();
    
    }

    pub fn get_desiredSize(self: *const ReadableStreamDefaultController) ?f64 {

        // Step 1: Return ! ReadableStreamDefaultControllerGetDesiredSize(this).
        return self.calculateDesiredSize();
    
    }

    pub fn call_close(self: *ReadableStreamDefaultController) !void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false,
        // throw a TypeError exception.
        if (!self.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        // Step 2: Perform ! ReadableStreamDefaultControllerClose(this).
        self.closeInternal();
    
    }

    pub fn call_enqueue(self: *ReadableStreamDefaultController, chunk: ?webidl.JSValue) !void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false,
        // throw a TypeError exception.
        if (!self.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        const chunkValue = if (chunk) |c| c else webidl.JSValue{ .undefined = {} };

        // Step 2: Perform ? ReadableStreamDefaultControllerEnqueue(this, chunk).
        try self.enqueueInternal(chunkValue);
    
    }

    pub fn call_error(self: *ReadableStreamDefaultController, e: ?webidl.JSValue) void {

        // Step 1: Perform ! ReadableStreamDefaultControllerError(this, e).
        const error_value = if (e) |err| err else webidl.JSValue{ .undefined = {} };
        self.errorInternal(error_value);
    
    }

    pub fn calculateDesiredSize(self: *const ReadableStreamDefaultController) ?f64 {

        // If stream is closed, return 0
        if (self.closeRequested and self.queue.isEmpty()) {
            return 0.0;
        }

        // Return highWaterMark - queueTotalSize
        return self.strategyHwm - self.queue.queue_total_size;
    
    }

    pub fn canCloseOrEnqueue(self: *const ReadableStreamDefaultController) bool {

        // Cannot close or enqueue if already close requested
        return !self.closeRequested;
    
    }

    pub fn closeInternal(self: *ReadableStreamDefaultController) void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
        if (!self.canCloseOrEnqueue()) {
            return;
        }

        // Step 2: Set controller.[[closeRequested]] to true.
        self.closeRequested = true;

        // Step 3: If controller.[[queue]] is empty,
        if (self.queue.isEmpty()) {
            // Step 3.1: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
            self.clearAlgorithms();

            // Step 3.2: Perform ! ReadableStreamClose(stream).
            if (self.stream) |stream_ptr| {
                const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

                // Fulfill all pending read requests with done=true
                switch (stream.reader) {
                    .none => {},
                    .default => |reader| {
                        while (reader.readRequests.items.len > 0) {
                            const promise = reader.readRequests.orderedRemove(0);
                            promise.fulfill(.{
                                .value = null,
                                .done = true,
                            });
                        }
                    },
                    .byob => {}, // TODO: BYOB reader fulfillment (Phase 7)
                }

                stream.closeInternal();
            }
        }
    
    }

    pub fn enqueueInternal(self: *ReadableStreamDefaultController, chunk: webidl.JSValue) !void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
        if (!self.canCloseOrEnqueue()) {
            return;
        }

        // Step 2: Let stream be controller.[[stream]].
        // Step 3: If ! IsReadableStreamLocked(stream) is true and
        //         ! ReadableStreamGetNumReadRequests(stream) > 0,
        //         perform ! ReadableStreamFulfillReadRequest(stream, chunk, false).
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Check if stream has a reader with pending read requests
            if (stream.get_locked()) {
                const num_requests = stream.getNumReadRequests();
                if (num_requests > 0) {
                    // Fulfill the first pending read request immediately
                    stream.fulfillReadRequest(common.JSValue.fromWebIDL(chunk), false);
                    return;
                }
            }
        }

        // Step 4: Otherwise, enqueue the chunk
        // Step 4.1: Let result be the result of performing controller.[[strategySizeAlgorithm]]
        const chunkValue = common.JSValue.fromWebIDL(chunk);
        const chunkSize = self.strategySizeAlgorithm.call(chunkValue);

        // Convert common.JSValue to queue Value for storage
        const queue_value: Value = switch (chunkValue) {
            .undefined => .undefined,
            .null => .null,
            .boolean => |b| .{ .number = if (b) 1.0 else 0.0 },
            .number => |n| .{ .number = n },
            .string => |s| .{ .string = s },
            .bytes => |b| .{ .bytes = b },
            .object => .undefined,
            .close_sentinel => .close_sentinel,
        };

        // Step 4.4: Let enqueueResult be EnqueueValueWithSize(controller, chunk, chunkSize).
        self.queue.enqueueValueWithSize(queue_value, chunkSize) catch {
            // Step 4.5: If enqueueResult is an abrupt completion,
            self.errorInternal(webidl.JSValue{ .string = "Enqueue failed" });
            return error.EnqueueFailed;
        };

        // Step 5: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
        self.callPullIfNeeded();
    
    }

    pub fn errorInternal(self: *ReadableStreamDefaultController, e: webidl.JSValue) void {

        // Convert to internal JSValue
        const error_value = common.JSValue.fromWebIDL(e);

        // Step 1: Let stream be controller.[[stream]].
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Step 2: If stream.[[state]] is not "readable", return.
            if (stream.state != .readable) {
                return;
            }

            // Step 3: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
            self.clearAlgorithms();

            // Step 4: Perform ! ReadableStreamError(stream, e).
            stream.errorInternal(error_value);
        }
    
    }

    fn clearAlgorithms(self: *ReadableStreamDefaultController) void {

        // In Zig, we don't need explicit clearing since algorithms use VTable pattern
        // The algorithms will be freed when the controller is deinitialized
        _ = self;
    
    }

    fn callPullIfNeeded(self: *ReadableStreamDefaultController) void {

        // Step 1: Let shouldPull be ! ReadableStreamDefaultControllerShouldCallPull(controller).
        if (!self.shouldCallPull()) {
            return;
        }

        // Step 2: If controller.[[pulling]] is true,
        if (self.pulling) {
            // Step 2.1: Set controller.[[pullAgain]] to true.
            self.pullAgain = true;
            return;
        }

        // Step 3: Assert: controller.[[pullAgain]] is false.
        std.debug.assert(!self.pullAgain);

        // Step 4: Set controller.[[pulling]] to true.
        self.pulling = true;

        // Step 5: Let pullPromise be the result of performing controller.[[pullAlgorithm]].
        const pullPromise = self.pullAlgorithm.call();

        // TODO: Implement promise handling when pull completes
        // For now, we just mark pulling as complete
        _ = pullPromise;
        self.pulling = false;

        // Check if we need to pull again
        if (self.pullAgain) {
            self.pullAgain = false;
            self.callPullIfNeeded();
        }
    
    }

    fn shouldCallPull(self: *ReadableStreamDefaultController) bool {

        // Step 1: Let stream be controller.[[stream]].
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Step 2: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return false.
            if (!self.canCloseOrEnqueue()) {
                return false;
            }

            // Step 3: If controller.[[started]] is false, return false.
            if (!self.started) {
                return false;
            }

            // Step 4: If ! IsReadableStreamLocked(stream) is true and
            //         ! ReadableStreamGetNumReadRequests(stream) > 0, return true.
            if (stream.get_locked() and stream.getNumReadRequests() > 0) {
                return true;
            }

            // Step 5: Let desiredSize be ! ReadableStreamDefaultControllerGetDesiredSize(controller).
            const desired_size = self.calculateDesiredSize();

            // Step 6: Assert: desiredSize is not null.
            // Step 7: If desiredSize > 0, return true.
            if (desired_size) |size| {
                return size > 0;
            }
        }

        // Step 8: Return false.
        return false;
    
    }

    pub fn pullSteps(self: *ReadableStreamDefaultController, reader: *ReadableStreamDefaultReader) !*AsyncPromise(common.ReadResult) {

        // Step 1: Let stream be controller.[[stream]].
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Step 2: If controller.[[queue]] is not empty,
            if (!self.queue.isEmpty()) {
                // Step 2.1: Let chunk be ! DequeueValue(controller).
                const chunk = self.queue.dequeueValue() catch unreachable;

                // Step 2.2: If controller.[[closeRequested]] is true and controller.[[queue]] is empty,
                if (self.closeRequested and self.queue.isEmpty()) {
                    // Step 2.2.1: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
                    self.clearAlgorithms();
                    // Step 2.2.2: Perform ! ReadableStreamClose(stream).
                    stream.closeInternal();
                }
                // Step 2.3: Otherwise, perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
                else {
                    self.callPullIfNeeded();
                }

                // Step 2.4: Return a promise fulfilled with ! ReadableStreamCreateReadResult(chunk, false, forAuthorCode).
                const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
                promise.fulfill(.{
                    .value = chunk,
                    .done = false,
                });
                return promise;
            }

            // Step 3: Let pendingPromise be ! ReadableStreamAddReadRequest(stream).
            const pendingPromise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
            try reader.readRequests.append(reader.allocator, pendingPromise);

            // Step 4: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
            self.callPullIfNeeded();

            // Step 5: Return pendingPromise.
            return pendingPromise;
        }

        // Shouldn't reach here if stream is set correctly
        const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
        const exception = webidl.errors.Exception{
            .simple = .{
                .type = .TypeError,
                .message = try self.allocator.dupe(u8, "Stream not initialized"),
            },
        };
        promise.reject(exception);
        return promise;
    
    }

    pub fn cancelInternal(self: *ReadableStreamDefaultController, reason: ?common.JSValue) !*AsyncPromise(void) {

        // Step 1: Perform ! ResetQueue(controller).
        self.queue.resetQueue();

        // Step 2: Let result be the result of performing controller.[[cancelAlgorithm]], passing reason.
        const result = self.cancelAlgorithm.call(reason);

        // Step 3: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
        self.clearAlgorithms();

        // Step 4: Return result (convert synchronous promise to async).
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        if (result.isFulfilled()) {
            promise.fulfill({});
        } else if (result.isRejected()) {
            promise.reject(result.error_value orelse webidl.errors.Exception.typeError(self.allocator, "Cancel failed") catch return promise);
        }
        return promise;
    
    }

    pub fn releaseSteps(self: *ReadableStreamDefaultController) void {

        // For default controller, release steps are a no-op
        _ = self;
    
    }

    pub fn hasBackpressure(self: *const ReadableStreamDefaultController) bool {

        // Spec step 1: Let desiredSize be ! ReadableStreamDefaultControllerGetDesiredSize(controller)
        const desired_size = self.calculateDesiredSize();

        // Spec step 2: If desiredSize â‰¤ 0, return true
        // Spec step 3: Return false
        return if (desired_size) |size| size <= 0 else false;
    
    }

    pub fn getDesiredSize(self: *const ReadableStreamDefaultController) ?f64 {

        return self.calculateDesiredSize();
    
    }

};


