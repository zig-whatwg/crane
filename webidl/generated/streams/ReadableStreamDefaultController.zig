// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortController = @import("dom").AbortController;
const Again = @import("again").Again;
const Algorithm = @import("algorithm").Algorithm;
const Algorithms = @import("algorithms").Algorithms;
const Allocator = @import("std.mem").Allocator;
const Assert = @import("assert").Assert;
const AsyncPromise = @import("async_promise").AsyncPromise;
const Attributes = @import("attributes").Attributes;
const AuthorCode = @import("author_code").AuthorCode;
const BYOB = @import("b_y_o_b").BYOB;
const Call = @import("call").Call;
const CallPull = @import("call_pull").CallPull;
const Cancel = @import("cancel").Cancel;
const CancelAlgorithm = @import("cancel_algorithm").CancelAlgorithm;
const Cannot = @import("cannot").Cannot;
const Cast = @import("cast").Cast;
const Check = @import("check").Check;
const Close = @import("close").Close;
const CloseOrEnqueue = @import("close_or_enqueue").CloseOrEnqueue;
const Closes = @import("closes").Closes;
const Controller = @import("controller").Controller;
const Convert = @import("convert").Convert;
const DequeueValue = @import("dequeue_value").DequeueValue;
const DesiredSize = @import("desired_size").DesiredSize;
const Empty = @import("empty").Empty;
const Enqueue = @import("enqueue").Enqueue;
const EnqueueFailed = @import("enqueue_failed").EnqueueFailed;
const EnqueueValueWithSize = @import("enqueue_value_with_size").EnqueueValueWithSize;
const EventLoop = @import("event_loop").EventLoop;
const Exception = @import("exception").Exception;
const For = @import("for").For;
const Fulfill = @import("fulfill").Fulfill;
const Fulfilled = @import("fulfilled").Fulfilled;
const Hwm = @import("hwm").Hwm;
const IDL = @import("i_d_l").IDL;
const If = @import("if").If;
const Implement = @import("implement").Implement;
const In = @import("in").In;
const Instance = @import("instance").Instance;
const Interface = @import("interface").Interface;
const Internal = @import("internal").Internal;
const IsReadableStreamLocked = @import("is_readable_stream_locked").IsReadableStreamLocked;
const JSValue = @import("j_s_value").JSValue;
const Let = @import("let").Let;
const Loop = @import("loop").Loop;
const Methods = @import("methods").Methods;
const NumReadRequests = @import("num_read_requests").NumReadRequests;
const Otherwise = @import("otherwise").Otherwise;
const Perform = @import("perform").Perform;
const Phase = @import("phase").Phase;
const Promise = @import("promise").Promise;
const Pull = @import("pull").Pull;
const PullAlgorithm = @import("pull_algorithm").PullAlgorithm;
const PullIfNeeded = @import("pull_if_needed").PullIfNeeded;
const Queue = @import("queue").Queue;
const QueueWithSizes = @import("queue_with_sizes").QueueWithSizes;
const ReadRequest = @import("read_request").ReadRequest;
const ReadResult = @import("read_result").ReadResult;
const ReadableStream = @import("readable_stream").ReadableStream;
const ReadableStreamAddReadRequest = @import("readable_stream_add_read_request").ReadableStreamAddReadRequest;
const ReadableStreamClose = @import("readable_stream_close").ReadableStreamClose;
const ReadableStreamCreateReadResult = @import("readable_stream_create_read_result").ReadableStreamCreateReadResult;
const ReadableStreamDefaultControllerCallPullIfNeeded = @import("readable_stream_default_controller_call_pull_if_needed").ReadableStreamDefaultControllerCallPullIfNeeded;
const ReadableStreamDefaultControllerCanCloseOrEnqueue = @import("readable_stream_default_controller_can_close_or_enqueue").ReadableStreamDefaultControllerCanCloseOrEnqueue;
const ReadableStreamDefaultControllerClearAlgorithms = @import("readable_stream_default_controller_clear_algorithms").ReadableStreamDefaultControllerClearAlgorithms;
const ReadableStreamDefaultControllerClose = @import("readable_stream_default_controller_close").ReadableStreamDefaultControllerClose;
const ReadableStreamDefaultControllerEnqueue = @import("readable_stream_default_controller_enqueue").ReadableStreamDefaultControllerEnqueue;
const ReadableStreamDefaultControllerError = @import("readable_stream_default_controller_error").ReadableStreamDefaultControllerError;
const ReadableStreamDefaultControllerGetDesiredSize = @import("readable_stream_default_controller_get_desired_size").ReadableStreamDefaultControllerGetDesiredSize;
const ReadableStreamDefaultControllerShouldCallPull = @import("readable_stream_default_controller_should_call_pull").ReadableStreamDefaultControllerShouldCallPull;
const ReadableStreamDefaultReader = @import("readable_stream_default_reader").ReadableStreamDefaultReader;
const ReadableStreamError = @import("readable_stream_error").ReadableStreamError;
const ReadableStreamFulfillReadRequest = @import("readable_stream_fulfill_read_request").ReadableStreamFulfillReadRequest;
const ReadableStreamGetNumReadRequests = @import("readable_stream_get_num_read_requests").ReadableStreamGetNumReadRequests;
const Readonly = @import("readonly").Readonly;
const Rejected = @import("rejected").Rejected;
const Remove = @import("remove").Remove;
const Requested = @import("requested").Requested;
const Requests = @import("requests").Requests;
const ResetQueue = @import("reset_queue").ResetQueue;
const Return = @import("return").Return;
const Returns = @import("returns").Returns;
const Set = @import("set").Set;
const Shouldn = @import("shouldn").Shouldn;
const Size = @import("size").Size;
const SizeAlgorithm = @import("size_algorithm").SizeAlgorithm;
const Spec = @import("spec").Spec;
const Step = @import("step").Step;
const Stream = @import("stream").Stream;
const TODO = @import("t_o_d_o").TODO;
const The = @import("the").The;
const TotalSize = @import("total_size").TotalSize;
const TypeError = @import("type_error").TypeError;
const VTable = @import("v_table").VTable;
const Value = @import("queue_with_sizes").Value;
const ValueWithSize = @import("value_with_size").ValueWithSize;
const WaterMark = @import("water_mark").WaterMark;
const WebIDL = @import("web_i_d_l").WebIDL;
const Zig = @import("zig").Zig;
const anyopaque = @import("anyopaque").anyopaque;
const common = @import("common").common;
const common.CancelAlgorithm = @import("common._cancel_algorithm").common.CancelAlgorithm;
const common.PullAlgorithm = @import("common._pull_algorithm").common.PullAlgorithm;
const common.SizeAlgorithm = @import("common._size_algorithm").common.SizeAlgorithm;
const eventLoop = @import("event_loop").eventLoop;
const eventLoop.EventLoop = @import("event_loop._event_loop").eventLoop.EventLoop;
const std = @import("std");
const std.mem.Allocator = @import("std.mem._allocator").std.mem.Allocator;
const webidl = @import("webidl");


/// ReadableStreamDefaultController WebIDL interface
///
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface ReadableStreamDefaultController {
///   readonly attribute unrestricted double? desiredSize;
///
///   undefined close();
///   undefined enqueue(optional any chunk);
///   undefined error(optional any e);
/// };
/// ```

pub const ReadableStreamDefaultController = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    abortController: AbortController,
    cancelAlgorithm: common.CancelAlgorithm,
    closeRequested: bool,
    pullAgain: bool,
    pullAlgorithm: common.PullAlgorithm,
    pulling: bool,
    queue: QueueWithSizes,
    started: bool,
    strategyHwm: f64,
    strategySizeAlgorithm: common.SizeAlgorithm,
    stream: ?*anyopaque,
    eventLoop: eventLoop.EventLoop,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        cancelAlgorithm: common.CancelAlgorithm,
        pullAlgorithm: common.PullAlgorithm,
        strategyHwm: f64,
        strategySizeAlgorithm: common.SizeAlgorithm,
        loop: eventLoop.EventLoop,
    ) !ReadableStreamDefaultController {

        return .{
            .allocator = allocator,
            .abortController = try AbortController.init(allocator),
            .cancelAlgorithm = cancelAlgorithm,
            .closeRequested = false,
            .pullAgain = false,
            .pullAlgorithm = pullAlgorithm,
            .pulling = false,
            .queue = QueueWithSizes.init(allocator),
            .started = false,
            .strategyHwm = strategyHwm,
            .strategySizeAlgorithm = strategySizeAlgorithm,
            .stream = null,
            .eventLoop = loop,
        };
    
    }

    pub fn deinit(self: *ReadableStreamDefaultController) void {
        self.abortController.deinit();
        self.queue.deinit();
    }

    // ============================================================================
    // WebIDL Interface Methods
    // ============================================================================
    // WebIDL Interface: Readonly Attributes
    // ============================================================================

    /// readonly attribute unrestricted double? desiredSize
    /// IDL: readonly attribute unrestricted double? desiredSize;
    ///
    /// Spec: ยง 4.6.3 "The desiredSize getter steps are:"
    /// Returns the desired size to fill the stream's internal queue.
    pub fn get_desiredSize(self: *const ReadableStreamDefaultController) ?f64 {
        // Step 1: Return ! ReadableStreamDefaultControllerGetDesiredSize(this).
        return self.calculateDesiredSize();
    }

    // ============================================================================
    // WebIDL Interface: Instance Methods
    // ============================================================================

    /// undefined close()
    /// IDL: undefined close();
    ///
    /// Spec: ยง 4.6.3 "The close() method steps are:"
    /// Closes the controlled readable stream.
    pub fn call_close(self: *ReadableStreamDefaultController) !void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false,
        // throw a TypeError exception.
        if (!self.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        // Step 2: Perform ! ReadableStreamDefaultControllerClose(this).
        self.closeInternal();
    
    }

    pub fn call_enqueue(self: *ReadableStreamDefaultController, chunk: ?webidl.JSValue) !void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false,
        // throw a TypeError exception.
        if (!self.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        const chunkValue = if (chunk) |c| c else webidl.JSValue{ .undefined = {} };

        // Step 2: Perform ? ReadableStreamDefaultControllerEnqueue(this, chunk).
        try self.enqueueInternal(chunkValue);
    
    }

    pub fn call_error(self: *ReadableStreamDefaultController, e: ?webidl.JSValue) void {

        // Step 1: Perform ! ReadableStreamDefaultControllerError(this, e).
        const error_value = if (e) |err| err else webidl.JSValue{ .undefined = {} };
        self.errorInternal(error_value);
    
    }

    pub fn calculateDesiredSize(self: *const ReadableStreamDefaultController) ?f64 {

        // If stream is closed, return 0
        if (self.closeRequested and self.queue.isEmpty()) {
            return 0.0;
        }

        // Return highWaterMark - queueTotalSize
        return self.strategyHwm - self.queue.queue_total_size;
    
    }

    pub fn canCloseOrEnqueue(self: *const ReadableStreamDefaultController) bool {
        // Cannot close or enqueue if already close requested
        return !self.closeRequested;
    }

    /// ReadableStreamDefaultControllerClose(controller)
    ///
    /// Spec: ยง 4.6.4 "Close the controller"
    pub fn closeInternal(self: *ReadableStreamDefaultController) void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
        if (!self.canCloseOrEnqueue()) {
            return;
        }

        // Step 2: Set controller.[[closeRequested]] to true.
        self.closeRequested = true;

        // Step 3: If controller.[[queue]] is empty,
        if (self.queue.isEmpty()) {
            // Step 3.1: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
            self.clearAlgorithms();

            // Step 3.2: Perform ! ReadableStreamClose(stream).
            if (self.stream) |stream_ptr| {
                const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

                // Fulfill all pending read requests with done=true
                switch (stream.reader) {
                    .none => {},
                    .default => |reader| {
                        while (reader.readRequests.items.len > 0) {
                            const promise = reader.readRequests.orderedRemove(0);
                            promise.fulfill(.{
                                .value = null,
                                .done = true,
                            });
                        }
                    },
                    .byob => {}, // TODO: BYOB reader fulfillment (Phase 7)
                }

                stream.closeInternal();
            }
        }
    
    }

    pub fn enqueueInternal(self: *ReadableStreamDefaultController, chunk: webidl.JSValue) !void {

        // Step 1: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
        if (!self.canCloseOrEnqueue()) {
            return;
        }

        // Step 2: Let stream be controller.[[stream]].
        // Step 3: If ! IsReadableStreamLocked(stream) is true and
        //         ! ReadableStreamGetNumReadRequests(stream) > 0,
        //         perform ! ReadableStreamFulfillReadRequest(stream, chunk, false).
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Check if stream has a reader with pending read requests
            if (stream.get_locked()) {
                const num_requests = stream.getNumReadRequests();
                if (num_requests > 0) {
                    // Fulfill the first pending read request immediately
                    stream.fulfillReadRequest(common.JSValue.fromWebIDL(chunk), false);
                    return;
                }
            }
        }

        // Step 4: Otherwise, enqueue the chunk
        // Step 4.1: Let result be the result of performing controller.[[strategySizeAlgorithm]]
        const chunkValue = common.JSValue.fromWebIDL(chunk);
        const chunkSize = self.strategySizeAlgorithm.call(chunkValue);

        // Convert common.JSValue to queue Value for storage
        const queue_value: Value = switch (chunkValue) {
            .undefined => .undefined,
            .null => .null,
            .boolean => |b| .{ .number = if (b) 1.0 else 0.0 },
            .number => |n| .{ .number = n },
            .string => |s| .{ .string = s },
            .bytes => |b| .{ .bytes = b },
            .object => .undefined,
            .close_sentinel => .close_sentinel,
        };

        // Step 4.4: Let enqueueResult be EnqueueValueWithSize(controller, chunk, chunkSize).
        self.queue.enqueueValueWithSize(queue_value, chunkSize) catch {
            // Step 4.5: If enqueueResult is an abrupt completion,
            self.errorInternal(webidl.JSValue{ .string = "Enqueue failed" });
            return error.EnqueueFailed;
        };

        // Step 5: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
        self.callPullIfNeeded();
    
    }

    pub fn errorInternal(self: *ReadableStreamDefaultController, e: webidl.JSValue) void {

        // Convert to internal JSValue
        const error_value = common.JSValue.fromWebIDL(e);

        // Step 1: Let stream be controller.[[stream]].
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Step 2: If stream.[[state]] is not "readable", return.
            if (stream.state != .readable) {
                return;
            }

            // Step 3: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
            self.clearAlgorithms();

            // Step 4: Perform ! ReadableStreamError(stream, e).
            stream.errorInternal(error_value);
        }
    
    }

    fn clearAlgorithms(self: *ReadableStreamDefaultController) void {
        // In Zig, we don't need explicit clearing since algorithms use VTable pattern
        // The algorithms will be freed when the controller is deinitialized
        _ = self;
    }

    /// ReadableStreamDefaultControllerCallPullIfNeeded(controller)
    ///
    /// Spec: ยง 4.6.4 "Call pull algorithm if backpressure allows"
    fn callPullIfNeeded(self: *ReadableStreamDefaultController) void {

        // Step 1: Let shouldPull be ! ReadableStreamDefaultControllerShouldCallPull(controller).
        if (!self.shouldCallPull()) {
            return;
        }

        // Step 2: If controller.[[pulling]] is true,
        if (self.pulling) {
            // Step 2.1: Set controller.[[pullAgain]] to true.
            self.pullAgain = true;
            return;
        }

        // Step 3: Assert: controller.[[pullAgain]] is false.
        std.debug.assert(!self.pullAgain);

        // Step 4: Set controller.[[pulling]] to true.
        self.pulling = true;

        // Step 5: Let pullPromise be the result of performing controller.[[pullAlgorithm]].
        const pullPromise = self.pullAlgorithm.call();

        // TODO: Implement promise handling when pull completes
        // For now, we just mark pulling as complete
        _ = pullPromise;
        self.pulling = false;

        // Check if we need to pull again
        if (self.pullAgain) {
            self.pullAgain = false;
            self.callPullIfNeeded();
        }
    
    }

    fn shouldCallPull(self: *ReadableStreamDefaultController) bool {

        // Step 1: Let stream be controller.[[stream]].
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Step 2: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return false.
            if (!self.canCloseOrEnqueue()) {
                return false;
            }

            // Step 3: If controller.[[started]] is false, return false.
            if (!self.started) {
                return false;
            }

            // Step 4: If ! IsReadableStreamLocked(stream) is true and
            //         ! ReadableStreamGetNumReadRequests(stream) > 0, return true.
            if (stream.get_locked() and stream.getNumReadRequests() > 0) {
                return true;
            }

            // Step 5: Let desiredSize be ! ReadableStreamDefaultControllerGetDesiredSize(controller).
            const desired_size = self.calculateDesiredSize();

            // Step 6: Assert: desiredSize is not null.
            // Step 7: If desiredSize > 0, return true.
            if (desired_size) |size| {
                return size > 0;
            }
        }

        // Step 8: Return false.
        return false;
    
    }

    pub fn pullSteps(self: *ReadableStreamDefaultController, reader: *ReadableStreamDefaultReader) !*AsyncPromise(common.ReadResult) {

        // Step 1: Let stream be controller.[[stream]].
        if (self.stream) |stream_ptr| {
            const stream: *ReadableStream = @ptrCast(@alignCast(stream_ptr));

            // Step 2: If controller.[[queue]] is not empty,
            if (!self.queue.isEmpty()) {
                // Step 2.1: Let chunk be ! DequeueValue(controller).
                const chunk = self.queue.dequeueValue() catch unreachable;

                // Step 2.2: If controller.[[closeRequested]] is true and controller.[[queue]] is empty,
                if (self.closeRequested and self.queue.isEmpty()) {
                    // Step 2.2.1: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
                    self.clearAlgorithms();
                    // Step 2.2.2: Perform ! ReadableStreamClose(stream).
                    stream.closeInternal();
                }
                // Step 2.3: Otherwise, perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
                else {
                    self.callPullIfNeeded();
                }

                // Step 2.4: Return a promise fulfilled with ! ReadableStreamCreateReadResult(chunk, false, forAuthorCode).
                const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
                promise.fulfill(.{
                    .value = chunk,
                    .done = false,
                });
                return promise;
            }

            // Step 3: Let pendingPromise be ! ReadableStreamAddReadRequest(stream).
            const pendingPromise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
            try reader.readRequests.append(reader.allocator, pendingPromise);

            // Step 4: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
            self.callPullIfNeeded();

            // Step 5: Return pendingPromise.
            return pendingPromise;
        }

        // Shouldn't reach here if stream is set correctly
        const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
        const exception = webidl.errors.Exception{
            .simple = .{
                .type = .TypeError,
                .message = try self.allocator.dupe(u8, "Stream not initialized"),
            },
        };
        promise.reject(exception);
        return promise;
    
    }

    pub fn cancelInternal(self: *ReadableStreamDefaultController, reason: ?common.JSValue) !*AsyncPromise(void) {

        // Step 1: Perform ! ResetQueue(controller).
        self.queue.resetQueue();

        // Step 2: Let result be the result of performing controller.[[cancelAlgorithm]], passing reason.
        const result = self.cancelAlgorithm.call(reason);

        // Step 3: Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
        self.clearAlgorithms();

        // Step 4: Return result (convert synchronous promise to async).
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        if (result.isFulfilled()) {
            promise.fulfill({});
        } else if (result.isRejected()) {
            promise.reject(result.error_value orelse webidl.errors.Exception.typeError(self.allocator, "Cancel failed") catch return promise);
        }
        return promise;
    
    }

};


