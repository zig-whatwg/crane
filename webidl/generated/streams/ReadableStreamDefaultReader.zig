// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const AsyncPromise = @import("async_promise").AsyncPromise;
pub const Exception = @import("exception").Exception;
pub const JSValue = @import("j_s_value").JSValue;
pub const Loop = @import("loop").Loop;
pub const Promise = @import("promise").Promise;
const ReadRequest = @import("read_request").ReadRequest;
const ReadableStream = @import("readable_stream").ReadableStream;
const ReadableStreamGenericReader = @import("readable_stream_generic_reader").ReadableStreamGenericReader;
pub const Requests = @import("requests").Requests;
const common = @import("common");
const eventLoop = @import("event_loop");
const infra = @import("infra");
const std = @import("std");
const webidl = @import("webidl");


/// ReadableStreamDefaultReader WebIDL interface
///
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface ReadableStreamDefaultReader {
///   constructor(ReadableStream stream);
///
///   Promise<ReadableStreamReadResult> read();
///   undefined releaseLock();
/// };
/// ReadableStreamDefaultReader includes ReadableStreamGenericReader;
/// ```
///
/// This interface includes the ReadableStreamGenericReader mixin, which provides:
/// - readonly attribute Promise<undefined> closed;
/// - Promise<undefined> cancel(optional any reason);

/// ReadableStreamDefaultReader WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface ReadableStreamDefaultReader {
/// constructor(ReadableStream stream);
/// 
/// Promise<ReadableStreamReadResult> read();
/// undefined releaseLock();
/// };
/// ReadableStreamDefaultReader includes ReadableStreamGenericReader;
/// ```
/// 
/// This interface includes the ReadableStreamGenericReader mixin, which provides:
/// - readonly attribute Promise<undefined> closed;
/// - Promise<undefined> cancel(optional any reason);
pub const ReadableStreamDefaultReader = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    /// [[closedPromise]]: Promise that fulfills when stream closes
    closedPromise: *AsyncPromise(void),
    /// [[stream]]: The ReadableStream being read from (or undefined if released)
    stream: ?*ReadableStream,
    /// Event loop for async operations
    eventLoop: eventLoop.EventLoop,
    /// [[readRequests]]: List of pending read requests (async promises)
    /// 
    /// Spec: § 4.3.2 Internal slot [[readRequests]]
    /// Changed from List(ReadRequest) to support async operations
    readRequests: infra.List(*AsyncPromise(common.ReadResult)),

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "ReadableStreamDefaultReader",
        .kind = .interface,
    };

    // ========================================================================
    // Methods
    // ========================================================================

    /// Initialize a new default reader (internal - not exposed via WebIDL)
    /// 
    /// Spec: § 4.3.4 "SetUpReadableStreamDefaultReader(reader, stream)"
    pub fn init(
        allocator: std.mem.Allocator,
        stream: *ReadableStream,
        loop: eventLoop.EventLoop,
    ) !ReadableStreamDefaultReader {

        return .{
            .allocator = null,
            .closedPromise = null,
            .stream = null,
            .eventLoop = null,
            .readRequests = infra.List(*AsyncPromise(common.ReadResult)).init(allocator),
        };
    
    }

    /// Deinitialize the reader
    /// 
    /// Spec: Cleanup internal slots
    pub fn deinit(self: *ReadableStreamDefaultReader) void {

        // Note: readRequests promises are owned by callers, just clear the list
        self.readRequests.deinit();
    
    }

    /// Promise<ReadableStreamReadResult> read()
    /// IDL: Promise<ReadableStreamReadResult> read();
    /// 
    /// Returns an AsyncPromise that will be fulfilled when data arrives
    /// or rejected if the stream errors. The promise is PENDING if no
    /// data is immediately available.
    /// 
    /// **IMPORTANT**: Caller owns the returned promise and must call deinit()
    pub fn call_read(self: *ReadableStreamDefaultReader) !*AsyncPromise(common.ReadResult) {

        // Step 1: If this.[[stream]] is undefined, return a promise rejected with a TypeError exception.
        if (self.stream == null) {
            const promise = try AsyncPromise(common.ReadResult).init(
                self.allocator,
                self.eventLoop,
            );
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Reader released"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        // Step 2: Return ! ReadableStreamDefaultReaderRead(this).
        return self.readInternal();
    
    }

    /// releaseLock() method
    /// 
    /// IDL: undefined releaseLock();
    /// 
    /// Spec: § 4.3.3 "The releaseLock() method steps are:"
    /// Releases the reader's lock on the stream.
    pub fn call_releaseLock(self: *ReadableStreamDefaultReader) void {

        // Step 1: If this.[[stream]] is undefined, return.
        if (self.stream == null) {
            return;
        }

        // Step 2: Perform ! ReadableStreamDefaultReaderRelease(this).
        // Delegate to mixin's generic release
        self.genericRelease();
    
    }

    /// ReadableStreamDefaultReaderRead(reader) - ASYNC VERSION
    /// 
    /// Spec: § 4.3.4 "ReadableStreamDefaultReaderRead(reader)"
    /// 
    /// This is the core async read logic. It returns:
    /// - Immediately fulfilled promise if data is available in the queue
    /// - Pending promise if no data is available (will be fulfilled later when data arrives)
    /// - Rejected promise if stream is errored
    fn readInternal(self: *ReadableStreamDefaultReader) !*AsyncPromise(common.ReadResult) {

        // Step 1: Let stream be reader.[[stream]].
        const stream = self.stream.?;

        // Step 2: Assert: stream.[[reader]] is reader.
        std.debug.assert(stream.reader == .default);

        // Step 3: Set stream.[[disturbed]] to true.
        stream.disturbed = true;

        // Step 4: If stream.[[state]] is "closed", return a promise fulfilled with {value: undefined, done: true}.
        if (stream.state == .closed) {
            const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
            promise.fulfill(common.ReadResult{ .value = null, .done = true });
            return promise;
        }

        // Step 5: If stream.[[state]] is "errored", return a promise rejected with stream.[[storedError]].
        if (stream.state == .errored) {
            const stored_err = stream.storedError orelse common.JSValue.undefined_value();
            const exception = try stored_err.toException(self.allocator);
            const promise = try AsyncPromise(common.ReadResult).init(self.allocator, self.eventLoop);
            promise.reject(exception);
            return promise;
        }

        // Step 6: Assert: stream.[[state]] is "readable".
        std.debug.assert(stream.state == .readable);

        // Step 7: Return ! stream.[[controller]].[[PullSteps]]().
        // This delegates to the controller to actually pull data
        return stream.controller.pullSteps(self);
    
    }

    /// readonly attribute Promise<undefined> closed
    /// IDL: readonly attribute Promise<undefined> closed;
    /// 
    /// Spec: § 4.2.3 "The closed getter steps are:"
    pub fn get_closed(self: *const ReadableStreamDefaultReader) webidl.Promise(void) {
        const self_parent: *const ReadableStreamGenericReader = @ptrCast(self);

        if (self_parent.closedPromise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else if (self_parent.closedPromise.isRejected()) {
            const err_msg = self_parent.closedPromise.state.rejected.toString();
            return webidl.Promise(void).rejected(err_msg);
        } else {
            return webidl.Promise(void).pending();
        }
    
    }

    /// Promise<undefined> cancel(optional any reason)
    /// IDL: Promise<undefined> cancel(optional any reason);
    /// 
    /// Spec: § 4.2.3 "The cancel(reason) method steps are:"
    pub fn call_cancel(self: *ReadableStreamDefaultReader, reason: ?webidl.JSValue) !*AsyncPromise(void) {
        const self_parent: *ReadableStreamGenericReader = @ptrCast(self);

        // Step 1: If this.[[stream]] is undefined, return a promise rejected with a TypeError exception.
        if (self_parent.stream == null) {
            const promise = try AsyncPromise(void).init(self_parent.allocator, self_parent.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self_parent.allocator.dupe(u8, "Reader released"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        const reason_value = if (reason) |r| common.JSValue.fromWebIDL(r) else null;

        // Step 2: Return ! ReadableStreamReaderGenericCancel(this, reason).
        return self.genericCancel(reason_value);
    
    }

    /// ReadableStreamReaderGenericCancel(reader, reason)
    /// 
    /// Spec: § 4.2.5 "Generic cancel implementation shared by all reader types"
    fn genericCancel(self: *ReadableStreamDefaultReader, reason: ?common.JSValue) !*AsyncPromise(void) {
        const self_parent: *ReadableStreamGenericReader = @ptrCast(self);

        // Step 1: Let stream be reader.[[stream]].
        const stream = self_parent.stream.?;

        // Step 2: Assert: stream is not undefined.
        // (Assertion is implicit - .? will panic if stream is null)

        // Step 3: Return ! ReadableStreamCancel(stream, reason).
        return stream.cancelInternal(reason);
    
    }

    /// ReadableStreamReaderGenericRelease(reader)
    /// 
    /// Spec: § 4.2.6 "Generic release implementation shared by all reader types"
    pub fn genericRelease(self: *ReadableStreamDefaultReader) void {
        const self_parent: *ReadableStreamGenericReader = @ptrCast(self);

        // Step 1: Let stream be reader.[[stream]].
        const stream = self_parent.stream.?;

        // Step 2: Assert: stream.[[reader]] is reader.
        // (We can't directly assert this due to type differences, but logically true)

        // Step 3: If stream.[[state]] is "readable", reject reader.[[closedPromise]] with a TypeError exception.
        if (stream.state == .readable) {
            self_parent.closedPromise.reject(webidl.errors.Exception.typeError(self_parent.allocator, "Reader released before stream closed") catch return);
        }

        // Step 4: Otherwise, set reader.[[closedPromise]] to a promise rejected with a TypeError exception.
        // (Already done in step 3 for readable state, and for other states the promise is already settled)

        // Step 5: Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
        // (Not applicable in our implementation - we don't track PromiseIsHandled)

        // Step 6: Perform ! stream.[[controller]].[[ReleaseSteps]]().
        stream.controller.releaseSteps();

        // Step 7: Set stream.[[reader]] to undefined.
        stream.reader = .none;

        // Step 8: Set reader.[[stream]] to undefined.
        self_parent.stream = null;
    
    }

};


