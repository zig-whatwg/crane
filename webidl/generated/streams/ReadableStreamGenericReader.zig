// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! ReadableStreamGenericReader mixin per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#generic-reader-mixin
//!
//! This mixin defines the shared interface between ReadableStreamDefaultReader
//! and ReadableStreamBYOBReader.
//!
//! IDL:
//! ```webidl
//! interface mixin ReadableStreamGenericReader {
//!   readonly attribute Promise<undefined> closed;
//!   Promise<undefined> cancel(optional any reason);
//! };
//! ```

const std = @import("std");
const webidl = @import("webidl");

pub const common = @import("common");
pub const eventLoop = @import("event_loop");
pub const AsyncPromise = @import("async_promise").AsyncPromise;

pub const ReadableStream = @import("readable_stream").ReadableStream;
/// ReadableStreamGenericReader mixin
/// 
/// This mixin defines the shared interface between ReadableStreamDefaultReader
/// and ReadableStreamBYOBReader.
pub const ReadableStreamGenericReader = struct {
    // ========================================================================
    // ReadableStreamGenericReader fields
    // ========================================================================
    allocator: std.mem.Allocator,
    /// [[closedPromise]]: Promise that fulfills when stream closes
    closedPromise: *AsyncPromise(void),
    /// [[stream]]: The ReadableStream being read from (or undefined if released)
    stream: ?*ReadableStream,
    /// Event loop for async operations
    eventLoop: eventLoop.EventLoop,

    // ========================================================================
    // ReadableStreamGenericReader methods
    // ========================================================================

    /// readonly attribute Promise<undefined> closed
    /// IDL: readonly attribute Promise<undefined> closed;
    /// 
    /// Spec: ยง 4.2.3 "The closed getter steps are:"
    pub fn get_closed(self: *const ReadableStreamGenericReader) webidl.Promise(void) {
        if (self.closedPromise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else if (self.closedPromise.isRejected()) {
            const err_str = switch (self.closedPromise.state.rejected) {
                .string => |s| s,
                else => "Unknown error",
            };
            return webidl.Promise(void).rejected(err_str);
        } else {
            return webidl.Promise(void).pending();
        }
    }
    /// Promise<undefined> cancel(optional any reason)
    /// IDL: Promise<undefined> cancel(optional any reason);
    /// 
    /// Spec: ยง 4.2.3 "The cancel(reason) method steps are:"
    pub fn call_cancel(self: *ReadableStreamGenericReader, reason: ?webidl.JSValue) !*AsyncPromise(void) {
        // Step 1: If this.[[stream]] is undefined, return a promise rejected with a TypeError exception.
        if (self.stream == null) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            promise.reject(common.JSValue{ .string = "Reader released" });
            return promise;
        }

        const reason_value = if (reason) |r| common.JSValue.fromWebIDL(r) else null;

        // Step 2: Return ! ReadableStreamReaderGenericCancel(this, reason).
        return self.genericCancel(reason_value);
    }
    /// ReadableStreamReaderGenericCancel(reader, reason)
    /// 
    /// Spec: ยง 4.2.5 "Generic cancel implementation shared by all reader types"
    fn genericCancel(self: *ReadableStreamGenericReader, reason: ?common.JSValue) !*AsyncPromise(void) {
        // Step 1: Let stream be reader.[[stream]].
        const stream = self.stream.?;

        // Step 2: Assert: stream is not undefined.
        // (Assertion is implicit - .? will panic if stream is null)

        // Step 3: Return ! ReadableStreamCancel(stream, reason).
        return stream.cancelInternal(reason);
    }
    /// ReadableStreamReaderGenericRelease(reader)
    /// 
    /// Spec: ยง 4.2.6 "Generic release implementation shared by all reader types"
    pub fn genericRelease(self: *ReadableStreamGenericReader) void {
        // Step 1: Let stream be reader.[[stream]].
        const stream = self.stream.?;

        // Step 2: Assert: stream.[[reader]] is reader.
        // (We can't directly assert this due to type differences, but logically true)

        // Step 3: If stream.[[state]] is "readable", reject reader.[[closedPromise]] with a TypeError exception.
        if (stream.state == .readable) {
            self.closedPromise.reject(common.JSValue{ .string = "Reader released before stream closed" });
        }

        // Step 4: Otherwise, set reader.[[closedPromise]] to a promise rejected with a TypeError exception.
        // (Already done in step 3 for readable state, and for other states the promise is already settled)

        // Step 5: Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
        // (Not applicable in our implementation - we don't track PromiseIsHandled)

        // Step 6: Perform ! stream.[[controller]].[[ReleaseSteps]]().
        stream.controller.releaseSteps();

        // Step 7: Set stream.[[reader]] to undefined.
        stream.reader = .none;

        // Step 8: Set reader.[[stream]] to undefined.
        self.stream = null;
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ReadableStreamGenericReader",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

