// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! ReadableStreamBYOBRequest class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#rs-byob-request-class
//! IDL: specs/streams.idl lines 115-121
//!
//! Represents a pending BYOB read request.
//! Allows the underlying byte source to write data into the reader's buffer.

const std = @import("std");

const webidl = @import("webidl");
const common = @import("common");

/// Import ReadableByteStreamController from its module
const ReadableByteStreamControllerModule = @import("readable_byte_stream_controller");
const ReadableByteStreamController = ReadableByteStreamControllerModule.ReadableByteStreamController;
/// ReadableStreamBYOBRequest WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface ReadableStreamBYOBRequest {
/// readonly attribute ArrayBufferView? view;
/// 
/// undefined respond([EnforceRange] unsigned long long bytesWritten);
/// undefined respondWithNewView(ArrayBufferView view);
/// };
/// ```
pub const ReadableStreamBYOBRequest = struct {
    allocator: std.mem.Allocator,
    /// [[controller]]: ReadableByteStreamController (or undefined if responded)
    controller: ?*ReadableByteStreamController,
    /// [[view]]: ArrayBufferView to write into (or null if responded)
    view: ?webidl.ArrayBufferView,

    /// Initialize a BYOB request (internal - not exposed via WebIDL)
    pub fn init(
        allocator: std.mem.Allocator,
        controller: *ReadableByteStreamController,
        view: webidl.ArrayBufferView,
    ) ReadableStreamBYOBRequest {
        return .{
            .allocator = allocator,
            .controller = controller,
            .view = view,
        };
    }
    pub fn deinit(self: *ReadableStreamBYOBRequest) void {
        _ = self;
        // No heap allocations to clean up
    }
    /// Returns the view to write into, or null if already responded.
    /// 
    /// IDL: readonly attribute ArrayBufferView? view;
    /// 
    /// Spec algorithm: ยง 4.8.3 "The view getter steps are:"
    pub fn get_view(self: *const ReadableStreamBYOBRequest) ?webidl.ArrayBufferView {
        // Step 1: Return this.[[view]].
        return self.view;
    }
    /// Indicates to the stream that bytesWritten bytes were written into view.
    /// 
    /// IDL: undefined respond([EnforceRange] unsigned long long bytesWritten);
    /// 
    /// Spec algorithm: ยง 4.8.3 "The respond(bytesWritten) method steps are:"
    pub fn call_respond(self: *ReadableStreamBYOBRequest, bytesWritten: u64) !void {
        // Step 1: If this.[[controller]] is undefined, throw a TypeError exception.
        if (self.controller == null) {
            return error.TypeError;
        }

        // Step 2: If ! IsDetachedBuffer(this.[[view]].[[ViewedArrayBuffer]]) is true,
        //         throw a TypeError exception.
        if (self.view == null) {
            return error.TypeError;
        }

        // TODO: Check if buffer is detached when webidl provides the API
        // For now, skip the detachment check

        // Step 3: Assert: this.[[view]].[[ByteLength]] > 0.
        // Step 4: Assert: this.[[view]].[[ViewedArrayBuffer]].[[ByteLength]] > 0.

        // Step 5: Perform ? ReadableByteStreamControllerRespond(this.[[controller]], bytesWritten).
        try self.respondInternal(bytesWritten);
    }
    /// Indicates to the stream that the entire view was written into.
    /// 
    /// IDL: undefined respondWithNewView(ArrayBufferView view);
    /// 
    /// Spec algorithm: ยง 4.8.3 "The respondWithNewView(view) method steps are:"
    pub fn call_respondWithNewView(self: *ReadableStreamBYOBRequest, view: webidl.ArrayBufferView) !void {
        // Step 1: If this.[[controller]] is undefined, throw a TypeError exception.
        if (self.controller == null) {
            return error.TypeError;
        }

        // Step 2: If ! IsDetachedBuffer(view.[[ViewedArrayBuffer]]) is true,
        //         throw a TypeError exception.
        // TODO: Check if buffer is detached when webidl provides the API
        // For now, skip the detachment check

        // Step 3: Return ? ReadableByteStreamControllerRespondWithNewView(this.[[controller]], view).
        try self.respondWithNewViewInternal(view);
    }
    fn respondInternal(self: *ReadableStreamBYOBRequest, bytesWritten: u64) !void {
        _ = self;
        _ = bytesWritten;
        // Would call controller's respond algorithm
    }
    fn respondWithNewViewInternal(self: *ReadableStreamBYOBRequest, view: webidl.ArrayBufferView) !void {
        _ = self;
        _ = view;
        // Would call controller's respondWithNewView algorithm
    }
};


// Tests

test "ReadableStreamBYOBRequest - view getter returns view" {
    const allocator = std.testing.allocator;

    // Use a dummy pointer for the opaque controller type
    const fake_controller = @as(*ReadableByteStreamController, @ptrFromInt(0x1000));

    // Create a minimal valid typed array
    const fake_buffer = @as(*webidl.ArrayBuffer, @ptrFromInt(0x2000));
    const typed_array = webidl.TypedArray(u8){
        .buffer = fake_buffer,
        .byteOffset = 0,
        .length = 1024,
    };
    const test_view = webidl.ArrayBufferView{ .uint8_array = typed_array };

    var request = ReadableStreamBYOBRequest.init(allocator, fake_controller, test_view);
    defer request.deinit();

    // View getter should return the view
    const view = request.get_view();
    try std.testing.expect(view != null);
}

test "ReadableStreamBYOBRequest - view getter returns null after invalidation" {
    const allocator = std.testing.allocator;

    // Use a dummy pointer for the opaque controller type
    const fake_controller = @as(*ReadableByteStreamController, @ptrFromInt(0x1000));

    // Create a minimal valid typed array
    const fake_buffer = @as(*webidl.ArrayBuffer, @ptrFromInt(0x2000));
    const typed_array = webidl.TypedArray(u8){
        .buffer = fake_buffer,
        .byteOffset = 0,
        .length = 1024,
    };
    const test_view = webidl.ArrayBufferView{ .uint8_array = typed_array };

    var request = ReadableStreamBYOBRequest.init(allocator, fake_controller, test_view);
    defer request.deinit();

    // Initially view is present
    try std.testing.expect(request.get_view() != null);

    // Invalidate the request (simulating what controller does)
    request.controller = null;
    request.view = null;

    // After invalidation, view getter returns null
    try std.testing.expect(request.get_view() == null);
}

test "ReadableStreamBYOBRequest - respond fails after controller invalidation" {
    const allocator = std.testing.allocator;

    // Use a dummy pointer for the opaque controller type
    const fake_controller = @as(*ReadableByteStreamController, @ptrFromInt(0x1000));

    // Create a minimal valid typed array
    const fake_buffer = @as(*webidl.ArrayBuffer, @ptrFromInt(0x2000));
    const typed_array = webidl.TypedArray(u8){
        .buffer = fake_buffer,
        .byteOffset = 0,
        .length = 1024,
    };
    const test_view = webidl.ArrayBufferView{ .uint8_array = typed_array };

    var request = ReadableStreamBYOBRequest.init(allocator, fake_controller, test_view);
    defer request.deinit();

    // Invalidate controller
    request.controller = null;

    // Respond should fail with TypeError
    const result = request.call_respond(512);
    try std.testing.expectError(error.TypeError, result);
}

test "ReadableStreamBYOBRequest - respond fails after view invalidation" {
    const allocator = std.testing.allocator;

    // Use a dummy pointer for the opaque controller type
    const fake_controller = @as(*ReadableByteStreamController, @ptrFromInt(0x1000));

    // Create a minimal valid typed array
    const fake_buffer = @as(*webidl.ArrayBuffer, @ptrFromInt(0x2000));
    const typed_array = webidl.TypedArray(u8){
        .buffer = fake_buffer,
        .byteOffset = 0,
        .length = 1024,
    };
    const test_view = webidl.ArrayBufferView{ .uint8_array = typed_array };

    var request = ReadableStreamBYOBRequest.init(allocator, fake_controller, test_view);
    defer request.deinit();

    // Invalidate view
    request.view = null;

    // Respond should fail with TypeError
    const result = request.call_respond(512);
    try std.testing.expectError(error.TypeError, result);
}

test "ReadableStreamBYOBRequest - respondWithNewView fails after controller invalidation" {
    const allocator = std.testing.allocator;

    // Use a dummy pointer for the opaque controller type
    const fake_controller = @as(*ReadableByteStreamController, @ptrFromInt(0x1000));

    // Create minimal valid typed arrays
    const fake_buffer = @as(*webidl.ArrayBuffer, @ptrFromInt(0x2000));
    const typed_array = webidl.TypedArray(u8){
        .buffer = fake_buffer,
        .byteOffset = 0,
        .length = 1024,
    };
    const test_view = webidl.ArrayBufferView{ .uint8_array = typed_array };

    var request = ReadableStreamBYOBRequest.init(allocator, fake_controller, test_view);
    defer request.deinit();

    // Invalidate controller
    request.controller = null;

    // RespondWithNewView should fail with TypeError
    const new_typed_array = webidl.TypedArray(u8){
        .buffer = fake_buffer,
        .byteOffset = 0,
        .length = 512,
    };
    const new_view = webidl.ArrayBufferView{ .uint8_array = new_typed_array };
    const result = request.call_respondWithNewView(new_view);
    try std.testing.expectError(error.TypeError, result);
}
