// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Algorithm = @import("algorithm").Algorithm;
const Algorithms = @import("algorithms").Algorithms;
const Allocator = @import("std.mem").Allocator;
const Assert = @import("assert").Assert;
const Backpressure = @import("backpressure").Backpressure;
const CancelAlgorithm = @import("cancel_algorithm").CancelAlgorithm;
const Cast = @import("cast").Cast;
const CloseOrEnqueue = @import("close_or_enqueue").CloseOrEnqueue;
const Controller = @import("controller").Controller;
const DesiredSize = @import("desired_size").DesiredSize;
const Enqueue = @import("enqueue").Enqueue;
const Exception = @import("exception").Exception;
const FlushAlgorithm = @import("flush_algorithm").FlushAlgorithm;
const For = @import("for").For;
const Full = @import("full").Full;
const If = @import("if").If;
const Interface = @import("interface").Interface;
const Internal = @import("internal").Internal;
const JSValue = @import("j_s_value").JSValue;
const Let = @import("let").Let;
const Methods = @import("methods").Methods;
const Perform = @import("perform").Perform;
const Promise = @import("promise").Promise;
const ReadableStream = @import("readable_stream").ReadableStream;
const ReadableStreamDefaultControllerCanCloseOrEnqueue = @import("readable_stream_default_controller_can_close_or_enqueue").ReadableStreamDefaultControllerCanCloseOrEnqueue;
const ReadableStreamDefaultControllerClose = @import("readable_stream_default_controller_close").ReadableStreamDefaultControllerClose;
const ReadableStreamDefaultControllerEnqueue = @import("readable_stream_default_controller_enqueue").ReadableStreamDefaultControllerEnqueue;
const ReadableStreamDefaultControllerGetDesiredSize = @import("readable_stream_default_controller_get_desired_size").ReadableStreamDefaultControllerGetDesiredSize;
const ReadableStreamDefaultControllerHasBackpressure = @import("readable_stream_default_controller_has_backpressure").ReadableStreamDefaultControllerHasBackpressure;
const Rejected = @import("rejected").Rejected;
const Replace = @import("replace").Replace;
const Return = @import("return").Return;
const Size = @import("size").Size;
const Spec = @import("spec").Spec;
const Stream = @import("stream").Stream;
const Terminate = @import("terminate").Terminate;
const The = @import("the").The;
const Throw = @import("throw").Throw;
const Transform = @import("transform").Transform;
const TransformAlgorithm = @import("transform_algorithm").TransformAlgorithm;
const TransformStream = @import("transform_stream").TransformStream;
const TransformStreamDefaultControllerEnqueue = @import("transform_stream_default_controller_enqueue").TransformStreamDefaultControllerEnqueue;
const TransformStreamDefaultControllerError = @import("transform_stream_default_controller_error").TransformStreamDefaultControllerError;
const TransformStreamDefaultControllerPerformTransform = @import("transform_stream_default_controller_perform_transform").TransformStreamDefaultControllerPerformTransform;
const TransformStreamDefaultControllerTerminate = @import("transform_stream_default_controller_terminate").TransformStreamDefaultControllerTerminate;
const TransformStreamError = @import("transform_stream_error").TransformStreamError;
const TransformStreamErrorWritableAndUnblockWrite = @import("transform_stream_error_writable_and_unblock_write").TransformStreamErrorWritableAndUnblockWrite;
const TransformStreamSetBackpressure = @import("transform_stream_set_backpressure").TransformStreamSetBackpressure;
const TypeError = @import("type_error").TypeError;
const Value = @import("value").Value;
const WebIDL = @import("web_i_d_l").WebIDL;
const WritableAndUnblockWrite = @import("writable_and_unblock_write").WritableAndUnblockWrite;
const anyopaque = @import("anyopaque").anyopaque;
const common = @import("common").common;
const common.CancelAlgorithm = @import("common._cancel_algorithm").common.CancelAlgorithm;
const common.FlushAlgorithm = @import("common._flush_algorithm").common.FlushAlgorithm;
const common.Promise(void) = @import("common._promise(void)").common.Promise(void);
const common.TransformAlgorithm = @import("common._transform_algorithm").common.TransformAlgorithm;
const std = @import("std");
const std.mem.Allocator = @import("std.mem._allocator").std.mem.Allocator;
const webidl = @import("webidl");


pub const TransformStreamDefaultController = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    stream: ?*anyopaque,
    transformAlgorithm: common.TransformAlgorithm,
    flushAlgorithm: common.FlushAlgorithm,
    cancelAlgorithm: common.CancelAlgorithm,
    finishPromise: ?common.Promise(void),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        transformAlgorithm: common.TransformAlgorithm,
        flushAlgorithm: common.FlushAlgorithm,
        cancelAlgorithm: common.CancelAlgorithm,
    ) TransformStreamDefaultController {

        return .{
            .allocator = allocator,
            .stream = null,
            .transformAlgorithm = transformAlgorithm,
            .flushAlgorithm = flushAlgorithm,
            .cancelAlgorithm = cancelAlgorithm,
            .finishPromise = null,
        };
    
    }

    pub fn deinit(self: *TransformStreamDefaultController) void {
        self.transformAlgorithm.deinit();
        self.flushAlgorithm.deinit();
        self.cancelAlgorithm.deinit();
    }

    // ============================================================================
    // WebIDL Interface Methods
    // ============================================================================

    /// desiredSize getter
    ///
    /// Spec: § 6.2.3 "The desiredSize getter steps"
    pub fn get_desiredSize(self: *const TransformStreamDefaultController) ?f64 {
        // Spec step 1: Let readableController be this.[[stream]].[[readable]].[[controller]]
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));
        const readable_controller = stream.readableStream.controller;

        // Spec step 2: Return ! ReadableStreamDefaultControllerGetDesiredSize(readableController)
        return readable_controller.getDesiredSize();
    }

    /// enqueue(chunk) method
    ///
    /// Spec: § 6.2.3 "The enqueue(chunk) method steps"
    pub fn call_enqueue(self: *TransformStreamDefaultController, chunk: ?webidl.JSValue) !void {
        const chunk_value = if (chunk) |c| common.JSValue.fromWebIDL(c) else common.JSValue.undefined_value();
        // Spec step 1: Perform ? TransformStreamDefaultControllerEnqueue(this, chunk)
        try self.enqueueInternal(chunk_value);
    }

    /// error(e) method
    ///
    /// Spec: § 6.2.3 "The error(e) method steps"
    pub fn call_error(self: *TransformStreamDefaultController, e: ?webidl.JSValue) !void {
        const error_value = if (e) |err| common.JSValue.fromWebIDL(err) else common.JSValue.undefined_value();
        // Spec step 1: Perform ? TransformStreamDefaultControllerError(this, e)
        self.errorInternal(error_value);
    }

    /// terminate() method
    ///
    /// Spec: § 6.2.3 "The terminate() method steps"
    pub fn call_terminate(self: *TransformStreamDefaultController) !void {
        // Spec step 1: Perform ? TransformStreamDefaultControllerTerminate(this)
        try self.terminateInternal();
    }

    // ============================================================================
    // Internal Algorithms
    // ============================================================================

    /// TransformStreamDefaultControllerEnqueue(controller, chunk)
    ///
    /// Spec: § 6.3.2 "Enqueue chunk to readable side"
    pub fn enqueueInternal(self: *TransformStreamDefaultController, chunk: common.JSValue) !void {

        // Spec step 1: Let stream be controller.[[stream]]
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));

        // Spec step 2: Let readableController be stream.[[readable]].[[controller]]
        const readable_controller = stream.readableStream.controller;

        // Spec step 3: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) is false, throw TypeError
        if (!readable_controller.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        // Spec step 4: Let enqueueResult be ReadableStreamDefaultControllerEnqueue(readableController, chunk)
        readable_controller.enqueueInternal(chunk.toWebIDL()) catch |err| {
            // Spec step 5: If enqueueResult is an abrupt completion
            // Spec step 5.1: Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, enqueueResult.[[Value]])
            stream.errorWritableAndUnblockWrite(common.JSValue{ .string = "Enqueue failed" });
            // Spec step 5.2: Throw stream.[[readable]].[[storedError]]
            return err;
        };

        // Spec step 6: Let backpressure be ! ReadableStreamDefaultControllerHasBackpressure(readableController)
        const backpressure = readable_controller.hasBackpressure();

        // Spec step 7: If backpressure is not stream.[[backpressure]]
        if (backpressure != stream.backpressure) {
            // Spec step 7.1: Assert: backpressure is true
            std.debug.assert(backpressure);
            // Spec step 7.2: Perform ! TransformStreamSetBackpressure(stream, true)
            stream.setBackpressure(true);
        }
    
    }

    fn errorInternal(self: *TransformStreamDefaultController, error_value: common.JSValue) void {
        // Spec step 1: Perform ! TransformStreamError(controller.[[stream]], e)
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));
        stream.errorStream(error_value);
    }

    /// TransformStreamDefaultControllerTerminate(controller)
    ///
    /// Spec: § 6.3.2 "Terminate the transform stream"
    fn terminateInternal(self: *TransformStreamDefaultController) !void {

        // Spec step 1: Let stream be controller.[[stream]]
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));

        // Spec step 2: Let readableController be stream.[[readable]].[[controller]]
        const readable_controller = stream.readableStream.controller;

        // Spec step 3: Perform ! ReadableStreamDefaultControllerClose(readableController)
        readable_controller.closeInternal();

        // Spec step 4: Let error be a TypeError exception indicating that the stream has been terminated
        const error_value = common.JSValue{ .string = "Stream has been terminated" };

        // Spec step 5: Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, error)
        stream.errorWritableAndUnblockWrite(error_value);
    
    }

    pub fn clearAlgorithms(self: *TransformStreamDefaultController) void {
        self.transformAlgorithm.deinit();
        self.flushAlgorithm.deinit();
        self.cancelAlgorithm.deinit();

        // Replace with no-op algorithms
        self.transformAlgorithm = common.defaultTransformAlgorithm();
        self.flushAlgorithm = common.defaultFlushAlgorithm();
        self.cancelAlgorithm = common.defaultCancelAlgorithm();
    }

    /// TransformStreamDefaultControllerPerformTransform(controller, chunk)
    ///
    /// Spec: § 6.3.2 "Perform transform with error handling"
    pub fn performTransform(self: *TransformStreamDefaultController, chunk: common.JSValue) common.Promise(void) {

        // Spec step 1: Let transformPromise be the result of performing controller.[[transformAlgorithm]], passing chunk
        const transform_promise = self.transformAlgorithm.call(chunk);

        // Spec step 2: Return the result of reacting to transformPromise with rejection steps
        // For now, we return the promise directly (simplified)
        // Full implementation would add rejection handler that calls TransformStreamError

        // If the transform promise is rejected, error the stream
        if (transform_promise.isRejected()) {
            const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));
            const exception = transform_promise.error_value orelse webidl.errors.Exception.typeError(self.allocator, "Transform failed") catch return transform_promise;
            const error_value = common.JSValue{ .string = exception.toString() };
            stream.errorStream(error_value);
        }

        return transform_promise;
    
    }

};


