// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Algorithm = @import("algorithm").Algorithm;
const Allocator = std.mem.Allocator;
const Exception = @import("exception").Exception;
const JSValue = @import("j_s_value").JSValue;
const ReadableStream = @import("readable_stream").ReadableStream;
const Stream = @import("stream").Stream;
const TransformStream = @import("transform_stream").TransformStream;
const common = @import("common");
const std = @import("std");
const webidl = @import("webidl");


pub const TransformStreamDefaultController = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    stream: ?*anyopaque,
    transformAlgorithm: common.TransformAlgorithm,
    flushAlgorithm: common.FlushAlgorithm,
    cancelAlgorithm: common.CancelAlgorithm,
    finishPromise: ?common.Promise(void),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        transformAlgorithm: common.TransformAlgorithm,
        flushAlgorithm: common.FlushAlgorithm,
        cancelAlgorithm: common.CancelAlgorithm,
    ) TransformStreamDefaultController {

        return .{
            .allocator = allocator,
            .stream = null,
            .transformAlgorithm = transformAlgorithm,
            .flushAlgorithm = flushAlgorithm,
            .cancelAlgorithm = cancelAlgorithm,
            .finishPromise = null,
        };
    
    }

    pub fn deinit(self: *TransformStreamDefaultController) void {

        self.transformAlgorithm.deinit();
        self.flushAlgorithm.deinit();
        self.cancelAlgorithm.deinit();
    
    }

    pub fn get_desiredSize(self: *const TransformStreamDefaultController) ?f64 {

        // Spec step 1: Let readableController be this.[[stream]].[[readable]].[[controller]]
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));
        const readable_controller = stream.readableStream.controller;

        // Spec step 2: Return ! ReadableStreamDefaultControllerGetDesiredSize(readableController)
        return readable_controller.getDesiredSize();
    
    }

    pub fn call_enqueue(self: *TransformStreamDefaultController, chunk: ?webidl.JSValue) !void {

        const chunk_value = if (chunk) |c| common.JSValue.fromWebIDL(c) else common.JSValue.undefined_value();
        // Spec step 1: Perform ? TransformStreamDefaultControllerEnqueue(this, chunk)
        try self.enqueueInternal(chunk_value);
    
    }

    pub fn call_error(self: *TransformStreamDefaultController, e: ?webidl.JSValue) !void {

        const error_value = if (e) |err| common.JSValue.fromWebIDL(err) else common.JSValue.undefined_value();
        // Spec step 1: Perform ? TransformStreamDefaultControllerError(this, e)
        self.errorInternal(error_value);
    
    }

    pub fn call_terminate(self: *TransformStreamDefaultController) !void {

        // Spec step 1: Perform ? TransformStreamDefaultControllerTerminate(this)
        try self.terminateInternal();
    
    }

    pub fn enqueueInternal(self: *TransformStreamDefaultController, chunk: common.JSValue) !void {

        // Spec step 1: Let stream be controller.[[stream]]
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));

        // Spec step 2: Let readableController be stream.[[readable]].[[controller]]
        const readable_controller = stream.readableStream.controller;

        // Spec step 3: If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) is false, throw TypeError
        if (!readable_controller.canCloseOrEnqueue()) {
            return error.TypeError;
        }

        // Spec step 4: Let enqueueResult be ReadableStreamDefaultControllerEnqueue(readableController, chunk)
        readable_controller.enqueueInternal(chunk.toWebIDL()) catch |err| {
            // Spec step 5: If enqueueResult is an abrupt completion
            // Spec step 5.1: Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, enqueueResult.[[Value]])
            stream.errorWritableAndUnblockWrite(common.JSValue{ .string = "Enqueue failed" });
            // Spec step 5.2: Throw stream.[[readable]].[[storedError]]
            return err;
        };

        // Spec step 6: Let backpressure be ! ReadableStreamDefaultControllerHasBackpressure(readableController)
        const backpressure = readable_controller.hasBackpressure();

        // Spec step 7: If backpressure is not stream.[[backpressure]]
        if (backpressure != stream.backpressure) {
            // Spec step 7.1: Assert: backpressure is true
            std.debug.assert(backpressure);
            // Spec step 7.2: Perform ! TransformStreamSetBackpressure(stream, true)
            stream.setBackpressure(true);
        }
    
    }

    fn errorInternal(self: *TransformStreamDefaultController, error_value: common.JSValue) void {

        // Spec step 1: Perform ! TransformStreamError(controller.[[stream]], e)
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));
        stream.errorStream(error_value);
    
    }

    fn terminateInternal(self: *TransformStreamDefaultController) !void {

        // Spec step 1: Let stream be controller.[[stream]]
        const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));

        // Spec step 2: Let readableController be stream.[[readable]].[[controller]]
        const readable_controller = stream.readableStream.controller;

        // Spec step 3: Perform ! ReadableStreamDefaultControllerClose(readableController)
        readable_controller.closeInternal();

        // Spec step 4: Let error be a TypeError exception indicating that the stream has been terminated
        const error_value = common.JSValue{ .string = "Stream has been terminated" };

        // Spec step 5: Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, error)
        stream.errorWritableAndUnblockWrite(error_value);
    
    }

    pub fn clearAlgorithms(self: *TransformStreamDefaultController) void {

        self.transformAlgorithm.deinit();
        self.flushAlgorithm.deinit();
        self.cancelAlgorithm.deinit();

        // Replace with no-op algorithms
        self.transformAlgorithm = common.defaultTransformAlgorithm();
        self.flushAlgorithm = common.defaultFlushAlgorithm();
        self.cancelAlgorithm = common.defaultCancelAlgorithm();
    
    }

    pub fn performTransform(self: *TransformStreamDefaultController, chunk: common.JSValue) common.Promise(void) {

        // Spec step 1: Let transformPromise be the result of performing controller.[[transformAlgorithm]], passing chunk
        const transform_promise = self.transformAlgorithm.call(chunk);

        // Spec step 2: Return the result of reacting to transformPromise with rejection steps
        // For now, we return the promise directly (simplified)
        // Full implementation would add rejection handler that calls TransformStreamError

        // If the transform promise is rejected, error the stream
        if (transform_promise.isRejected()) {
            const stream: *TransformStream = @ptrCast(@alignCast(self.stream.?));
            const exception = transform_promise.error_value orelse webidl.errors.Exception.typeError(self.allocator, "Transform failed") catch return transform_promise;
            const error_value = common.JSValue{ .string = exception.toString() };
            stream.errorStream(error_value);
        }

        return transform_promise;
    
    }

};


