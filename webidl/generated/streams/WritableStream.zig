// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const AsyncPromise = @import("async_promise").AsyncPromise;
const Event = @import("event").Event;
const TestEventLoop = @import("test_event_loop").TestEventLoop;
const WritableStreamDefaultController = @import("writable_stream_default_controller").WritableStreamDefaultController;
const WritableStreamDefaultWriter = @import("writable_stream_default_writer").WritableStreamDefaultWriter;
const common = @import("common").common;
const dict_parsing = @import("dict_parsing").dict_parsing;
const eventLoop = @import("event_loop").eventLoop;
const std = @import("std");
const structured_clone = @import("structured_clone").structured_clone;
const webidl = @import("webidl");

pub const WritableStream = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    backpressure: bool,
    closeRequest: ?*AsyncPromise(void),
    controller: *WritableStreamDefaultController,
    detached: bool,
    inFlightWriteRequest: ?*AsyncPromise(void),
    inFlightCloseRequest: ?*AsyncPromise(void),
    pendingAbortRequest: ?AbortRequest,
    state: StreamState,
    storedError: ?common.JSValue,
    writer: Writer,
    writeRequests: std.ArrayList(*AsyncPromise(void)),
    eventLoop: eventLoop.EventLoop,
    eventLoop_storage: ?*TestEventLoop,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !WritableStream {

        const loop_ptr = try allocator.create(TestEventLoop);
        errdefer allocator.destroy(loop_ptr);

        loop_ptr.* = TestEventLoop.init(allocator);

        var stream = try initWithSink(allocator, loop_ptr.eventLoop(), null, null);
        stream.eventLoop_storage = loop_ptr;

        return stream;
    
    }

    pub fn deinit(self: *WritableStream) void {

        self.controller.deinit();
        self.allocator.destroy(self.controller);

        self.writeRequests.deinit(self.allocator);

        switch (self.writer) {
            .default => |w| {
                w.deinit();
                self.allocator.destroy(w);
            },
            .none => {},
        }

        if (self.eventLoop_storage) |loop_ptr| {
            loop_ptr.deinit();
            self.allocator.destroy(loop_ptr);
        }
    
    }

    pub fn initWithSink(
        allocator: std.mem.Allocator,
        loop: eventLoop.EventLoop,
        underlyingSink: ?webidl.JSValue,
        strategy: ?webidl.JSValue,
    ) !WritableStream {

        const sink_dict = try dict_parsing.parseUnderlyingSink(allocator, underlyingSink);
        const strategy_dict = try dict_parsing.parseQueuingStrategy(allocator, strategy);

        const highWaterMark = strategy_dict.high_water_mark orelse 1.0;
        const size_algorithm = if (strategy_dict.size) |size_fn|
            common.wrapGenericSizeCallback(size_fn)
        else
            common.defaultSizeAlgorithm();

        const abortAlgorithm = if (sink_dict.abort) |abort_fn|
            common.wrapGenericAbortCallback(abort_fn)
        else
            common.defaultAbortAlgorithm();

        const closeAlgorithm = if (sink_dict.close) |close_fn|
            common.wrapGenericCloseCallback(close_fn)
        else
            common.defaultCloseAlgorithm();

        const writeAlgorithm = if (sink_dict.write) |write_fn|
            common.wrapGenericWriteCallback(write_fn)
        else
            common.defaultWriteAlgorithm();

        const controller = try allocator.create(WritableStreamDefaultController);
        errdefer allocator.destroy(controller);

        controller.* = try WritableStreamDefaultController.init(
            allocator,
            abortAlgorithm,
            closeAlgorithm,
            writeAlgorithm,
            highWaterMark,
            size_algorithm,
            loop,
        );

        var stream = WritableStream{
            .allocator = allocator,
            .backpressure = false,
            .closeRequest = null,
            .controller = controller,
            .detached = false,
            .inFlightWriteRequest = null,
            .inFlightCloseRequest = null,
            .pendingAbortRequest = null,
            .state = .writable,
            .storedError = null,
            .writer = .none,
            .writeRequests = std.ArrayList(*AsyncPromise(void)){},
            .eventLoop = loop,
            .eventLoop_storage = null,
        };

        stream.controller.stream = @ptrCast(&stream);
        stream.controller.started = true;

        return stream;
    
    }

    pub fn get_locked(self: *const WritableStream) bool {

        return self.writer != .none;
    
    }

    pub fn call_abort(self: *WritableStream, reason: ?webidl.JSValue) !*AsyncPromise(void) {

        if (self.get_locked()) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Stream is locked"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        const reason_value = if (reason) |r| common.JSValue.fromWebIDL(r) else null;
        return self.abortInternal(reason_value);
    
    }

    pub fn call_close(self: *WritableStream) !*AsyncPromise(void) {

        if (self.get_locked()) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Stream is locked"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        if (self.state == .closed or self.state == .errored) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Stream is already closed or errored"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        return self.closeInternal();
    
    }

    pub fn call_getWriter(self: *WritableStream) !*WritableStreamDefaultWriter {

        return self.acquireDefaultWriter(self.eventLoop);
    
    }

    pub fn transferSteps(self: *WritableStream) !*structured_clone.SerializedData {

        const cross_realm_transform = @import("cross_realm_transform");
        const message_port = @import("message_port");
        const ReadableStream = @import("readable_stream").ReadableStream;

        // Spec step 1: If ! IsWritableStreamLocked(value) is true, throw DataCloneError
        if (self.writer != .none) {
            return error.DataCloneError;
        }

        // Spec step 2-3: Create MessagePort pair
        const ports = try message_port.createMessagePortPair(self.allocator);
        const port1 = ports[0];
        const port2 = ports[1];

        // Spec step 4: Entangle (already done in createMessagePortPair)

        // Spec step 5: Create ReadableStream in current realm
        var readable = try ReadableStream.init(self.allocator);
        errdefer readable.deinit();

        // Spec step 6: SetUpCrossRealmTransformReadable(readable, port1)
        try cross_realm_transform.setupCrossRealmTransformReadable(self.allocator, &readable, port1);

        // Spec step 7: Let promise = ! ReadableStreamPipeTo(readable, value, false, false, false)
        // Note: We're not awaiting the promise - it runs in the background
        _ = try readable.call_pipeTo(self, .{ .preventClose = false, .preventAbort = false, .preventCancel = false, .signal = null });

        // Spec step 8: Set promise.[[PromiseIsHandled]] to true
        // (Promise error handling is internal to pipeTo)

        // Spec step 9: Serialize port2 with transfer
        const serialized = try structured_clone.structuredSerializeWithTransfer(self.allocator, port2);

        return serialized;
    
    }

    pub fn transferReceivingSteps(
        self: *WritableStream,
        serialized: *structured_clone.SerializedData,
    ) !void {

        const cross_realm_transform = @import("cross_realm_transform");

        // Spec step 1: Let deserializedRecord = ! StructuredDeserializeWithTransfer(dataHolder.[[port]], current Realm)
        const deserialized = try structured_clone.structuredDeserializeWithTransfer(self.allocator, serialized);

        // Spec step 2: Let port = deserializedRecord.[[Deserialized]]
        const port = deserialized.port;

        // Spec step 3: Perform ! SetUpCrossRealmTransformWritable(value, port)
        try cross_realm_transform.setupCrossRealmTransformWritable(self.allocator, self, port);
    
    }

    pub fn acquireDefaultWriter(self: *WritableStream, loop: eventLoop.EventLoop) !*WritableStreamDefaultWriter {

        const writer = try self.allocator.create(WritableStreamDefaultWriter);
        errdefer self.allocator.destroy(writer);

        writer.* = try WritableStreamDefaultWriter.init(self.allocator, self, loop);
        self.writer = .{ .default = writer };

        return writer;
    
    }

    pub fn errorInternal(self: *WritableStream, e: common.JSValue) void {

        if (self.state == .closed or self.state == .errored) {
            return;
        }
        self.state = .errored;
        self.storedError = e;
    
    }

    pub fn startErroring(self: *WritableStream, reason: common.JSValue) void {

        // Spec step 1: Assert: stream.[[storedError]] is undefined
        std.debug.assert(self.storedError == null);

        // Spec step 2: Assert: stream.[[state]] is "writable"
        std.debug.assert(self.state == .writable);

        // Spec step 5: Set stream.[[state]] to "erroring"
        self.state = .erroring;

        // Spec step 6: Set stream.[[storedError]] to reason
        self.storedError = reason;

        // Spec step 7-8: Reject writer's ready promise if writer exists
        const reason_exception = reason.toException(self.allocator) catch return;
        switch (self.writer) {
            .none => {},
            .default => |writer| {
                // Spec step 8: Perform ! WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason)
                if (writer.readyPromise) |ready| {
                    ready.reject(reason_exception);
                }
            },
        }

        // Spec step 9: If no operation in flight and controller is started, finish erroring immediately
        if (!self.hasOperationMarkedInFlight() and self.controller.started) {
            self.finishErroring();
        }
    
    }

};


