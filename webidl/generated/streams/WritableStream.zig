// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortRequest = @import("abort_request").AbortRequest;
const Allocator = std.mem.Allocator;
const AsyncPromise = @import("async_promise").AsyncPromise;
const Controller = @import("controller").Controller;
const JSValue = @import("j_s_value").JSValue;
const Loop = @import("loop").Loop;
const Promise = @import("promise").Promise;
const Requests = @import("requests").Requests;
const TestEventLoop = @import("test_event_loop").TestEventLoop;
const WritableStreamDefaultController = @import("writable_stream_default_controller").WritableStreamDefaultController;
const WritableStreamDefaultWriter = @import("writable_stream_default_writer").WritableStreamDefaultWriter;
const common = @import("common");
const dict_parsing = @import("dict_parsing");
const eventLoop = @import("event_loop");
const std = @import("std");
const structured_clone = @import("structured_clone");
const webidl = @import("webidl");


/// Stream state enumeration
///
/// Spec: ยง 5.1 "Internal slots" - [[state]]
pub const StreamState = enum {
    writable,
    closed,
    erroring,
    errored,
};

/// Writer type for a writable stream (optional)
pub const Writer = union(enum) {
    none: void,
    default: *WritableStreamDefaultWriter,
};

pub const WritableStream = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    backpressure: bool,
    closeRequest: ?*AsyncPromise(void),
    controller: *WritableStreamDefaultController,
    detached: bool,
    inFlightWriteRequest: ?*AsyncPromise(void),
    inFlightCloseRequest: ?*AsyncPromise(void),
    pendingAbortRequest: ?AbortRequest,
    state: StreamState,
    storedError: ?common.JSValue,
    writer: Writer,
    writeRequests: std.ArrayList(*AsyncPromise(void)),
    eventLoop: eventLoop.EventLoop,
    eventLoop_storage: ?*TestEventLoop,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !WritableStream {

        const loop_ptr = try allocator.create(TestEventLoop);
        errdefer allocator.destroy(loop_ptr);

        loop_ptr.* = TestEventLoop.init(allocator);

        var stream = try initWithSink(allocator, loop_ptr.eventLoop(), null, null);
        stream.eventLoop_storage = loop_ptr;

        return stream;
    
    }

    pub fn deinit(self: *WritableStream) void {

        self.controller.deinit();
        self.allocator.destroy(self.controller);

        self.writeRequests.deinit(self.allocator);

        switch (self.writer) {
            .default => |w| {
                w.deinit();
                self.allocator.destroy(w);
            },
            .none => {},
        }

        if (self.eventLoop_storage) |loop_ptr| {
            loop_ptr.deinit();
            self.allocator.destroy(loop_ptr);
        }
    
    }

    pub fn initWithSink(
        allocator: std.mem.Allocator,
        loop: eventLoop.EventLoop,
        underlyingSink: ?webidl.JSValue,
        strategy: ?webidl.JSValue,
    ) !WritableStream {

        const sink_dict = try dict_parsing.parseUnderlyingSink(allocator, underlyingSink);
        const strategy_dict = try dict_parsing.parseQueuingStrategy(allocator, strategy);

        const highWaterMark = strategy_dict.high_water_mark orelse 1.0;
        const size_algorithm = if (strategy_dict.size) |size_fn|
            common.wrapGenericSizeCallback(size_fn)
        else
            common.defaultSizeAlgorithm();

        const abortAlgorithm = if (sink_dict.abort) |abort_fn|
            common.wrapGenericAbortCallback(abort_fn)
        else
            common.defaultAbortAlgorithm();

        const closeAlgorithm = if (sink_dict.close) |close_fn|
            common.wrapGenericCloseCallback(close_fn)
        else
            common.defaultCloseAlgorithm();

        const writeAlgorithm = if (sink_dict.write) |write_fn|
            common.wrapGenericWriteCallback(write_fn)
        else
            common.defaultWriteAlgorithm();

        const controller = try allocator.create(WritableStreamDefaultController);
        errdefer allocator.destroy(controller);

        controller.* = try WritableStreamDefaultController.init(
            allocator,
            abortAlgorithm,
            closeAlgorithm,
            writeAlgorithm,
            highWaterMark,
            size_algorithm,
            loop,
        );

        var stream = WritableStream{
            .allocator = allocator,
            .backpressure = false,
            .closeRequest = null,
            .controller = controller,
            .detached = false,
            .inFlightWriteRequest = null,
            .inFlightCloseRequest = null,
            .pendingAbortRequest = null,
            .state = .writable,
            .storedError = null,
            .writer = .none,
            .writeRequests = std.ArrayList(*AsyncPromise(void)){},
            .eventLoop = loop,
            .eventLoop_storage = null,
        };

        stream.controller.stream = @ptrCast(&stream);
        stream.controller.started = true;

        return stream;
    
    }

    pub fn get_locked(self: *const WritableStream) bool {

        return self.writer != .none;
    
    }

    pub fn call_abort(self: *WritableStream, reason: ?webidl.JSValue) !*AsyncPromise(void) {

        if (self.get_locked()) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Stream is locked"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        const reason_value = if (reason) |r| common.JSValue.fromWebIDL(r) else null;
        return self.abortInternal(reason_value);
    
    }

    pub fn call_close(self: *WritableStream) !*AsyncPromise(void) {

        if (self.get_locked()) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Stream is locked"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        if (self.state == .closed or self.state == .errored) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Stream is already closed or errored"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        return self.closeInternal();
    
    }

    pub fn call_getWriter(self: *WritableStream) !*WritableStreamDefaultWriter {

        return self.acquireDefaultWriter(self.eventLoop);
    
    }

    pub fn transferSteps(self: *WritableStream) !*structured_clone.SerializedData {
        const cross_realm_transform = @import("cross_realm_transform");
        const message_port = @import("message_port");
        const ReadableStream = @import("readable_stream").ReadableStream;

        // Spec step 1: If ! IsWritableStreamLocked(value) is true, throw DataCloneError
        if (self.writer != .none) {
            return error.DataCloneError;
        }

        // Spec step 2-3: Create MessagePort pair
        const ports = try message_port.createMessagePortPair(self.allocator);
        const port1 = ports[0];
        const port2 = ports[1];

        // Spec step 4: Entangle (already done in createMessagePortPair)

        // Spec step 5: Create ReadableStream in current realm
        var readable = try ReadableStream.init(self.allocator);
        errdefer readable.deinit();

        // Spec step 6: SetUpCrossRealmTransformReadable(readable, port1)
        try cross_realm_transform.setupCrossRealmTransformReadable(self.allocator, &readable, port1);

        // Spec step 7: Let promise = ! ReadableStreamPipeTo(readable, value, false, false, false)
        // Note: We're not awaiting the promise - it runs in the background
        _ = try readable.call_pipeTo(self, .{ .preventClose = false, .preventAbort = false, .preventCancel = false, .signal = null });

        // Spec step 8: Set promise.[[PromiseIsHandled]] to true
        // (Promise error handling is internal to pipeTo)

        // Spec step 9: Serialize port2 with transfer
        const serialized = try structured_clone.structuredSerializeWithTransfer(self.allocator, port2);

        return serialized;
    }

    /// [[TransferReceivingSteps]](dataHolder)
    ///
    /// Spec: ยง 5.2.5 "Transfer" (transfer-receiving steps)
    /// https://streams.spec.whatwg.org/#ws-transfer
    ///
    /// Steps for receiving a transferred WritableStream in another realm.
    /// Deserializes the MessagePort and sets up a stream that writes to it.
    pub fn transferReceivingSteps(
        self: *WritableStream,
        serialized: *structured_clone.SerializedData,
    ) !void {

        const cross_realm_transform = @import("cross_realm_transform");

        // Spec step 1: Let deserializedRecord = ! StructuredDeserializeWithTransfer(dataHolder.[[port]], current Realm)
        const deserialized = try structured_clone.structuredDeserializeWithTransfer(self.allocator, serialized);

        // Spec step 2: Let port = deserializedRecord.[[Deserialized]]
        const port = deserialized.port;

        // Spec step 3: Perform ! SetUpCrossRealmTransformWritable(value, port)
        try cross_realm_transform.setupCrossRealmTransformWritable(self.allocator, self, port);
    
    }

    fn abortInternal(self: *WritableStream, reason: ?common.JSValue) !*AsyncPromise(void) {

        // Spec step 1: If stream.[[state]] is "closed" or "errored", return fulfilled promise
        if (self.state == .closed or self.state == .errored) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            promise.fulfill({});
            return promise;
        }

        // Spec step 2: Signal abort on stream.[[controller]].[[abortController]] with reason
        const reason_exception = if (reason) |r| try r.toException(self.allocator) else null;
        self.controller.abortController.call_abort(reason_exception);

        // Spec step 3: Let state be stream.[[state]]
        const state = self.state;

        // Spec step 4: If state is "closed" or "errored", return fulfilled promise
        // (Re-check because signaling abort runs author code and may change state)
        if (state == .closed or state == .errored) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            promise.fulfill({});
            return promise;
        }

        // Spec step 5: If stream.[[pendingAbortRequest]] is not undefined, return its promise
        if (self.pendingAbortRequest) |existing_abort| {
            return existing_abort.promise;
        }

        // Spec step 6: Assert: state is "writable" or "erroring"
        std.debug.assert(state == .writable or state == .erroring);

        // Spec step 7: Let wasAlreadyErroring be false
        var was_already_erroring = false;

        // Spec step 8: If state is "erroring"
        var abort_reason = reason;
        if (state == .erroring) {
            // Spec step 8.1: Set wasAlreadyErroring to true
            was_already_erroring = true;
            // Spec step 8.2: Set reason to undefined
            abort_reason = null;
        }

        // Spec step 9: Let promise be a new promise
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);

        // Spec step 10: Set stream.[[pendingAbortRequest]] to new abort request
        self.pendingAbortRequest = AbortRequest{
            .promise = promise,
            .reason = abort_reason,
            .wasAlreadyErroring = was_already_erroring,
        };

        // Spec step 11: If wasAlreadyErroring is false, perform ! WritableStreamStartErroring(stream, reason)
        if (!was_already_erroring) {
            self.startErroring(abort_reason orelse common.JSValue.undefined_value());
        }

        // Spec step 12: Return promise
        return promise;
    
    }

    fn closeInternal(self: *WritableStream) !*AsyncPromise(void) {

        // Spec step 1: Let state be stream.[[state]]
        const state = self.state;

        // Spec step 2: If state is "closed" or "errored", return rejected promise with TypeError
        if (state == .closed or state == .errored) {
            const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
            const exception = webidl.errors.Exception{
                .simple = .{
                    .type = .TypeError,
                    .message = try self.allocator.dupe(u8, "Cannot close a closed or errored stream"),
                },
            };
            promise.reject(exception);
            return promise;
        }

        // Spec step 3: Assert: state is "writable" or "erroring"
        std.debug.assert(state == .writable or state == .erroring);

        // Spec step 4: Assert: ! WritableStreamCloseQueuedOrInFlight(stream) is false
        std.debug.assert(!self.closeQueuedOrInFlight());

        // Spec step 5: Let promise be a new promise
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);

        // Spec step 6: Set stream.[[closeRequest]] to promise
        self.closeRequest = promise;

        // Spec step 7: Let writer be stream.[[writer]]
        // Spec step 8: If writer is not undefined, and stream.[[backpressure]] is true, and state is "writable",
        //              resolve writer.[[readyPromise]] with undefined
        if (state == .writable and self.backpressure) {
            switch (self.writer) {
                .none => {},
                .default => |writer| {
                    if (writer.readyPromise) |ready| {
                        ready.fulfill({});
                    }
                },
            }
        }

        // Spec step 9: Perform ! WritableStreamDefaultControllerClose(stream.[[controller]])
        self.controller.closeInternal();

        // Spec step 10: Return promise
        return promise;
    
    }

    fn closeQueuedOrInFlight(self: *const WritableStream) bool {

        // Spec step 1-2: If closeRequest or inFlightCloseRequest is undefined, return false; else true
        return self.closeRequest != null or self.inFlightCloseRequest != null;
    
    }

    pub fn acquireDefaultWriter(self: *WritableStream, loop: eventLoop.EventLoop) !*WritableStreamDefaultWriter {

        const writer = try self.allocator.create(WritableStreamDefaultWriter);
        errdefer self.allocator.destroy(writer);

        writer.* = try WritableStreamDefaultWriter.init(self.allocator, self, loop);
        self.writer = .{ .default = writer };

        return writer;
    
    }

    pub fn errorInternal(self: *WritableStream, e: common.JSValue) void {

        if (self.state == .closed or self.state == .errored) {
            return;
        }
        self.state = .errored;
        self.storedError = e;
    
    }

    fn hasOperationMarkedInFlight(self: *const WritableStream) bool {

        // Spec step 1-2: If inFlightWriteRequest or inFlightCloseRequest is undefined, return false; else true
        return self.inFlightWriteRequest != null or self.inFlightCloseRequest != null;
    
    }

    fn rejectCloseAndClosedPromiseIfNeeded(self: *WritableStream) void {

        // Spec step 1: Assert: stream.[[state]] is "errored"
        std.debug.assert(self.state == .errored);

        const stored_error = self.storedError orelse common.JSValue.undefined_value();
        const stored_exception = stored_error.toException(self.allocator) catch return;

        // Spec step 2-3: Reject closeRequest if present
        if (self.closeRequest) |close_req| {
            std.debug.assert(self.inFlightCloseRequest == null);
            close_req.reject(stored_exception);
            self.closeRequest = null;
        }

        // Spec step 4: If writer is not undefined
        switch (self.writer) {
            .none => {},
            .default => |writer| {
                // Spec step 4.1: Reject writer.[[closedPromise]] with storedError
                writer.closedPromise.reject(stored_exception);
                // Spec step 4.2: Set writer.[[closedPromise]].[[PromiseIsHandled]] to true
                // (In production, this prevents unhandled rejection warnings)
            },
        }
    
    }

    pub fn startErroring(self: *WritableStream, reason: common.JSValue) void {

        // Spec step 1: Assert: stream.[[storedError]] is undefined
        std.debug.assert(self.storedError == null);

        // Spec step 2: Assert: stream.[[state]] is "writable"
        std.debug.assert(self.state == .writable);

        // Spec step 5: Set stream.[[state]] to "erroring"
        self.state = .erroring;

        // Spec step 6: Set stream.[[storedError]] to reason
        self.storedError = reason;

        // Spec step 7-8: Reject writer's ready promise if writer exists
        const reason_exception = reason.toException(self.allocator) catch return;
        switch (self.writer) {
            .none => {},
            .default => |writer| {
                // Spec step 8: Perform ! WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason)
                if (writer.readyPromise) |ready| {
                    ready.reject(reason_exception);
                }
            },
        }

        // Spec step 9: If no operation in flight and controller is started, finish erroring immediately
        if (!self.hasOperationMarkedInFlight() and self.controller.started) {
            self.finishErroring();
        }
    
    }

    fn finishErroring(self: *WritableStream) void {

        // Spec step 1: Assert: stream.[[state]] is "erroring"
        std.debug.assert(self.state == .erroring);

        // Spec step 2: Assert: ! WritableStreamHasOperationMarkedInFlight(stream) is false
        std.debug.assert(!self.hasOperationMarkedInFlight());

        // Spec step 3: Set stream.[[state]] to "errored"
        self.state = .errored;

        // Spec step 4: Perform ! stream.[[controller]].[[ErrorSteps]]()
        self.controller.errorSteps();

        const stored_error = self.storedError orelse common.JSValue.undefined_value();
        const stored_exception = stored_error.toException(self.allocator) catch return;

        // Spec step 6-7: Reject all pending write requests
        while (self.writeRequests.items.len > 0) {
            const write_request = self.writeRequests.orderedRemove(0);
            write_request.reject(stored_exception);
        }

        // Spec step 8: If pendingAbortRequest is undefined
        if (self.pendingAbortRequest == null) {
            // Spec step 8.1-8.2: Reject close and return
            self.rejectCloseAndClosedPromiseIfNeeded();
            return;
        }

        // Spec step 9-10: Get and clear pendingAbortRequest
        const abort_request = self.pendingAbortRequest.?;
        self.pendingAbortRequest = null;

        // Spec step 11: If wasAlreadyErroring is true
        if (abort_request.wasAlreadyErroring) {
            // Spec step 11.1: Reject abortRequest's promise
            abort_request.promise.reject(stored_exception);
            // Spec step 11.2: Reject close and return
            self.rejectCloseAndClosedPromiseIfNeeded();
            return;
        }

        // Spec step 12: Let promise be ! stream.[[controller]].[[AbortSteps]](abortRequest's reason)
        const abort_result = self.controller.abortSteps(abort_request.reason);

        // Spec step 13: Upon fulfillment
        if (abort_result.isFulfilled()) {
            // Spec step 13.1: Resolve abortRequest's promise with undefined
            abort_request.promise.fulfill({});
            // Spec step 13.2: Reject close
            self.rejectCloseAndClosedPromiseIfNeeded();
        } else if (abort_result.isRejected()) {
            // Spec step 14: Upon rejection with reason
            // Spec step 14.1: Reject abortRequest's promise with reason
            const err_exception = abort_result.error_value orelse webidl.Exception{ .simple = .{ .type = .TypeError, .message = "Abort failed" } };
            abort_request.promise.reject(err_exception);
            // Spec step 14.2: Reject close
            self.rejectCloseAndClosedPromiseIfNeeded();
        }
        // Note: If promise is pending, we would need to add fulfillment/rejection handlers
        // For simplicity, we handle synchronous completion here
    
    }

};


