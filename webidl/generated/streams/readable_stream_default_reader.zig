// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! ReadableStreamDefaultReader class per WHATWG Streams Standard
//!
//! Spec: https://streams.spec.whatwg.org/#default-reader-class
//! IDL: specs/streams.idl lines 69-76
//!
//! Allows reading chunks from a ReadableStream.

const std = @import("std");

const webidl = @import("webidl");
const common = @import("common");
const ReadRequest = @import("read_request").ReadRequest;
const eventLoop = @import("eventLoop");
const AsyncPromise = @import("async_promise").AsyncPromise;

/// Import ReadableStream for calling its methods
/// We can't import the type directly due to circular dependency,
/// so we use @import and access it through the module
const readableStream_mod = @import("readableStream");
const ReadableStream = readableStream_mod.ReadableStream;
/// ReadableStreamDefaultReader WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface ReadableStreamDefaultReader {
/// constructor(ReadableStream stream);
/// 
/// Promise<ReadableStreamReadResult> read();
/// undefined releaseLock();
/// };
/// ReadableStreamDefaultReader includes ReadableStreamGenericReader;
/// 
/// interface mixin ReadableStreamGenericReader {
/// readonly attribute Promise<undefined> closed;
/// 
/// Promise<undefined> cancel(optional any reason);
/// };
/// ```
pub const ReadableStreamDefaultReader = struct {
    allocator: std.mem.Allocator,
    /// Event loop for async operations
    eventLoop: eventLoop.EventLoop,
    /// [[closedPromise]]: Promise that fulfills when stream closes
    /// Async promise that resolves when stream closes or rejects on error
    closedPromise: *AsyncPromise(void),
    /// [[stream]]: The ReadableStream being read from (or undefined if released)
    stream: ?*ReadableStream,
    /// [[readRequests]]: List of pending read requests (async promises)
    /// Changed from ArrayList(ReadRequest) to support async operations
    readRequests: std.ArrayList(*AsyncPromise(common.ReadResult)),

    /// Initialize a new default reader (internal - not exposed via WebIDL)
    pub fn init(
        allocator: std.mem.Allocator,
        stream: *ReadableStream,
        loop: eventLoop.EventLoop,
    ) !ReadableStreamDefaultReader {
        // Spec: § 4.3.4 "SetUpReadableStreamDefaultReader(reader, stream)"
        // Initialize closed promise as pending
        const closedPromise = try AsyncPromise(void).init(allocator, loop);

        return .{
            .allocator = allocator,
            .eventLoop = loop,
            .closedPromise = closedPromise,
            .stream = stream,
            .readRequests = std.ArrayList(*AsyncPromise(common.ReadResult)){},
        };
    }
    pub fn deinit(self: *ReadableStreamDefaultReader) void {
        // Promises (closedPromise) are allocated from the event loop's arena.
        // The promise memory and reactions will be freed when the event loop is destroyed.
        // We do NOT call deinit() here to avoid double-free or use-after-free issues.
        // This matches browser semantics where promises are garbage collected.

        // Note: readRequests promises are owned by callers, just clear the list
        self.readRequests.deinit(self.allocator);
    }
    /// Returns a promise that fulfills when the stream closes or rejects if it errors.
    /// 
    /// IDL: readonly attribute Promise<undefined> closed;
    /// 
    /// Spec algorithm: § 4.2.3 "The closed getter steps are:"
    pub fn get_closed(self: *const ReadableStreamDefaultReader) webidl.Promise(void) {
        // Step 1: Return this.[[closedPromise]].
        // Convert async promise to webidl promise
        if (self.closedPromise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else if (self.closedPromise.isRejected()) {
            // Convert internal JSValue error to string for webidl Promise
            const err_str = switch (self.closedPromise.state.rejected) {
                .string => |s| s,
                else => "Unknown error",
            };
            return webidl.Promise(void).rejected(err_str);
        } else {
            return webidl.Promise(void).pending();
        }
    }
    /// Cancels the stream with the given reason.
    /// 
    /// IDL: Promise<undefined> cancel(optional any reason);
    /// 
    /// Spec algorithm: § 4.2.3 "The cancel(reason) method steps are:"
    pub fn call_cancel(self: *ReadableStreamDefaultReader, reason: webidl.Optional(webidl.JSValue)) webidl.Promise(void) {
        // Step 1: If this.[[stream]] is undefined, return a promise rejected with a TypeError exception.
        if (self.stream == null) {
            return webidl.Promise(void).rejected("Reader released");
        }

        const reason_value = if (reason.was_passed)
            common.JSValue.fromWebIDL(reason.value)
        else
            null;

        // Step 2: Return ! ReadableStreamReaderGenericCancel(this, reason).
        const internal_promise = self.genericCancel(reason_value) catch {
            return webidl.Promise(void).rejected("Failed to cancel");
        };
        defer internal_promise.deinit();

        // Convert async promise to webidl promise
        if (internal_promise.isFulfilled()) {
            return webidl.Promise(void).fulfilled({});
        } else if (internal_promise.isRejected()) {
            // Convert internal JSValue error to string for webidl Promise
            const err_str = switch (internal_promise.state.rejected) {
                .string => |s| s,
                else => "Unknown error",
            };
            return webidl.Promise(void).rejected(err_str);
        } else {
            return webidl.Promise(void).pending();
        }
    }
    /// Reads the next chunk from the stream (ASYNC VERSION).
    /// 
    /// IDL: Promise<ReadableStreamReadResult> read();
    /// 
    /// Spec algorithm: § 4.3.3 "The read() method steps are:"
    /// 
    /// Returns an AsyncPromise that will be fulfilled when data arrives
    /// or rejected if the stream errors. The promise is PENDING if no
    /// data is immediately available.
    /// 
    /// **IMPORTANT**: Caller owns the returned promise and must call deinit()
    pub fn call_read(self: *ReadableStreamDefaultReader) !*AsyncPromise(common.ReadResult) {
        // Step 1: If this.[[stream]] is undefined, return a promise rejected with a TypeError exception.
        if (self.stream == null) {
            const promise = try AsyncPromise(common.ReadResult).init(
                self.allocator,
                self.eventLoop,
            );
            promise.reject(common.JSValue{ .string = "Reader released" });
            return promise;
        }

        // Step 2: Return ! ReadableStreamDefaultReaderRead(this).
        return self.readInternal();
    }
    /// Releases the reader's lock on the stream.
    /// 
    /// IDL: undefined releaseLock();
    /// 
    /// Spec algorithm: § 4.3.3 "The releaseLock() method steps are:"
    pub fn call_releaseLock(self: *ReadableStreamDefaultReader) void {
        // Step 1: If this.[[stream]] is undefined, return.
        if (self.stream == null) {
            return;
        }

        // Step 2: Perform ! ReadableStreamDefaultReaderRelease(this).
        self.releaseInternal();
    }
    /// Generic cancel implementation
    /// 
    /// Spec: § 4.2.5 "ReadableStreamReaderGenericCancel(reader, reason)"
    fn genericCancel(self: *ReadableStreamDefaultReader, reason: ?common.JSValue) !*AsyncPromise(void) {
        // Step 1: Assert: stream.[[reader]] is not undefined.
        // Step 2: Return ! ReadableStreamCancel(stream, reason).
        _ = reason;
        const promise = try AsyncPromise(void).init(self.allocator, self.eventLoop);
        promise.fulfill({});
        return promise;
    }
    /// Internal read implementation (ASYNC VERSION)
    /// 
    /// Spec: § 4.3.4 "ReadableStreamDefaultReaderRead(reader)"
    /// 
    /// This is the core async read logic. It returns:
    /// - FULFILLED promise if data is immediately available or stream is closed/errored
    /// - PENDING promise if queue is empty (promise added to readRequests)
    fn readInternal(self: *ReadableStreamDefaultReader) !*AsyncPromise(common.ReadResult) {
        const stream: *ReadableStream = @ptrCast(@alignCast(self.stream.?));

        // Step 2: Mark stream as disturbed (spec § 4.3.4 step 2)
        stream.disturbed = true;

        // Step 3-6: Check stream state
        switch (stream.state) {
            .closed => {
                // Stream closed - return fulfilled promise with done=true
                const promise = try AsyncPromise(common.ReadResult).init(
                    self.allocator,
                    self.eventLoop,
                );
                promise.fulfill(.{ .value = null, .done = true });
                return promise;
            },
            .errored => {
                // Stream errored - return rejected promise
                const promise = try AsyncPromise(common.ReadResult).init(
                    self.allocator,
                    self.eventLoop,
                );
                promise.reject(stream.storedError orelse common.JSValue.undefined_value());
                return promise;
            },
            .readable => {
                // Try to dequeue from controller
                if (!stream.controller.queue.isEmpty()) {
                    // Data available - fulfill immediately (spec § 4.3.4 step 6)
                    const queue_value = try stream.controller.queue.dequeueValue();

                    // queue_value is already common.JSValue
                    const chunk: common.JSValue = queue_value;

                    const promise = try AsyncPromise(common.ReadResult).init(
                        self.allocator,
                        self.eventLoop,
                    );
                    promise.fulfill(.{ .value = chunk, .done = false });

                    // Check if queue is now empty and close was requested
                    // Spec § 4.6.4: After dequeuing, if closeRequested and queue is empty, close stream
                    if (stream.controller.closeRequested and stream.controller.queue.isEmpty()) {
                        stream.controller.clearAlgorithms();
                        stream.closeInternal();
                    } else {
                        // Call pull after read (spec § 4.3.4 step 6.3)
                        stream.controller.callPullIfNeeded();
                    }

                    return promise;
                } else {
                    // NO DATA AVAILABLE - Create pending promise (spec § 4.3.4 step 7)
                    const promise = try AsyncPromise(common.ReadResult).init(
                        self.allocator,
                        self.eventLoop,
                    );

                    // Add to pending read requests (will be fulfilled when data arrives)
                    try self.readRequests.append(self.allocator, promise);

                    // Call pull to request data (spec § 4.3.4 step 7)
                    stream.controller.callPullIfNeeded();

                    // Return PENDING promise
                    return promise;
                }
            },
        }
    }
    /// Internal release implementation
    /// 
    /// Spec: § 4.3.5 "ReadableStreamDefaultReaderRelease(reader)"
    fn releaseInternal(self: *ReadableStreamDefaultReader) void {
        // Step 2: Let e be a new TypeError exception.
        const e = common.JSValue{ .string = "Reader released" };

        // Step 3: Perform ! ReadableStreamDefaultReaderErrorReadRequests(reader, e).
        // IMPORTANT: Do this BEFORE genericRelease() which will free the reader
        self.errorReadRequests(e);

        // Step 1: Perform ! ReadableStreamReaderGenericRelease(reader).
        // This will free the reader, so it must be the last thing we do
        self.genericRelease();
    }
    /// Generic release implementation
    /// 
    /// Spec: § 4.2.5 "ReadableStreamReaderGenericRelease(reader)"
    fn genericRelease(self: *ReadableStreamDefaultReader) void {
        // Spec: § 4.2.6 "ReadableStreamReaderGenericRelease(reader)"

        // Step 1-2: Promise handling (TODO: implement closedPromise)
        // 1. Reject reader.[[closedPromise]] with TypeError
        // 2. Set reader.[[closedPromise]] to rejected promise

        // Step 3: Set reader.[[stream]].[[reader]] to undefined
        // Step 4: Set reader.[[stream]] to undefined
        if (self.stream) |stream| {
            const allocator = stream.allocator;
            stream.reader = .none;
            self.stream = null;

            // Free the reader since the stream no longer tracks it
            // NOTE: We only call deinit() to free the readRequests ArrayList.
            // We do NOT free promises (they're in arena) or the reader struct itself
            // (tests might still hold pointers to it).
            self.deinit();
            allocator.destroy(self);
        } else {
            self.stream = null;
        }
    }
    /// Error all pending read requests
    /// 
    /// Spec: § 4.3.5 "ReadableStreamDefaultReaderErrorReadRequests(reader, e)"
    fn errorReadRequests(self: *ReadableStreamDefaultReader, e: common.JSValue) void {
        // Step 1: Let readRequests be reader.[[readRequests]].
        // Step 2: Set reader.[[readRequests]] to a new empty list.
        // Step 3: For each readRequest of readRequests,
        //         perform readRequest's error steps, given e.

        // IMPORTANT: During cleanup, promises may have already been freed from the arena.
        // Trying to reject them can cause use-after-free errors.
        // Instead, just clear the list without rejecting.
        // The promises will be automatically freed when the event loop's arena is destroyed.
        // This matches browser semantics where promises are garbage collected.
        _ = e; // Unused during cleanup
        self.readRequests.clearRetainingCapacity();
    }
};


// Phase 2 Async Read Tests

test "Async read - pending promise fulfilled when chunk arrives" {
    const allocator = std.testing.allocator;
    const TestEventLoop = @import("test_eventLoop").TestEventLoop;

    // Create event loop
    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    // Create stream with empty source (no immediate data)
    var stream = try ReadableStream.initWithSource(allocator, test_loop.eventLoop(), null, null);
    defer stream.deinit();
    stream.fixControllerPointer();

    // Acquire reader
    const reader = try stream.acquireDefaultReader(test_loop.eventLoop());

    // Issue read - should return pending promise (no data available)
    const read_promise = try reader.call_read();

    // Verify promise is pending
    try std.testing.expect(read_promise.isPending());

    // Verify read request was queued
    try std.testing.expectEqual(@as(usize, 1), reader.readRequests.items.len);

    // Now enqueue a chunk - should fulfill the pending read
    try stream.controller.call_enqueue(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "test chunk" },
    });

    // Verify promise was fulfilled (enqueue fulfills immediately)
    try std.testing.expect(read_promise.isFulfilled());
    try std.testing.expect(!read_promise.state.fulfilled.done);
    try std.testing.expectEqualStrings("test chunk", read_promise.state.fulfilled.value.?.string);

    // Verify read request was removed from queue
    try std.testing.expectEqual(@as(usize, 0), reader.readRequests.items.len);

    // Cleanup
    read_promise.deinit();
    reader.call_releaseLock();
}

test "Async read - immediate fulfillment when chunk available" {
    const allocator = std.testing.allocator;
    const TestEventLoop = @import("test_eventLoop").TestEventLoop;

    // Create event loop
    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    // Create stream
    var stream = try ReadableStream.initWithSource(allocator, test_loop.eventLoop(), null, null);
    defer stream.deinit();
    stream.fixControllerPointer();

    // Enqueue chunk BEFORE reading
    try stream.controller.call_enqueue(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "immediate chunk" },
    });

    // Acquire reader
    const reader = try stream.acquireDefaultReader(test_loop.eventLoop());

    // Issue read - should return fulfilled promise (data available)
    const read_promise = try reader.call_read();
    defer read_promise.deinit();

    // Verify promise is fulfilled
    try std.testing.expect(read_promise.isFulfilled());
    try std.testing.expect(!read_promise.state.fulfilled.done);
    try std.testing.expectEqualStrings("immediate chunk", read_promise.state.fulfilled.value.?.string);

    // Verify no pending requests
    try std.testing.expectEqual(@as(usize, 0), reader.readRequests.items.len);

    // Cleanup
    reader.call_releaseLock();
}

test "Async read - multiple pending reads fulfilled in order" {
    const allocator = std.testing.allocator;
    const TestEventLoop = @import("test_eventLoop").TestEventLoop;

    // Create event loop
    var test_loop = TestEventLoop.init(allocator);
    defer test_loop.deinit();

    // Create stream with empty source
    var stream = try ReadableStream.initWithSource(allocator, test_loop.eventLoop(), null, null);
    defer stream.deinit();
    stream.fixControllerPointer();

    // Acquire reader
    const reader = try stream.acquireDefaultReader(test_loop.eventLoop());

    // Issue multiple reads - all should be pending
    const read1 = try reader.call_read();
    const read2 = try reader.call_read();
    const read3 = try reader.call_read();

    // All pending
    try std.testing.expect(read1.isPending());
    try std.testing.expect(read2.isPending());
    try std.testing.expect(read3.isPending());
    try std.testing.expectEqual(@as(usize, 3), reader.readRequests.items.len);

    // Enqueue first chunk - should fulfill first read only
    try stream.controller.call_enqueue(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "chunk1" },
    });

    try std.testing.expect(read1.isFulfilled());
    try std.testing.expectEqualStrings("chunk1", read1.state.fulfilled.value.?.string);
    try std.testing.expect(read2.isPending());
    try std.testing.expect(read3.isPending());
    try std.testing.expectEqual(@as(usize, 2), reader.readRequests.items.len);

    // Enqueue second chunk
    try stream.controller.call_enqueue(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "chunk2" },
    });

    try std.testing.expect(read2.isFulfilled());
    try std.testing.expectEqualStrings("chunk2", read2.state.fulfilled.value.?.string);
    try std.testing.expect(read3.isPending());
    try std.testing.expectEqual(@as(usize, 1), reader.readRequests.items.len);

    // Enqueue third chunk
    try stream.controller.call_enqueue(.{
        .was_passed = true,
        .value = webidl.JSValue{ .string = "chunk3" },
    });

    try std.testing.expect(read3.isFulfilled());
    try std.testing.expectEqualStrings("chunk3", read3.state.fulfilled.value.?.string);
    try std.testing.expectEqual(@as(usize, 0), reader.readRequests.items.len);

    // Cleanup
    read1.deinit();
    read2.deinit();
    read3.deinit();
    reader.call_releaseLock();
}
