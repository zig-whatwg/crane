// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const std = @import("std");
const webidl = @import("webidl");
const Allocator = @import("std.mem").Allocator;
const std = @import("std");
const webidl = @import("webidl");

pub const console = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    enabled: bool,
    printFn: ?PrintFn,
    runtime: ?*types.RuntimeInterface,
    countMap: infra.OrderedMap(webidl.DOMString, u32),
    timerTable: infra.OrderedMap(webidl.DOMString, infra.Moment),
    groupStack: infra.Stack(Group),
    messageBuffer: CircularMessageBuffer,
    labelPool: std.StringHashMap(void),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: Allocator) !console {

        return initWithBufferSize(allocator, 1000);
    
    }

    pub fn initWithBufferSize(allocator: Allocator, buffer_size: usize) !console {

        var labelPool = std.StringHashMap(void).init(allocator);
        errdefer {
            var it = labelPool.keyIterator();
            while (it.next()) |key| {
                allocator.free(key.*);
            }
            labelPool.deinit();
        }

        // Pre-intern the "default" label (used 90% of the time)
        const default_label = try allocator.dupe(u8, "default");
        errdefer allocator.free(default_label);
        try labelPool.put(default_label, {});

        var messageBuffer = try CircularMessageBuffer.init(allocator, buffer_size);
        errdefer messageBuffer.deinit();

        return .{
            .allocator = allocator,
            .enabled = true, // Browser optimization: fast disabled path
            .printFn = defaultPrinter,
            .runtime = null, // No runtime by default (standalone mode)
            .countMap = infra.OrderedMap(webidl.DOMString, u32).init(allocator),
            .timerTable = infra.OrderedMap(webidl.DOMString, infra.Moment).init(allocator),
            .groupStack = infra.Stack(Group).init(allocator),
            .messageBuffer = messageBuffer,
            .labelPool = labelPool,
        };
    
    }

    pub fn deinit(self: *console) void {

        self.countMap.deinit();
        self.timerTable.deinit();

        // Free all groups with labels
        while (self.groupStack.pop()) |group| {
            var g = group;
            g.deinit(self.allocator);
        }
        self.groupStack.deinit();

        self.messageBuffer.deinit();

        // Free all interned label strings
        var it = self.labelPool.keyIterator();
        while (it.next()) |key| {
            self.allocator.free(key.*);
        }
        self.labelPool.deinit();
    
    }

    pub fn call_assert(self: *console, condition: bool, data: []const webidl.JSValue) void {

        // 1. If condition is true, return.
        if (condition) return;

        // 2. Let message be a string indicating assertion failure
        const message = "Assertion failed";

        // 3. If data is empty, append message to data
        if (data.len == 0) {
            const args = [_]webidl.JSValue{.{ .string = message }};
            self.logger(.assert_level, &args);
            return;
        }

        // Step 4: Otherwise
        const first = data[0];

        // Step 4.2: If first is not a String, then prepend message to data
        if (first != .string) {
            var args_with_prefix = self.allocator.alloc(webidl.JSValue, data.len + 1) catch {
                self.logger(.assert_level, data);
                return;
            };
            defer self.allocator.free(args_with_prefix);

            args_with_prefix[0] = webidl.JSValue{ .string = message };
            @memcpy(args_with_prefix[1..], data);

            // Step 5: Perform Logger("assert", data)
            self.logger(.assert_level, args_with_prefix);
        } else {
            // Step 4.3: Otherwise (first IS a String)
            // Step 4.3.1: Let concat be the concatenation of message, U+003A (:), U+0020 SPACE, and first
            const concat = std.fmt.allocPrint(
                self.allocator,
                "{s}: {s}",
                .{ message, first.string },
            ) catch {
                self.logger(.assert_level, data);
                return;
            };

            // Step 4.3.2: Set data[0] to concat
            var modified_data = self.allocator.alloc(webidl.JSValue, data.len) catch {
                self.allocator.free(concat);
                self.logger(.assert_level, data);
                return;
            };
            defer self.allocator.free(modified_data);

            modified_data[0] = webidl.JSValue{ .string = concat };
            if (data.len > 1) {
                @memcpy(modified_data[1..], data[1..]);
            }

            // Step 5: Perform Logger("assert", data)
            const owned_strings = [_][]const u8{concat};
            if (modified_data.len == 1) {
                self.printerWithOwnedStrings(.assert_level, modified_data, &owned_strings);
            } else {
                self.printerWithOwnedStrings(.assert_level, modified_data, &owned_strings);
            }
        }
    
    }

    pub fn call_clear(self: *console) void {

        // Step 1: Empty the appropriate group stack
        while (self.groupStack.pop()) |group| {
            var g = group;
            g.deinit(self.allocator);
        }

        // Step 2: If possible for the environment, clear the console
        self.messageBuffer.clear();
    
    }

    pub fn call_debug(self: *console, data: []const webidl.JSValue) void {

        self.logger(.debug, data);
    
    }

    pub fn call_error(self: *console, data: []const webidl.JSValue) void {

        self.logger(.error_level, data);
    
    }

    pub fn call_info(self: *console, data: []const webidl.JSValue) void {

        self.logger(.info, data);
    
    }

    pub fn call_log(self: *console, data: []const webidl.JSValue) void {

        self.logger(.log, data);
    
    }

    pub fn call_table(self: *console, tabular_data: ?webidl.JSValue, properties: ?[]const webidl.DOMString) void {

        if (tabular_data == null) {
            self.logger(.log, &.{});
            return;
        }

        const data = tabular_data.?;

        // If runtime is available, attempt to construct table
        if (self.runtime) |rt| {
            self.constructTable(rt, data, properties) catch {
                // Fall back to logging on error
                const args: [1]webidl.JSValue = .{data};
                self.logger(.log, &args);
                return;
            };
        } else {
            // No runtime - fall back to logging
            const args: [1]webidl.JSValue = .{data};
            self.logger(.log, &args);
        }
    
    }

    pub fn call_trace(self: *console, data: []const webidl.JSValue) void {

        // Step 1: Let trace be some implementation-defined stack trace representation
        // Step 2: Optionally, let formattedData be the result of Formatter(data)
        // Step 3: Incorporate formattedData as a label for trace
        // Step 4: Perform Printer("trace", « trace »)

        // If runtime is available, capture stack trace
        if (self.runtime) |rt| {
            const frames = rt.vtable.captureStackTrace(rt.context, self.allocator) catch {
                // If stack capture fails, fall back to simple trace
                self.logger(.trace, data);
                return;
            };
            defer {
                for (frames) |frame| {
                    if (frame.function_name) |name| self.allocator.free(name);
                    if (frame.file_name) |file| self.allocator.free(file);
                }
                self.allocator.free(frames);
            }

            // Format stack trace as string
            var trace_str = infra.List(u8).init(self.allocator);
            defer trace_str.deinit();

            // Add label with optional data
            if (data.len > 0) {
                const formatted = self.formatter(data) catch data;
                defer if (formatted.ptr != data.ptr) self.allocator.free(formatted);

                for (formatted) |arg| {
                    const str = switch (arg) {
                        .string => |s| s,
                        else => "[object]",
                    };
                    trace_str.appendSlice(str) catch {};
                    trace_str.append(' ') catch {};
                }
            }
            trace_str.appendSlice("Trace\n") catch {};

            // Format each stack frame
            for (frames) |frame| {
                const formatted_frame = frame.format(self.allocator) catch continue;
                defer self.allocator.free(formatted_frame);

                trace_str.appendSlice(formatted_frame) catch {};
                trace_str.append('\n') catch {};
            }

            // Print the complete stack trace
            const trace_items = trace_str.items();
            const trace_value = webidl.JSValue{ .string = trace_items };
            self.printer(.trace, &.{trace_value});
        } else {
            // Fallback: Just print with trace level (no stack capture)
            self.logger(.trace, data);
        }
    
    }

    pub fn call_warn(self: *console, data: []const webidl.JSValue) void {

        self.logger(.warn, data);
    
    }

    pub fn call_dir(self: *console, item: ?webidl.JSValue, options: ?webidl.JSValue) void {

        _ = options;
        if (item) |obj| {
            const args: [1]webidl.JSValue = .{obj};
            self.logger(.dir, &args);
        } else {
            self.logger(.dir, &.{});
        }
    
    }

    pub fn call_dirxml(self: *console, data: []const webidl.JSValue) void {

        self.logger(.dirxml, data);
    
    }

    pub fn call_count(self: *console, label: []const u8) void {

        // Step 1: Let map be the associated count map
        // Step 2-3: Get or create count
        const interned = self.internLabel(label) catch label;

        var count: u32 = 1;
        if (self.countMap.get(interned)) |existing| {
            count = existing + 1;
        }
        self.countMap.set(interned, count) catch return;

        // Step 4: Let concat be the concatenation of label, ":", " ", and ToString(map[label])
        const concat = std.fmt.allocPrint(self.allocator, "{s}: {d}", .{ label, count }) catch return;
        defer self.allocator.free(concat);

        // Step 5: Perform Logger("count", « concat »)
        const args = [_]webidl.JSValue{.{ .string = concat }};
        self.logger(.count, &args);
    
    }

    pub fn call_countReset(self: *console, label: []const u8) void {

        // Step 1: Let map be the associated count map
        const interned = self.internLabel(label) catch label;

        // Step 2: If map[label] exists, set map[label] to 0
        if (self.countMap.contains(interned)) {
            self.countMap.set(interned, 0) catch return;
        } else {
            // Step 3: Otherwise - log warning message
            const message = std.fmt.allocPrint(
                self.allocator,
                "Count for '{s}' does not exist",
                .{label},
            ) catch return;
            defer self.allocator.free(message);

            const args = [_]webidl.JSValue{.{ .string = message }};
            self.logger(.count_reset, &args);
        }
    
    }

    pub fn call_group(self: *console, data: []const webidl.JSValue) void {

        // Step 1: Let group be a new group
        // Step 2: If data is not empty, let groupLabel be result of Formatter(data)
        var group_label: ?[]const u8 = null;
        if (data.len > 0) {
            const formatted = self.formatter(data) catch null;
            if (formatted) |f| {
                // Convert formatted args to string
                if (f.len > 0 and f[0] == .string) {
                    group_label = self.allocator.dupe(u8, f[0].string) catch null;
                }
                if (f.ptr != data.ptr) {
                    self.allocator.free(f);
                }
            }
        }

        // Step 3-4: Incorporate groupLabel and set expanded by default
        const group = Group.init(group_label);

        // Step 5: Perform Printer("group", « group »)
        self.logger(.group, data);

        // Step 6: Push group onto the appropriate group stack
        self.groupStack.push(group) catch {};
    
    }

    pub fn call_groupCollapsed(self: *console, data: []const webidl.JSValue) void {

        // Step 1: Let group be a new group
        // Step 2: If data is not empty, let groupLabel be result of Formatter(data)
        var group_label: ?[]const u8 = null;
        if (data.len > 0) {
            const formatted = self.formatter(data) catch null;
            if (formatted) |f| {
                if (f.len > 0 and f[0] == .string) {
                    group_label = self.allocator.dupe(u8, f[0].string) catch null;
                }
                if (f.ptr != data.ptr) {
                    self.allocator.free(f);
                }
            }
        }

        // Step 3-4: Incorporate groupLabel and set collapsed by default
        const group = Group.initCollapsed(group_label);

        // Step 5: Perform Printer("groupCollapsed", « group »)
        self.logger(.group_collapsed, data);

        // Step 6: Push group onto the appropriate group stack
        self.groupStack.push(group) catch {};
    
    }

    pub fn call_groupEnd(self: *console) void {

        // Step 1: Pop the last group from the group stack
        if (self.groupStack.pop()) |group| {
            var g = group;
            g.deinit(self.allocator);
        }
    
    }

    pub fn call_time(self: *console, label: []const u8) void {

        const interned = self.internLabel(label) catch label;

        // Step 1: If the associated timer table contains an entry with key label, return
        if (self.timerTable.contains(interned)) {
            // Optionally report warning (spec lines 223-224)
            return;
        }

        // Step 2: Otherwise, set value to current time
        const now = infra.Moment.now();
        self.timerTable.set(interned, now) catch return;
    
    }

    pub fn call_timeLog(self: *console, label: []const u8, data: []const webidl.JSValue) void {

        const interned = self.internLabel(label) catch label;

        // Step 1: Let timerTable be the associated timer table
        // Step 2: Let startTime be timerTable[label]
        const start_time = self.timerTable.get(interned) orelse return;

        // Step 3: Let duration be string representing difference
        const now = infra.Moment.now();
        const elapsed = now.since(start_time);
        const duration_ms = elapsed.toMilliseconds();

        // Step 4: Let concat be concatenation of label, ":", " ", and duration
        const concat = std.fmt.allocPrint(
            self.allocator,
            "{s}: {d}ms",
            .{ label, duration_ms },
        ) catch return;
        defer self.allocator.free(concat);

        // Step 5: Prepend concat to data
        const args_len = 1 + data.len;
        var args = self.allocator.alloc(webidl.JSValue, args_len) catch return;
        defer self.allocator.free(args);

        args[0] = webidl.JSValue{ .string = concat };
        if (data.len > 0) {
            @memcpy(args[1..], data);
        }

        // Step 6: Perform Printer("timeLog", data)
        self.printer(.time_log, args);
    
    }

    pub fn call_timeEnd(self: *console, label: []const u8) void {

        const interned = self.internLabel(label) catch label;

        // Step 1: Let timerTable be the associated timer table
        // Step 2: Let startTime be timerTable[label]
        const start_time = self.timerTable.get(interned) orelse return;

        // Step 3: Remove timerTable[label]
        self.timerTable.remove(interned);

        // Step 4: Let duration be string representing difference
        const now = infra.Moment.now();
        const elapsed = now.since(start_time);
        const duration_ms = elapsed.toMilliseconds();

        // Step 5: Let concat be concatenation of label, ":", " ", and duration
        const concat = std.fmt.allocPrint(
            self.allocator,
            "{s}: {d}ms",
            .{ label, duration_ms },
        ) catch return;
        defer self.allocator.free(concat);

        // Step 6: Perform Printer("timeEnd", « concat »)
        const args = [_]webidl.JSValue{.{ .string = concat }};
        self.printer(.time_end, &args);
    
    }

};


