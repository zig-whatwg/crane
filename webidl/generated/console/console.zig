// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
pub const Buffer = @import("buffer").Buffer;
pub const Map = @import("map").Map;
pub const Moment = @import("moment").Moment;
pub const Pool = @import("pool").Pool;
pub const Stack = @import("stack").Stack;
pub const Table = @import("table").Table;
const format = @import("format");
const infra = @import("infra");
const std = @import("std");
const types = @import("types");
const webidl = @import("webidl");


const Group = types.Group;
const LogLevel = types.LogLevel;
const Message = types.Message;
const CircularMessageBuffer = types.CircularMessageBuffer;

/// Printer function signature for console output.
///
/// Takes a pre-formatted message string and outputs it.
/// This is called by the Printer operation after formatting.
///
/// Example:
/// ```zig
/// fn customPrinter(message: []const u8) void {
///     std.log.info("[CONSOLE] {s}", .{message});
/// }
/// ```
pub const PrintFn = *const fn (message: []const u8) void;

/// Default printer function that outputs to stderr.
///
/// This is the default value for console.printFn.
/// Outputs messages using std.debug.print with newline.
fn defaultPrinter(message: []const u8) void {
    std.debug.print("{s}\n", .{message});
}

/// console namespace object per WHATWG console Standard
///
/// WHATWG console Standard lines 8-39 (WebIDL):
/// ```webidl
/// [Exposed=*]
/// namespace console {
///   // Logging (11 methods)
///   undefined assert(optional boolean condition = false, any... data);
///   undefined clear();
///   undefined debug(any... data);
///   undefined error(any... data);
///   undefined info(any... data);
///   undefined log(any... data);
///   undefined table(optional any tabularData, optional sequence<DOMString> properties);
///   undefined trace(any... data);
///   undefined warn(any... data);
///   undefined dir(optional any item, optional object? options);
///   undefined dirxml(any... data);
///
///   // Counting (2 methods)
///   undefined count(optional DOMString label = "default");
///   undefined countReset(optional DOMString label = "default");
///
///   // Grouping (3 methods)
///   undefined group(any... data);
///   undefined groupCollapsed(any... data);
///   undefined groupEnd();
///
///   // Timing (3 methods)
///   undefined time(optional DOMString label = "default");
///   undefined timeLog(optional DOMString label = "default", any... data);
///   undefined timeEnd(optional DOMString label = "default");
/// };
/// ```
///
/// # State Management
///
/// Each console namespace object has associated state:
/// - **countMap**: Map of labels to counts (for count/countReset)
/// - **timerTable**: Map of labels to start times (for time/timeLog/timeEnd)
/// - **groupStack**: Stack of active groups (for group/groupCollapsed/groupEnd)
/// - **messageBuffer**: Circular buffer of messages (for history/DevTools)
/// - **labelPool**: Interned strings for performance
///
/// # Fields
///
/// - `allocator`: Memory allocator for all operations
/// - `enabled`: Fast disable path (set to false to disable all output)
/// - `printFn`: Optional custom printer function (default: stderr)
/// - `runtime`: Optional JavaScript runtime for ECMAScript type conversions
/// - `countMap`: Label→count mapping for count() operations
/// - `timerTable`: Label→timestamp mapping for timing operations
/// - `groupStack`: Stack of active groups for indentation
/// - `messageBuffer`: Circular buffer for message history (default 1000)
/// - `labelPool`: Interned label strings for performance

pub const console = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    enabled: bool,
    printFn: ?PrintFn,
    runtime: ?*types.RuntimeInterface,
    countMap: infra.OrderedMap(webidl.DOMString, u32),
    timerTable: infra.OrderedMap(webidl.DOMString, infra.Moment),
    groupStack: infra.Stack(Group),
    messageBuffer: CircularMessageBuffer,
    labelPool: std.StringHashMap(void),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: Allocator) !console {

        return initWithBufferSize(allocator, 1000);
    
    }

    pub fn initWithBufferSize(allocator: Allocator, buffer_size: usize) !console {

        var labelPool = std.StringHashMap(void).init(allocator);
        errdefer {
            var it = labelPool.keyIterator();
            while (it.next()) |key| {
                allocator.free(key.*);
            }
            labelPool.deinit();
        }

        // Pre-intern the "default" label (used 90% of the time)
        const default_label = try allocator.dupe(u8, "default");
        errdefer allocator.free(default_label);
        try labelPool.put(default_label, {});

        var messageBuffer = try CircularMessageBuffer.init(allocator, buffer_size);
        errdefer messageBuffer.deinit();

        return .{
            .allocator = allocator,
            .enabled = true, // Browser optimization: fast disabled path
            .printFn = defaultPrinter,
            .runtime = null, // No runtime by default (standalone mode)
            .countMap = infra.OrderedMap(webidl.DOMString, u32).init(allocator),
            .timerTable = infra.OrderedMap(webidl.DOMString, infra.Moment).init(allocator),
            .groupStack = infra.Stack(Group).init(allocator),
            .messageBuffer = messageBuffer,
            .labelPool = labelPool,
        };
    
    }

    pub fn deinit(self: *console) void {

        self.countMap.deinit();
        self.timerTable.deinit();

        // Free all groups with labels
        while (self.groupStack.pop()) |group| {
            var g = group;
            g.deinit(self.allocator);
        }
        self.groupStack.deinit();

        self.messageBuffer.deinit();

        // Free all interned label strings
        var it = self.labelPool.keyIterator();
        while (it.next()) |key| {
            self.allocator.free(key.*);
        }
        self.labelPool.deinit();
    
    }

    fn internLabel(self: *console, label_utf8: []const u8) ![]const u8 {

        // Check if already in pool
        if (self.labelPool.getKey(label_utf8)) |existing| {
            return existing;
        }

        // Not in pool - allocate and insert
        const owned = try self.allocator.dupe(u8, label_utf8);
        errdefer self.allocator.free(owned);

        try self.labelPool.put(owned, {});

        // Return the owned string from the pool
        return self.labelPool.getKey(owned).?;
    
    }

    pub fn call_assert(self: *console, condition: bool, data: []const webidl.JSValue) void {

        // 1. If condition is true, return.
        if (condition) return;

        // 2. Let message be a string indicating assertion failure
        const message = "Assertion failed";

        // 3. If data is empty, append message to data
        if (data.len == 0) {
            const args = [_]webidl.JSValue{.{ .string = message }};
            self.logger(.assert_level, &args);
            return;
        }

        // Step 4: Otherwise
        const first = data[0];

        // Step 4.2: If first is not a String, then prepend message to data
        if (first != .string) {
            var args_with_prefix = self.allocator.alloc(webidl.JSValue, data.len + 1) catch {
                self.logger(.assert_level, data);
                return;
            };
            defer self.allocator.free(args_with_prefix);

            args_with_prefix[0] = webidl.JSValue{ .string = message };
            @memcpy(args_with_prefix[1..], data);

            // Step 5: Perform Logger("assert", data)
            self.logger(.assert_level, args_with_prefix);
        } else {
            // Step 4.3: Otherwise (first IS a String)
            // Step 4.3.1: Let concat be the concatenation of message, U+003A (:), U+0020 SPACE, and first
            const concat = std.fmt.allocPrint(
                self.allocator,
                "{s}: {s}",
                .{ message, first.string },
            ) catch {
                self.logger(.assert_level, data);
                return;
            };

            // Step 4.3.2: Set data[0] to concat
            var modified_data = self.allocator.alloc(webidl.JSValue, data.len) catch {
                self.allocator.free(concat);
                self.logger(.assert_level, data);
                return;
            };
            defer self.allocator.free(modified_data);

            modified_data[0] = webidl.JSValue{ .string = concat };
            if (data.len > 1) {
                @memcpy(modified_data[1..], data[1..]);
            }

            // Step 5: Perform Logger("assert", data)
            const owned_strings = [_][]const u8{concat};
            if (modified_data.len == 1) {
                self.printerWithOwnedStrings(.assert_level, modified_data, &owned_strings);
            } else {
                self.printerWithOwnedStrings(.assert_level, modified_data, &owned_strings);
            }
        }
    
    }

    pub fn call_clear(self: *console) void {

        // Step 1: Empty the appropriate group stack
        while (self.groupStack.pop()) |group| {
            var g = group;
            g.deinit(self.allocator);
        }

        // Step 2: If possible for the environment, clear the console
        self.messageBuffer.clear();
    
    }

    pub fn call_debug(self: *console, data: []const webidl.JSValue) void {

        self.logger(.debug, data);
    
    }

    pub fn call_error(self: *console, data: []const webidl.JSValue) void {

        self.logger(.error_level, data);
    
    }

    pub fn call_info(self: *console, data: []const webidl.JSValue) void {

        self.logger(.info, data);
    
    }

    pub fn call_log(self: *console, data: []const webidl.JSValue) void {
        self.logger(.log, data);
    }

    /// table(tabularData, properties)
    ///
    /// WHATWG console Standard lines 102-106:
    /// Try to construct a table with columns of properties and rows of tabularData.
    /// Falls back to logging if it can't be parsed as tabular.
    ///
    /// IDL: undefined table(optional any tabularData, optional sequence<DOMString> properties);
    pub fn call_table(self: *console, tabular_data: ?webidl.JSValue, properties: ?[]const webidl.DOMString) void {
        if (tabular_data == null) {
            self.logger(.log, &.{});
            return;
        }

        const data = tabular_data.?;

        // If runtime is available, attempt to construct table
        if (self.runtime) |rt| {
            self.constructTable(rt, data, properties) catch {
                // Fall back to logging on error
                const args: [1]webidl.JSValue = .{data};
                self.logger(.log, &args);
                return;
            };
        } else {
            // No runtime - fall back to logging
            const args: [1]webidl.JSValue = .{data};
            self.logger(.log, &args);
        }
    }

    /// Construct and display a table from tabular data.
    ///
    /// Complete implementation following browser console.table() behavior:
    /// 1. Parse array elements and extract all unique keys
    /// 2. Filter columns by properties parameter if provided
    /// 3. Build ASCII table with proper alignment and borders
    /// 4. Support primitives and objects as array elements
    fn constructTable(
        self: *console,
        rt: *types.RuntimeInterface,
        data: webidl.JSValue,
        properties: ?[]const webidl.DOMString,
    ) !void {

        // Step 1: Check if data is an array
        const is_array = rt.vtable.isArray(rt.context, data);
        if (!is_array) {
            return error.NotTabular;
        }

        // Step 2: Get array length
        const length_opt = try rt.vtable.getLength(rt.context, data);
        const length = length_opt orelse return error.NotTabular;

        if (length == 0) {
            const args: [1]webidl.JSValue = .{data};
            self.logger(.log, &args);
            return;
        }

        // Step 3: Collect all unique keys from array elements
        var all_keys = std.StringHashMap(void).init(self.allocator);
        defer {
            var key_iter = all_keys.keyIterator();
            while (key_iter.next()) |key| {
                self.allocator.free(key.*);
            }
            all_keys.deinit();
        }

        var i: u32 = 0;
        while (i < length) : (i += 1) {
            const index_str = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
            defer self.allocator.free(index_str);

            const element = (try rt.vtable.getProperty(rt.context, data, index_str, self.allocator)) orelse continue;

            if (rt.vtable.isObject(rt.context, element)) {
                const keys = try rt.vtable.getKeys(rt.context, element, self.allocator);
                defer {
                    for (keys) |key| {
                        self.allocator.free(key);
                    }
                    self.allocator.free(keys);
                }

                for (keys) |key| {
                    const entry = try all_keys.getOrPut(key);
                    if (!entry.found_existing) {
                        entry.key_ptr.* = try self.allocator.dupe(u8, key);
                    }
                }
            }
        }

        // Step 4: Determine which columns to display
        var columns = infra.List([]const u8).init(self.allocator);
        defer {
            for (columns.items()) |col| {
                self.allocator.free(col);
            }
            columns.deinit();
        }

        if (properties) |props| {
            for (props) |prop| {
                const prop_utf8 = try infra.string.utf16ToUtf8(self.allocator, prop);
                defer self.allocator.free(prop_utf8);

                if (all_keys.contains(prop_utf8)) {
                    try columns.append(try self.allocator.dupe(u8, prop_utf8));
                }
            }
        } else {
            var key_iter = all_keys.keyIterator();
            while (key_iter.next()) |key| {
                try columns.append(try self.allocator.dupe(u8, key.*));
            }
        }

        // Step 5: Build table string with borders
        var table = infra.List(u8).init(self.allocator);
        defer table.deinit();

        // Calculate column widths
        const col_widths = blk: {
            var widths = try self.allocator.alloc(usize, columns.size() + 1);
            widths[0] = "(index)".len;

            for (columns.items(), 1..) |col, idx| {
                widths[idx] = col.len;
            }

            // Check data for wider cells
            i = 0;
            while (i < length) : (i += 1) {
                const idx_str = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
                defer self.allocator.free(idx_str);

                widths[0] = @max(widths[0], idx_str.len);

                const index_str = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
                defer self.allocator.free(index_str);

                const element = (try rt.vtable.getProperty(rt.context, data, index_str, self.allocator)) orelse continue;

                for (columns.items(), 1..) |col, col_idx| {
                    if (rt.vtable.isObject(rt.context, element)) {
                        const value = (try rt.vtable.getProperty(rt.context, element, col, self.allocator)) orelse continue;
                        const val_str = try rt.vtable.toString(rt.context, value, self.allocator);
                        defer self.allocator.free(val_str);
                        widths[col_idx] = @max(widths[col_idx], val_str.len);
                    }
                }
            }

            break :blk widths;
        };
        defer self.allocator.free(col_widths);

        // Top border
        try table.appendSlice("┌");
        for (col_widths, 0..) |width, idx| {
            for (0..width + 2) |_| try table.appendSlice("─");
            if (idx < col_widths.len - 1) {
                try table.appendSlice("┬");
            }
        }
        try table.appendSlice("┐\n");

        // Header row
        try table.appendSlice("│ (index)");
        for (0..col_widths[0] - "(index)".len) |_| try table.append(' ');
        try table.append(' ');

        for (columns.items(), 1..) |col, idx| {
            try table.appendSlice("│ ");
            try table.appendSlice(col);
            for (0..col_widths[idx] - col.len) |_| try table.append(' ');
            try table.append(' ');
        }
        try table.appendSlice("│\n");

        // Header separator
        try table.appendSlice("├");
        for (col_widths, 0..) |width, idx| {
            for (0..width + 2) |_| try table.appendSlice("─");
            if (idx < col_widths.len - 1) {
                try table.appendSlice("┼");
            }
        }
        try table.appendSlice("┤\n");

        // Data rows
        i = 0;
        while (i < length) : (i += 1) {
            const idx_str = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
            defer self.allocator.free(idx_str);

            try table.appendSlice("│ ");
            try table.appendSlice(idx_str);
            for (0..col_widths[0] - idx_str.len) |_| try table.append(' ');
            try table.append(' ');

            const index_str = try std.fmt.allocPrint(self.allocator, "{d}", .{i});
            defer self.allocator.free(index_str);

            const element = (try rt.vtable.getProperty(rt.context, data, index_str, self.allocator)) orelse {
                for (1..col_widths.len) |idx| {
                    try table.appendSlice("│ ");
                    for (0..col_widths[idx]) |_| try table.append(' ');
                    try table.append(' ');
                }
                try table.appendSlice("│\n");
                continue;
            };

            for (columns.items(), 1..) |col, idx| {
                try table.appendSlice("│ ");

                if (rt.vtable.isObject(rt.context, element)) {
                    const value = (try rt.vtable.getProperty(rt.context, element, col, self.allocator)) orelse {
                        for (0..col_widths[idx]) |_| try table.append(' ');
                        try table.append(' ');
                        continue;
                    };

                    const val_str = try rt.vtable.toString(rt.context, value, self.allocator);
                    defer self.allocator.free(val_str);

                    try table.appendSlice(val_str);
                    for (0..col_widths[idx] - val_str.len) |_| try table.append(' ');
                } else {
                    for (0..col_widths[idx]) |_| try table.append(' ');
                }
                try table.append(' ');
            }
            try table.appendSlice("│\n");
        }

        // Bottom border
        try table.appendSlice("└");
        for (col_widths, 0..) |width, idx| {
            for (0..width + 2) |_| try table.appendSlice("─");
            if (idx < col_widths.len - 1) {
                try table.appendSlice("┴");
            }
        }
        try table.appendSlice("┘\n");

        // Print the table
        const table_items = table.items();
        const table_value = webidl.JSValue{ .string = table_items };
        self.printer(.table, &.{table_value});
    
    }

    pub fn call_trace(self: *console, data: []const webidl.JSValue) void {

        // Step 1: Let trace be some implementation-defined stack trace representation
        // Step 2: Optionally, let formattedData be the result of Formatter(data)
        // Step 3: Incorporate formattedData as a label for trace
        // Step 4: Perform Printer("trace", « trace »)

        // If runtime is available, capture stack trace
        if (self.runtime) |rt| {
            const frames = rt.vtable.captureStackTrace(rt.context, self.allocator) catch {
                // If stack capture fails, fall back to simple trace
                self.logger(.trace, data);
                return;
            };
            defer {
                for (frames) |frame| {
                    if (frame.function_name) |name| self.allocator.free(name);
                    if (frame.file_name) |file| self.allocator.free(file);
                }
                self.allocator.free(frames);
            }

            // Format stack trace as string
            var trace_str = infra.List(u8).init(self.allocator);
            defer trace_str.deinit();

            // Add label with optional data
            if (data.len > 0) {
                const formatted = self.formatter(data) catch data;
                defer if (formatted.ptr != data.ptr) self.allocator.free(formatted);

                for (formatted) |arg| {
                    const str = switch (arg) {
                        .string => |s| s,
                        else => "[object]",
                    };
                    trace_str.appendSlice(str) catch {};
                    trace_str.append(' ') catch {};
                }
            }
            trace_str.appendSlice("Trace\n") catch {};

            // Format each stack frame
            for (frames) |frame| {
                const formatted_frame = frame.format(self.allocator) catch continue;
                defer self.allocator.free(formatted_frame);

                trace_str.appendSlice(formatted_frame) catch {};
                trace_str.append('\n') catch {};
            }

            // Print the complete stack trace
            const trace_items = trace_str.items();
            const trace_value = webidl.JSValue{ .string = trace_items };
            self.printer(.trace, &.{trace_value});
        } else {
            // Fallback: Just print with trace level (no stack capture)
            self.logger(.trace, data);
        }
    
    }

    pub fn call_warn(self: *console, data: []const webidl.JSValue) void {

        self.logger(.warn, data);
    
    }

    pub fn call_dir(self: *console, item: ?webidl.JSValue, options: ?webidl.JSValue) void {

        _ = options;
        if (item) |obj| {
            const args: [1]webidl.JSValue = .{obj};
            self.logger(.dir, &args);
        } else {
            self.logger(.dir, &.{});
        }
    
    }

    pub fn call_dirxml(self: *console, data: []const webidl.JSValue) void {

        self.logger(.dirxml, data);
    
    }

    pub fn call_count(self: *console, label: []const u8) void {

        // Step 1: Let map be the associated count map
        // Step 2-3: Get or create count
        const interned = self.internLabel(label) catch label;

        var count: u32 = 1;
        if (self.countMap.get(interned)) |existing| {
            count = existing + 1;
        }
        self.countMap.set(interned, count) catch return;

        // Step 4: Let concat be the concatenation of label, ":", " ", and ToString(map[label])
        const concat = std.fmt.allocPrint(self.allocator, "{s}: {d}", .{ label, count }) catch return;
        defer self.allocator.free(concat);

        // Step 5: Perform Logger("count", « concat »)
        const args = [_]webidl.JSValue{.{ .string = concat }};
        self.logger(.count, &args);
    
    }

    pub fn call_countReset(self: *console, label: []const u8) void {

        // Step 1: Let map be the associated count map
        const interned = self.internLabel(label) catch label;

        // Step 2: If map[label] exists, set map[label] to 0
        if (self.countMap.contains(interned)) {
            self.countMap.set(interned, 0) catch return;
        } else {
            // Step 3: Otherwise - log warning message
            const message = std.fmt.allocPrint(
                self.allocator,
                "Count for '{s}' does not exist",
                .{label},
            ) catch return;
            defer self.allocator.free(message);

            const args = [_]webidl.JSValue{.{ .string = message }};
            self.logger(.count_reset, &args);
        }
    
    }

    pub fn call_group(self: *console, data: []const webidl.JSValue) void {

        // Step 1: Let group be a new group
        // Step 2: If data is not empty, let groupLabel be result of Formatter(data)
        var group_label: ?[]const u8 = null;
        if (data.len > 0) {
            const formatted = self.formatter(data) catch null;
            if (formatted) |f| {
                // Convert formatted args to string
                if (f.len > 0 and f[0] == .string) {
                    group_label = self.allocator.dupe(u8, f[0].string) catch null;
                }
                if (f.ptr != data.ptr) {
                    self.allocator.free(f);
                }
            }
        }

        // Step 3-4: Incorporate groupLabel and set expanded by default
        const group = Group.init(group_label);

        // Step 5: Perform Printer("group", « group »)
        self.logger(.group, data);

        // Step 6: Push group onto the appropriate group stack
        self.groupStack.push(group) catch {};
    
    }

    pub fn call_groupCollapsed(self: *console, data: []const webidl.JSValue) void {

        // Step 1: Let group be a new group
        // Step 2: If data is not empty, let groupLabel be result of Formatter(data)
        var group_label: ?[]const u8 = null;
        if (data.len > 0) {
            const formatted = self.formatter(data) catch null;
            if (formatted) |f| {
                if (f.len > 0 and f[0] == .string) {
                    group_label = self.allocator.dupe(u8, f[0].string) catch null;
                }
                if (f.ptr != data.ptr) {
                    self.allocator.free(f);
                }
            }
        }

        // Step 3-4: Incorporate groupLabel and set collapsed by default
        const group = Group.initCollapsed(group_label);

        // Step 5: Perform Printer("groupCollapsed", « group »)
        self.logger(.group_collapsed, data);

        // Step 6: Push group onto the appropriate group stack
        self.groupStack.push(group) catch {};
    
    }

    pub fn call_groupEnd(self: *console) void {

        // Step 1: Pop the last group from the group stack
        if (self.groupStack.pop()) |group| {
            var g = group;
            g.deinit(self.allocator);
        }
    
    }

    pub fn call_time(self: *console, label: []const u8) void {

        const interned = self.internLabel(label) catch label;

        // Step 1: If the associated timer table contains an entry with key label, return
        if (self.timerTable.contains(interned)) {
            // Optionally report warning (spec lines 223-224)
            return;
        }

        // Step 2: Otherwise, set value to current time
        const now = infra.Moment.now();
        self.timerTable.set(interned, now) catch return;
    
    }

    pub fn call_timeLog(self: *console, label: []const u8, data: []const webidl.JSValue) void {

        const interned = self.internLabel(label) catch label;

        // Step 1: Let timerTable be the associated timer table
        // Step 2: Let startTime be timerTable[label]
        const start_time = self.timerTable.get(interned) orelse return;

        // Step 3: Let duration be string representing difference
        const now = infra.Moment.now();
        const elapsed = now.since(start_time);
        const duration_ms = elapsed.toMilliseconds();

        // Step 4: Let concat be concatenation of label, ":", " ", and duration
        const concat = std.fmt.allocPrint(
            self.allocator,
            "{s}: {d}ms",
            .{ label, duration_ms },
        ) catch return;
        defer self.allocator.free(concat);

        // Step 5: Prepend concat to data
        const args_len = 1 + data.len;
        var args = self.allocator.alloc(webidl.JSValue, args_len) catch return;
        defer self.allocator.free(args);

        args[0] = webidl.JSValue{ .string = concat };
        if (data.len > 0) {
            @memcpy(args[1..], data);
        }

        // Step 6: Perform Printer("timeLog", data)
        self.printer(.time_log, args);
    
    }

    pub fn call_timeEnd(self: *console, label: []const u8) void {

        const interned = self.internLabel(label) catch label;

        // Step 1: Let timerTable be the associated timer table
        // Step 2: Let startTime be timerTable[label]
        const start_time = self.timerTable.get(interned) orelse return;

        // Step 3: Remove timerTable[label]
        self.timerTable.remove(interned);

        // Step 4: Let duration be string representing difference
        const now = infra.Moment.now();
        const elapsed = now.since(start_time);
        const duration_ms = elapsed.toMilliseconds();

        // Step 5: Let concat be concatenation of label, ":", " ", and duration
        const concat = std.fmt.allocPrint(
            self.allocator,
            "{s}: {d}ms",
            .{ label, duration_ms },
        ) catch return;
        defer self.allocator.free(concat);

        // Step 6: Perform Printer("timeEnd", « concat »)
        const args = [_]webidl.JSValue{.{ .string = concat }};
        self.printer(.time_end, &args);
    
    }

    fn logger(self: *console, log_level: LogLevel, args: []const webidl.JSValue) void {

        // Fast path if disabled
        if (!self.enabled) return;

        // Step 1: If args is empty, return
        if (args.len == 0) return;

        // Step 2: Let first be args[0]
        const first = args[0];

        // Step 3: Let rest be all elements following first in args
        const rest = args[1..];

        // Step 4: If rest is empty, perform Printer(logLevel, « first »)
        if (rest.len == 0) {
            self.printer(log_level, &.{first});
            return;
        }

        // Step 5: Otherwise, perform Printer(logLevel, Formatter(args))
        const formatted = self.formatter(args) catch {
            // If formatting fails, print args unformatted
            self.printer(log_level, args);
            return;
        };
        defer if (formatted.ptr != args.ptr) self.allocator.free(formatted);

        self.printer(log_level, formatted);

        // Step 6: Return undefined (implicit in Zig void return)
    
    }

    fn formatter(self: *console, args: []const webidl.JSValue) ![]const webidl.JSValue {

        // Step 1: If args's size is 1, return args
        if (args.len == 1) return args;

        // Step 2: Let target be the first element of args
        const target = args[0];

        // Step 3: Let current be the second element of args
        const current = args[1];

        // Convert target to string for format specifier scanning
        const target_str = switch (target) {
            .string => |s| s,
            else => {
                // Can't process format specifiers on non-strings
                return args;
            },
        };

        // Step 4: Find the first possible format specifier from left to right in target
        const first_spec_match = blk: {
            var specs = try format.findAllSpecifiers(self.allocator, target_str);
            defer specs.deinit();

            if (specs.size() > 0) {
                break :blk specs.get(0);
            } else {
                break :blk null;
            }
        };

        // Step 5: If no format specifier was found, return args
        if (first_spec_match == null) return args;

        const spec_info = first_spec_match.?;

        // Step 6: Otherwise (a specifier was found)
        // Convert current arg based on specifier type
        const converted = try self.convertForSpecifier(current, spec_info.spec);
        defer self.allocator.free(converted);

        // Step 6.7: Replace specifier in target with converted
        var new_target_buf = infra.List(u8).init(self.allocator);
        defer new_target_buf.deinit();

        // Append text before specifier
        try new_target_buf.appendSlice(target_str[0..spec_info.index]);
        // Append converted value
        try new_target_buf.appendSlice(converted);
        // Append text after specifier (skip the 2-char specifier: %s, %d, etc.)
        try new_target_buf.appendSlice(target_str[spec_info.index + 2 ..]);

        const new_target_str = try self.allocator.dupe(u8, new_target_buf.items());

        // Step 7: Let result be a list containing target + elements from third onward
        const result_len = 1 + (if (args.len > 2) args.len - 2 else 0);
        var result = try self.allocator.alloc(webidl.JSValue, result_len);

        result[0] = webidl.JSValue{ .string = new_target_str };

        // Copy remaining args (starting from third element, index 2)
        if (args.len > 2) {
            @memcpy(result[1..], args[2..]);
        }

        // Step 8: Return Formatter(result) - RECURSIVE CALL
        const final_result = try self.formatter(result);

        // Clean up intermediate allocations
        if (final_result.ptr != result.ptr) {
            var string_still_used = false;
            for (final_result) |item| {
                if (item == .string and item.string.ptr == new_target_str.ptr) {
                    string_still_used = true;
                    break;
                }
            }
            if (!string_still_used) {
                self.allocator.free(new_target_str);
            }
            self.allocator.free(result);
        }

        return final_result;
    
    }

    fn convertForSpecifier(self: *console, value: webidl.JSValue, spec: format.FormatSpec) ![]const u8 {

        // If runtime is available, use it for type conversions
        if (self.runtime) |rt| {
            return switch (spec) {
                .string => try rt.vtable.toString(rt.context, value, self.allocator),
                .integer => {
                    const int_val = try rt.vtable.toInteger(rt.context, value);
                    return try std.fmt.allocPrint(self.allocator, "{d}", .{int_val});
                },
                .float => {
                    const float_val = try rt.vtable.toFloat(rt.context, value);
                    return try std.fmt.allocPrint(self.allocator, "{d}", .{float_val});
                },
                .optimal, .object => try rt.vtable.toString(rt.context, value, self.allocator),
                .css => try self.allocator.dupe(u8, ""),
            };
        }

        // Fallback: Use simple conversions when no runtime available
        return switch (spec) {
            .string => switch (value) {
                .string => |s| try self.allocator.dupe(u8, s),
                .number => |n| try std.fmt.allocPrint(self.allocator, "{d}", .{n}),
                .boolean => |b| try self.allocator.dupe(u8, if (b) "true" else "false"),
                .null => try self.allocator.dupe(u8, "null"),
                .undefined => try self.allocator.dupe(u8, "undefined"),
            },
            .integer => switch (value) {
                .string => |s| blk: {
                    const parsed = std.fmt.parseInt(i32, s, 10) catch 0;
                    break :blk try std.fmt.allocPrint(self.allocator, "{d}", .{parsed});
                },
                .number => |n| try std.fmt.allocPrint(self.allocator, "{d}", .{@as(i32, @intFromFloat(n))}),
                .boolean => |b| try std.fmt.allocPrint(self.allocator, "{d}", .{if (b) @as(i32, 1) else @as(i32, 0)}),
                .null => try self.allocator.dupe(u8, "0"),
                .undefined => try self.allocator.dupe(u8, "NaN"),
            },
            .float => switch (value) {
                .string => |s| blk: {
                    const parsed = std.fmt.parseFloat(f64, s) catch std.math.nan(f64);
                    break :blk try std.fmt.allocPrint(self.allocator, "{d}", .{parsed});
                },
                .number => |n| try std.fmt.allocPrint(self.allocator, "{d}", .{n}),
                .boolean => |b| try std.fmt.allocPrint(self.allocator, "{d}", .{if (b) @as(f64, 1.0) else @as(f64, 0.0)}),
                .null => try self.allocator.dupe(u8, "0"),
                .undefined => try self.allocator.dupe(u8, "NaN"),
            },
            .optimal, .object => switch (value) {
                .string => |s| try self.allocator.dupe(u8, s),
                .number => |n| try std.fmt.allocPrint(self.allocator, "{d}", .{n}),
                .boolean => |b| try self.allocator.dupe(u8, if (b) "true" else "false"),
                .null => try self.allocator.dupe(u8, "null"),
                .undefined => try self.allocator.dupe(u8, "undefined"),
            },
            .css => try self.allocator.dupe(u8, ""),
        };
    
    }

    fn printer(self: *console, log_level: LogLevel, args: []const webidl.JSValue) void {

        self.printerWithOwnedStrings(log_level, args, &.{});
    
    }

    fn printerWithOwnedStrings(self: *console, log_level: LogLevel, args: []const webidl.JSValue, owned_strings: []const []const u8) void {

        const indent = self.groupStack.size();
        const timestamp = infra.Moment.now();

        // Create message
        var message = Message.init(log_level, timestamp, args, indent, self.allocator) catch return;

        // Track owned strings
        for (owned_strings) |owned_str| {
            message.takeOwnership(owned_str) catch {};
        }

        // Add to buffer
        self.messageBuffer.push(message);

        // If print function is set, format and output immediately
        if (self.printFn) |printFn| {
            const formatted = message.format(self.allocator) catch return;
            defer self.allocator.free(formatted);
            printFn(formatted);
        }
    
    }

};


