// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

// Test file to check if child interfaces inherit parent mixins

// Test Case 1: Single mixin with field
pub const TestMixin = struct {
    // ========================================================================
    // TestMixin fields
    // ========================================================================
    mixin_field: u32 = 42,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "TestMixin",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Parent interface that includes the mixin
/// Runtime type tag for Parent hierarchy.
/// Used for safe downcasting from ParentBase to derived types.
pub const ParentTypeTag = enum {
    Parent,
    Child,
};

/// Base struct for Parent hierarchy polymorphism.
/// All Parent-derived types have `base: ParentBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ParentBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: ParentTypeTag,

    parent_field: u32 = 100,

    // ========================================================================
    // Polymorphic downcasting
    // ========================================================================
    // 
    // Downcasting from base to derived type is done via @ptrCast:
    // 
    //   const base: *NodeBase = element.toBase();
    //   const elem: *Element = @ptrCast(@alignCast(base));
    // 
    // This is safe because all derived types have `base` as their first field.
    // For type-safe downcasting, add runtime type checking in your code.
    // 
    // This base type has 1 derived type(s):
    //   - Child (upcast: Child.toBase(), downcast: @ptrCast(@alignCast(base)))
    //

};

const TestMixin = @import("test_mixin").TestMixin;
pub const Parent = struct {
    // ========================================================================
    // Fields from TestMixin mixin
    // ========================================================================
    mixin_field: u32 = 42,

    // ========================================================================
    // Parent fields
    // ========================================================================
    parent_field: u32 = 100,

    pub const includes = .{TestMixin};
    pub fn init(allocator: std.mem.Allocator, mixin_field: u32, parent_field: u32) !Parent {
        return try Parent.initFields(allocator, &.{
            .mixin_field = mixin_field,
            .parent_field = parent_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { mixin_field: u32, parent_field: u32, }) !Parent {
        return .{
            .mixin_field = fields.mixin_field,
            .parent_field = fields.parent_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Parent",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Child interface that extends Parent
// Expected: Child automatically gets mixin_field from Parent's TestMixin
const ParentBase = @import("parent").ParentBase;
pub const Child = struct {
    base: ParentBase,

    // ========================================================================
    // Child fields
    // ========================================================================
    child_field: u32 = 200,

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to ParentBase for type-generic code.
    pub fn toBase(self: *Child) *ParentBase {
        return &self.base;
    }
    pub fn init(allocator: std.mem.Allocator, parent_field: u32, mixin_field: u32, child_field: u32) !Child {
        return try Child.initFields(allocator, &.{
            .parent_field = parent_field,
            .mixin_field = mixin_field,
            .child_field = child_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_field: u32, mixin_field: u32, child_field: u32, }) !Child {
        return .{
            .parent_field = fields.parent_field,
            .mixin_field = fields.mixin_field,
            .child_field = fields.child_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Child",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Test Case 2: Multiple mixins with fields
pub const MixinA = struct {
    // ========================================================================
    // MixinA fields
    // ========================================================================
    field_a: u32 = 10,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "MixinA",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

pub const MixinB = struct {
    // ========================================================================
    // MixinB fields
    // ========================================================================
    field_b: u32 = 20,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "MixinB",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

/// Runtime type tag for ParentMulti hierarchy.
/// Used for safe downcasting from ParentMultiBase to derived types.
pub const ParentMultiTypeTag = enum {
    ParentMulti,
    ChildMulti,
    GrandChild,
};

/// Base struct for ParentMulti hierarchy polymorphism.
/// All ParentMulti-derived types have `base: ParentMultiBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ParentMultiBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: ParentMultiTypeTag,

    parent_multi_field: u32 = 300,

    // ========================================================================
    // Polymorphic downcasting
    // ========================================================================
    // 
    // Downcasting from base to derived type is done via @ptrCast:
    // 
    //   const base: *NodeBase = element.toBase();
    //   const elem: *Element = @ptrCast(@alignCast(base));
    // 
    // This is safe because all derived types have `base` as their first field.
    // For type-safe downcasting, add runtime type checking in your code.
    // 
    // This base type has 2 derived type(s):
    //   - ChildMulti (upcast: ChildMulti.toBase(), downcast: @ptrCast(@alignCast(base)))
    //   - GrandChild (upcast: GrandChild.toBase(), downcast: @ptrCast(@alignCast(base)))
    //

};

const MixinA = @import("mixin_a").MixinA;
const MixinB = @import("mixin_b").MixinB;
pub const ParentMulti = struct {
    // ========================================================================
    // Fields from MixinA mixin
    // ========================================================================
    field_a: u32 = 10,

    // ========================================================================
    // Fields from MixinB mixin
    // ========================================================================
    field_b: u32 = 20,

    // ========================================================================
    // ParentMulti fields
    // ========================================================================
    parent_multi_field: u32 = 300,

    pub const includes = .{ MixinA, MixinB };
    pub fn init(allocator: std.mem.Allocator, field_a: u32, field_b: u32, parent_multi_field: u32) !ParentMulti {
        return try ParentMulti.initFields(allocator, &.{
            .field_a = field_a,
            .field_b = field_b,
            .parent_multi_field = parent_multi_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { field_a: u32, field_b: u32, parent_multi_field: u32, }) !ParentMulti {
        return .{
            .field_a = fields.field_a,
            .field_b = fields.field_b,
            .parent_multi_field = fields.parent_multi_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ParentMulti",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Expected: ChildMulti gets field_a, field_b, parent_multi_field
/// Runtime type tag for ChildMulti hierarchy.
/// Used for safe downcasting from ChildMultiBase to derived types.
pub const ChildMultiTypeTag = enum {
    ChildMulti,
    GrandChild,
};

/// Base struct for ChildMulti hierarchy polymorphism.
/// All ChildMulti-derived types have `base: ChildMultiBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ChildMultiBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: ChildMultiTypeTag,

    parent_multi_field: u32 = 300,
    field_b: u32 = 20,
    field_a: u32 = 10,

    child_multi_field: u32 = 400,

    // ========================================================================
    // Polymorphic downcasting
    // ========================================================================
    // 
    // Downcasting from base to derived type is done via @ptrCast:
    // 
    //   const base: *NodeBase = element.toBase();
    //   const elem: *Element = @ptrCast(@alignCast(base));
    // 
    // This is safe because all derived types have `base` as their first field.
    // For type-safe downcasting, add runtime type checking in your code.
    // 
    // This base type has 1 derived type(s):
    //   - GrandChild (upcast: GrandChild.toBase(), downcast: @ptrCast(@alignCast(base)))
    //

};

const ParentMultiBase = @import("parent_multi").ParentMultiBase;
pub const ChildMulti = struct {
    base: ParentMultiBase,

    // ========================================================================
    // ChildMulti fields
    // ========================================================================
    child_multi_field: u32 = 400,

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to ParentMultiBase for type-generic code.
    pub fn toBase(self: *ChildMulti) *ParentMultiBase {
        return &self.base;
    }
    pub fn init(allocator: std.mem.Allocator, parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32) !ChildMulti {
        return try ChildMulti.initFields(allocator, &.{
            .parent_multi_field = parent_multi_field,
            .field_b = field_b,
            .field_a = field_a,
            .child_multi_field = child_multi_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, }) !ChildMulti {
        return .{
            .parent_multi_field = fields.parent_multi_field,
            .field_b = fields.field_b,
            .field_a = fields.field_a,
            .child_multi_field = fields.child_multi_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ChildMulti",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Test Case 3: Grandchild (3-level inheritance)
// Expected: GrandChild gets field_a, field_b from ParentMulti's mixins,
//           plus parent_multi_field, child_multi_field
const ChildMultiBase = @import("child_multi").ChildMultiBase;
pub const GrandChild = struct {
    base: ChildMultiBase,

    // ========================================================================
    // GrandChild fields
    // ========================================================================
    grandchild_field: u32 = 500,

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to ChildMultiBase for type-generic code.
    pub fn toBase(self: *GrandChild) *ChildMultiBase {
        return &self.base;
    }
    pub fn init(allocator: std.mem.Allocator, parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, grandchild_field: u32) !GrandChild {
        return try GrandChild.initFields(allocator, &.{
            .parent_multi_field = parent_multi_field,
            .field_b = field_b,
            .field_a = field_a,
            .child_multi_field = child_multi_field,
            .grandchild_field = grandchild_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, grandchild_field: u32, }) !GrandChild {
        return .{
            .parent_multi_field = fields.parent_multi_field,
            .field_b = fields.field_b,
            .field_a = fields.field_a,
            .child_multi_field = fields.child_multi_field,
            .grandchild_field = fields.grandchild_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "GrandChild",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

