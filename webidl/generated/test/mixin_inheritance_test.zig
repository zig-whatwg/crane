// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

// Test file to check if child interfaces inherit parent mixins

// Test Case 1: Single mixin with field
pub const TestMixin = struct {
    // ========================================================================
    // TestMixin fields
    // ========================================================================
    mixin_field: u32 = 42,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "TestMixin",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Parent interface that includes the mixin
/// Runtime type tag for Parent hierarchy.
/// Used for safe downcasting from ParentBase to derived types.
pub const ParentTypeTag = enum {
    Parent,
    Child,
};

/// Base struct for Parent hierarchy polymorphism.
/// All Parent-derived types have `base: ParentBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ParentBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: ParentTypeTag,

    parent_field: u32 = 100,

    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for Child.
    /// Use this in Child.init() to properly initialize the base field.
    pub fn initForChild(allocator: Allocator) ParentBase {
        return .{
            .type_tag = .Child,
            .allocator = allocator,
        };
    }


    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *ParentBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    /// 
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *ParentBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(ParentTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const ParentBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(ParentTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in Parent hierarchy:
    //   - Child
    //

};

const TestMixin = @import("test_mixin").TestMixin;
pub const Parent = struct {
    // ========================================================================
    // Fields from TestMixin mixin
    // ========================================================================
    mixin_field: u32 = 42,

    // ========================================================================
    // Parent fields
    // ========================================================================
    parent_field: u32 = 100,

    pub const includes = .{TestMixin};
    pub fn init(allocator: std.mem.Allocator, mixin_field: u32, parent_field: u32) !Parent {
        return try Parent.initFields(allocator, &.{
            .mixin_field = mixin_field,
            .parent_field = parent_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { mixin_field: u32, parent_field: u32, }) !Parent {
        return .{
            .mixin_field = fields.mixin_field,
            .parent_field = fields.parent_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Parent",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Child interface that extends Parent
// Expected: Child automatically gets mixin_field from Parent's TestMixin
const ParentBase = @import("parent").ParentBase;
pub const Child = struct {
    base: ParentBase,

    // ========================================================================
    // Child fields
    // ========================================================================
    child_field: u32 = 200,

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to ParentBase for type-generic code.
    pub fn toBase(self: *Child) *ParentBase {
        return &self.base;
    }
    pub fn init(allocator: std.mem.Allocator, parent_field: u32, mixin_field: u32, child_field: u32) !Child {
        return try Child.initFields(allocator, &.{
            .parent_field = parent_field,
            .mixin_field = mixin_field,
            .child_field = child_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_field: u32, mixin_field: u32, child_field: u32, }) !Child {
        return .{
            .parent_field = fields.parent_field,
            .mixin_field = fields.mixin_field,
            .child_field = fields.child_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Child",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Test Case 2: Multiple mixins with fields
pub const MixinA = struct {
    // ========================================================================
    // MixinA fields
    // ========================================================================
    field_a: u32 = 10,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "MixinA",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

pub const MixinB = struct {
    // ========================================================================
    // MixinB fields
    // ========================================================================
    field_b: u32 = 20,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "MixinB",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

/// Runtime type tag for ParentMulti hierarchy.
/// Used for safe downcasting from ParentMultiBase to derived types.
pub const ParentMultiTypeTag = enum {
    ParentMulti,
    ChildMulti,
    GrandChild,
};

/// Base struct for ParentMulti hierarchy polymorphism.
/// All ParentMulti-derived types have `base: ParentMultiBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ParentMultiBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: ParentMultiTypeTag,

    parent_multi_field: u32 = 300,

    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for ChildMulti.
    /// Use this in ChildMulti.init() to properly initialize the base field.
    pub fn initForChildMulti(allocator: Allocator) ParentMultiBase {
        return .{
            .type_tag = .ChildMulti,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for GrandChild.
    /// Use this in GrandChild.init() to properly initialize the base field.
    pub fn initForGrandChild(allocator: Allocator) ParentMultiBase {
        return .{
            .type_tag = .GrandChild,
            .allocator = allocator,
        };
    }


    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *ParentMultiBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    /// 
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *ParentMultiBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(ParentMultiTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const ParentMultiBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(ParentMultiTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in ParentMulti hierarchy:
    //   - ChildMulti
    //   - GrandChild
    //

};

const MixinA = @import("mixin_a").MixinA;
const MixinB = @import("mixin_b").MixinB;
pub const ParentMulti = struct {
    // ========================================================================
    // Fields from MixinA mixin
    // ========================================================================
    field_a: u32 = 10,

    // ========================================================================
    // Fields from MixinB mixin
    // ========================================================================
    field_b: u32 = 20,

    // ========================================================================
    // ParentMulti fields
    // ========================================================================
    parent_multi_field: u32 = 300,

    pub const includes = .{ MixinA, MixinB };
    pub fn init(allocator: std.mem.Allocator, field_a: u32, field_b: u32, parent_multi_field: u32) !ParentMulti {
        return try ParentMulti.initFields(allocator, &.{
            .field_a = field_a,
            .field_b = field_b,
            .parent_multi_field = parent_multi_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { field_a: u32, field_b: u32, parent_multi_field: u32, }) !ParentMulti {
        return .{
            .field_a = fields.field_a,
            .field_b = fields.field_b,
            .parent_multi_field = fields.parent_multi_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ParentMulti",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Expected: ChildMulti gets field_a, field_b, parent_multi_field
/// Runtime type tag for ChildMulti hierarchy.
/// Used for safe downcasting from ChildMultiBase to derived types.
pub const ChildMultiTypeTag = enum {
    ChildMulti,
    GrandChild,
};

/// Base struct for ChildMulti hierarchy polymorphism.
/// All ChildMulti-derived types have `base: ChildMultiBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ChildMultiBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: ChildMultiTypeTag,

    parent_multi_field: u32 = 300,
    field_b: u32 = 20,
    field_a: u32 = 10,

    child_multi_field: u32 = 400,

    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for GrandChild.
    /// Use this in GrandChild.init() to properly initialize the base field.
    pub fn initForGrandChild(allocator: Allocator) ChildMultiBase {
        return .{
            .type_tag = .GrandChild,
            .allocator = allocator,
        };
    }


    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *ChildMultiBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    /// 
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *ChildMultiBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(ChildMultiTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const ChildMultiBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(ChildMultiTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in ChildMulti hierarchy:
    //   - GrandChild
    //

};

const ParentMultiBase = @import("parent_multi").ParentMultiBase;
pub const ChildMulti = struct {
    base: ParentMultiBase,

    // ========================================================================
    // ChildMulti fields
    // ========================================================================
    child_multi_field: u32 = 400,

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to ParentMultiBase for type-generic code.
    pub fn toBase(self: *ChildMulti) *ParentMultiBase {
        return &self.base;
    }
    pub fn init(allocator: std.mem.Allocator, parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32) !ChildMulti {
        return try ChildMulti.initFields(allocator, &.{
            .parent_multi_field = parent_multi_field,
            .field_b = field_b,
            .field_a = field_a,
            .child_multi_field = child_multi_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, }) !ChildMulti {
        return .{
            .parent_multi_field = fields.parent_multi_field,
            .field_b = fields.field_b,
            .field_a = fields.field_a,
            .child_multi_field = fields.child_multi_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ChildMulti",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Test Case 3: Grandchild (3-level inheritance)
// Expected: GrandChild gets field_a, field_b from ParentMulti's mixins,
//           plus parent_multi_field, child_multi_field
const ChildMultiBase = @import("child_multi").ChildMultiBase;
pub const GrandChild = struct {
    base: ChildMultiBase,

    // ========================================================================
    // GrandChild fields
    // ========================================================================
    grandchild_field: u32 = 500,

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to ChildMultiBase for type-generic code.
    pub fn toBase(self: *GrandChild) *ChildMultiBase {
        return &self.base;
    }
    pub fn init(allocator: std.mem.Allocator, parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, grandchild_field: u32) !GrandChild {
        return try GrandChild.initFields(allocator, &.{
            .parent_multi_field = parent_multi_field,
            .field_b = field_b,
            .field_a = field_a,
            .child_multi_field = child_multi_field,
            .grandchild_field = grandchild_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, grandchild_field: u32, }) !GrandChild {
        return .{
            .parent_multi_field = fields.parent_multi_field,
            .field_b = fields.field_b,
            .field_a = fields.field_a,
            .child_multi_field = fields.child_multi_field,
            .grandchild_field = fields.grandchild_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "GrandChild",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

