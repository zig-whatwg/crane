// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

// Test file to check if child interfaces inherit parent mixins

// Test Case 1: Single mixin with field
pub const TestMixin = struct {
    // ========================================================================
    // TestMixin fields
    // ========================================================================
    mixin_field: u32 = 42,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "TestMixin",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Parent interface that includes the mixin
/// Base struct for Parent hierarchy polymorphism.
/// All Parent-derived types have `base: ParentBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ParentBase = struct {
    parent_field: u32 = 100,

    // Safe downcast to Child
    // Returns null if this is not a Child instance
    // TODO: Fix circular dependency - Child imports Parent, so we can't import Child here
    // Will be implemented when we modify derived classes to have base: field
    // Then Child can have: pub fn toBase(node: *Child) *ParentBase { return &node.base; }
    // pub fn asChild(base: *ParentBase) ?*Child {
    //     return @ptrCast(@alignCast(base));
    // }

};

const TestMixin = @import("test_mixin").TestMixin;
pub const Parent = struct {
    // ========================================================================
    // Fields from TestMixin mixin
    // ========================================================================
    mixin_field: u32 = 42,

    // ========================================================================
    // Parent fields
    // ========================================================================
    parent_field: u32 = 100,

    pub const includes = .{TestMixin};
    pub fn init(allocator: std.mem.Allocator, mixin_field: u32, parent_field: u32) !Parent {
        return try Parent.initFields(allocator, &.{
            .mixin_field = mixin_field,
            .parent_field = parent_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { mixin_field: u32, parent_field: u32, }) !Parent {
        return .{
            .mixin_field = fields.mixin_field,
            .parent_field = fields.parent_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Parent",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Child interface that extends Parent
// Expected: Child automatically gets mixin_field from Parent's TestMixin
pub const Child = struct {
    parent_field: u32 = 100,
    mixin_field: u32 = 42,

    // ========================================================================
    // Child fields
    // ========================================================================
    child_field: u32 = 200,
    pub fn init(allocator: std.mem.Allocator, parent_field: u32, mixin_field: u32, child_field: u32) !Child {
        return try Child.initFields(allocator, &.{
            .parent_field = parent_field,
            .mixin_field = mixin_field,
            .child_field = child_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_field: u32, mixin_field: u32, child_field: u32, }) !Child {
        return .{
            .parent_field = fields.parent_field,
            .mixin_field = fields.mixin_field,
            .child_field = fields.child_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Child",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Test Case 2: Multiple mixins with fields
pub const MixinA = struct {
    // ========================================================================
    // MixinA fields
    // ========================================================================
    field_a: u32 = 10,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "MixinA",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

pub const MixinB = struct {
    // ========================================================================
    // MixinB fields
    // ========================================================================
    field_b: u32 = 20,

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "MixinB",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

/// Base struct for ParentMulti hierarchy polymorphism.
/// All ParentMulti-derived types have `base: ParentMultiBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const ParentMultiBase = struct {
    parent_multi_field: u32 = 300,

    // Safe downcast to ChildMulti
    // Returns null if this is not a ChildMulti instance
    // TODO: Fix circular dependency - ChildMulti imports ParentMulti, so we can't import ChildMulti here
    // Will be implemented when we modify derived classes to have base: field
    // Then ChildMulti can have: pub fn toBase(node: *ChildMulti) *ParentMultiBase { return &node.base; }
    // pub fn asChildMulti(base: *ParentMultiBase) ?*ChildMulti {
    //     return @ptrCast(@alignCast(base));
    // }

    // Safe downcast to GrandChild
    // Returns null if this is not a GrandChild instance
    // TODO: Fix circular dependency - GrandChild imports ParentMulti, so we can't import GrandChild here
    // Will be implemented when we modify derived classes to have base: field
    // Then GrandChild can have: pub fn toBase(node: *GrandChild) *ParentMultiBase { return &node.base; }
    // pub fn asGrandChild(base: *ParentMultiBase) ?*GrandChild {
    //     return @ptrCast(@alignCast(base));
    // }

};

const MixinA = @import("mixin_a").MixinA;
const MixinB = @import("mixin_b").MixinB;
pub const ParentMulti = struct {
    // ========================================================================
    // Fields from MixinA mixin
    // ========================================================================
    field_a: u32 = 10,

    // ========================================================================
    // Fields from MixinB mixin
    // ========================================================================
    field_b: u32 = 20,

    // ========================================================================
    // ParentMulti fields
    // ========================================================================
    parent_multi_field: u32 = 300,

    pub const includes = .{ MixinA, MixinB };
    pub fn init(allocator: std.mem.Allocator, field_a: u32, field_b: u32, parent_multi_field: u32) !ParentMulti {
        return try ParentMulti.initFields(allocator, &.{
            .field_a = field_a,
            .field_b = field_b,
            .parent_multi_field = parent_multi_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { field_a: u32, field_b: u32, parent_multi_field: u32, }) !ParentMulti {
        return .{
            .field_a = fields.field_a,
            .field_b = fields.field_b,
            .parent_multi_field = fields.parent_multi_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ParentMulti",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Expected: ChildMulti gets field_a, field_b, parent_multi_field
pub const ChildMulti = struct {
    parent_multi_field: u32 = 300,
    field_b: u32 = 20,
    field_a: u32 = 10,

    // ========================================================================
    // ChildMulti fields
    // ========================================================================
    child_multi_field: u32 = 400,
    pub fn init(allocator: std.mem.Allocator, parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32) !ChildMulti {
        return try ChildMulti.initFields(allocator, &.{
            .parent_multi_field = parent_multi_field,
            .field_b = field_b,
            .field_a = field_a,
            .child_multi_field = child_multi_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, }) !ChildMulti {
        return .{
            .parent_multi_field = fields.parent_multi_field,
            .field_b = fields.field_b,
            .field_a = fields.field_a,
            .child_multi_field = fields.child_multi_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ChildMulti",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Test Case 3: Grandchild (3-level inheritance)
// Expected: GrandChild gets field_a, field_b from ParentMulti's mixins,
//           plus parent_multi_field, child_multi_field
pub const GrandChild = struct {
    parent_multi_field: u32 = 300,
    field_b: u32 = 20,
    field_a: u32 = 10,
    child_multi_field: u32 = 400,

    // ========================================================================
    // GrandChild fields
    // ========================================================================
    grandchild_field: u32 = 500,
    pub fn init(allocator: std.mem.Allocator, parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, grandchild_field: u32) !GrandChild {
        return try GrandChild.initFields(allocator, &.{
            .parent_multi_field = parent_multi_field,
            .field_b = field_b,
            .field_a = field_a,
            .child_multi_field = child_multi_field,
            .grandchild_field = grandchild_field,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { parent_multi_field: u32, field_b: u32, field_a: u32, child_multi_field: u32, grandchild_field: u32, }) !GrandChild {
        return .{
            .parent_multi_field = fields.parent_multi_field,
            .field_b = fields.field_b,
            .field_a = fields.field_a,
            .child_multi_field = fields.child_multi_field,
            .grandchild_field = fields.grandchild_field,
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "GrandChild",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

