// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const std = @import("std");
const webidl = @import("webidl");
const Allocator = @import("std.mem").Allocator;
const std = @import("std");
const webidl = @import("webidl");

pub const HTMLSlotElement = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    name: []const u8,
    assigned_nodes: std.ArrayList(*anyopaque),
    manually_assigned_nodes: std.ArrayList(*anyopaque),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !Self {

        return Self{
            .allocator = allocator,
            .name = "",
            .assigned_nodes = std.ArrayList(*anyopaque).init(allocator),
            .manually_assigned_nodes = std.ArrayList(*anyopaque).init(allocator),
        };
    
    }

    pub fn deinit(self: *Self) void {

        if (self.name.len > 0) {
            self.allocator.free(self.name);
        }
        self.assigned_nodes.deinit();
        self.manually_assigned_nodes.deinit();
    
    }

    pub fn setName(self: *Self, name: []const u8) !void {

        if (self.name.len > 0) {
            self.allocator.free(self.name);
        }
        self.name = try self.allocator.dupe(u8, name);
    
    }

    pub fn getName(self: *const Self) []const u8 {

        return self.name;
    
    }

    pub fn getAssignedNodes(self: *Self) *std.ArrayList(*anyopaque) {

        return &self.assigned_nodes;
    
    }

    pub fn getManuallyAssignedNodes(self: *Self) *std.ArrayList(*anyopaque) {

        return &self.manually_assigned_nodes;
    
    }

    pub fn hasAssignedNodes(self: *const Self) bool {

        return self.assigned_nodes.items.len > 0;
    
    }

};


