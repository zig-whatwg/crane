// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const std = @import("std");
const webidl = @import("webidl");


/// HTMLSlotElement - Represents a <slot> element in shadow DOM
///
/// TODO: This is a mock implementation. Replace with full HTML spec implementation
/// when available. The full implementation will extend HTMLElement and include:
/// - Full HTML element attributes and methods
/// - Integration with HTML parsing
/// - Complete event handling
///
/// Current mock provides ONLY the minimal interface needed for shadow DOM:
/// - name attribute (slot name)
/// - assigned_nodes list (slottables assigned to this slot)
/// - manually_assigned_nodes list (for manual slot assignment mode)

pub const HTMLSlotElement = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    name: []const u8,
    assigned_nodes: std.ArrayList(*anyopaque),
    manually_assigned_nodes: std.ArrayList(*anyopaque),

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "HTMLSlotElement",
        .kind = .interface,
    };

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !Self {

        return Self{
            .allocator = allocator,
            .name = "",
            .assigned_nodes = std.ArrayList(*anyopaque).init(allocator),
            .manually_assigned_nodes = std.ArrayList(*anyopaque).init(allocator),
        };
    
    }

    pub fn deinit(self: *HTMLSlotElement) void {
        const self_parent: *Self = @ptrCast(self);

        if (self_parent.name.len > 0) {
            self_parent.allocator.free(self_parent.name);
        }
        self_parent.assigned_nodes.deinit();
        self_parent.manually_assigned_nodes.deinit();
    
    }

    pub fn setName(self: *HTMLSlotElement, name: []const u8) !void {
        const self_parent: *Self = @ptrCast(self);

        if (self_parent.name.len > 0) {
            self_parent.allocator.free(self_parent.name);
        }
        self_parent.name = try self_parent.allocator.dupe(u8, name);
    
    }

    pub fn getName(self: *const HTMLSlotElement) []const u8 {
        const self_parent: *const Self = @ptrCast(self);

        return self_parent.name;
    
    }

    pub fn getAssignedNodes(self: *HTMLSlotElement) *std.ArrayList(*anyopaque) {
        const self_parent: *Self = @ptrCast(self);

        return &self_parent.assigned_nodes;
    
    }

    pub fn getManuallyAssignedNodes(self: *HTMLSlotElement) *std.ArrayList(*anyopaque) {
        const self_parent: *Self = @ptrCast(self);

        return &self_parent.manually_assigned_nodes;
    
    }

    pub fn hasAssignedNodes(self: *const HTMLSlotElement) bool {
        const self_parent: *const Self = @ptrCast(self);

        return self_parent.assigned_nodes.items.len > 0;
    
    }

};


// ============================================================================
// Tests
// ============================================================================

test "HTMLSlotElement - initialization" {
    const allocator = std.testing.allocator;

    var slot = try HTMLSlotElement.init(allocator);
    defer slot.deinit();

    // Default name is empty string
    try std.testing.expectEqualStrings("", slot.getName());

    // Lists are initially empty
    try std.testing.expectEqual(@as(usize, 0), slot.assigned_nodes.items.len);
    try std.testing.expectEqual(@as(usize, 0), slot.manually_assigned_nodes.items.len);
    try std.testing.expect(!slot.hasAssignedNodes());
}

test "HTMLSlotElement - set and get name" {
    const allocator = std.testing.allocator;

    var slot = try HTMLSlotElement.init(allocator);
    defer slot.deinit();

    try slot.setName("header");
    try std.testing.expectEqualStrings("header", slot.getName());

    // Change name
    try slot.setName("footer");
    try std.testing.expectEqualStrings("footer", slot.getName());
}

test "HTMLSlotElement - assigned nodes" {
    const allocator = std.testing.allocator;

    var slot = try HTMLSlotElement.init(allocator);
    defer slot.deinit();

    // Add some mock nodes
    var dummy1: u32 = 1;
    var dummy2: u32 = 2;

    try slot.assigned_nodes.append(@ptrCast(&dummy1));
    try slot.assigned_nodes.append(@ptrCast(&dummy2));

    try std.testing.expect(slot.hasAssignedNodes());
    try std.testing.expectEqual(@as(usize, 2), slot.assigned_nodes.items.len);
}


