// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const infra = @import("infra");
const std = @import("std");
const webidl = @import("webidl");


/// HTMLSlotElement - Represents a <slot> element in shadow DOM
///
/// TODO: This is a mock implementation. Replace with full HTML spec implementation
/// when available. The full implementation will extend HTMLElement and include:
/// - Full HTML element attributes and methods
/// - Integration with HTML parsing
/// - Complete event handling
///
/// Current mock provides ONLY the minimal interface needed for shadow DOM:
/// - name attribute (slot name)
/// - assigned_nodes list (slottables assigned to this slot)
/// - manually_assigned_nodes list (for manual slot assignment mode)

/// HTMLSlotElement - Represents a <slot> element in shadow DOM
/// 
/// TODO: This is a mock implementation. Replace with full HTML spec implementation
/// when available. The full implementation will extend HTMLElement and include:
/// - Full HTML element attributes and methods
/// - Integration with HTML parsing
/// - Complete event handling
/// 
/// Current mock provides ONLY the minimal interface needed for shadow DOM:
/// - name attribute (slot name)
/// - assigned_nodes list (slottables assigned to this slot)
/// - manually_assigned_nodes list (for manual slot assignment mode)
pub const HTMLSlotElement = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    /// Allocator for managing slot data
    allocator: std.mem.Allocator,
    /// Slot name (DOM ยง4.8.2.3)
    /// Default is empty string
    name: []const u8,
    /// Assigned nodes list (DOM ยง4.8.2.3)
    /// List of slottables assigned to this slot
    /// Initially empty, updated by assign slottables algorithm
    assigned_nodes: infra.List(*anyopaque),
    /// Manually assigned nodes list (DOM ยง4.8.2.5)
    /// For manual slot assignment mode
    /// Initially empty
    manually_assigned_nodes: infra.List(*anyopaque),

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "HTMLSlotElement",
        .kind = .interface,
    };

    // ========================================================================
    // Methods
    // ========================================================================

    /// Initialize a new HTMLSlotElement
    pub fn init(allocator: std.mem.Allocator) !Self {

        return Self{
            .allocator = allocator,
            .name = "",
            .assigned_nodes = infra.List(*anyopaque).init(allocator),
            .manually_assigned_nodes = infra.List(*anyopaque).init(allocator),
        };
    
    }

    /// Clean up resources
    pub fn deinit(self: *HTMLSlotElement) void {
        const self_parent = self;

        if (self_parent.name.len > 0) {
            self_parent.allocator.free(self_parent.name);
        }
        self_parent.assigned_nodes.deinit();
        self_parent.manually_assigned_nodes.deinit();
    
    }

    /// Set the slot name
    pub fn setName(self: *HTMLSlotElement, name: []const u8) !void {
        const self_parent = self;

        if (self_parent.name.len > 0) {
            self_parent.allocator.free(self_parent.name);
        }
        self_parent.name = try self_parent.allocator.dupe(u8, name);
    
    }

    /// Get the slot name
    pub fn getName(self: *const HTMLSlotElement) []const u8 {
        const self_parent = self;

        return self_parent.name;
    
    }

    /// Get assigned nodes list
    pub fn getAssignedNodes(self: *HTMLSlotElement) *infra.List(*anyopaque) {
        const self_parent = self;

        return &self_parent.assigned_nodes;
    
    }

    /// Get manually assigned nodes list
    pub fn getManuallyAssignedNodes(self: *HTMLSlotElement) *infra.List(*anyopaque) {
        const self_parent = self;

        return &self_parent.manually_assigned_nodes;
    
    }

    /// Check if this slot has any assigned nodes
    pub fn hasAssignedNodes(self: *const HTMLSlotElement) bool {
        const self_parent = self;

        return self_parent.assigned_nodes.len > 0;
    
    }

};


// ============================================================================
// Tests
// ============================================================================


