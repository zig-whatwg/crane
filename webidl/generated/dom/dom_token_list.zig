// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! DOMTokenList interface per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-domtokenlist
//! Section: 4.8 "Interface DOMTokenList"
//!
//! DOMTokenList represents a set of space-separated tokens (e.g., class list).

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

// Forward declaration for Element (will be used for update steps)
const element_mod = @import("element");
pub const Element = element_mod.Element;

/// DOM operation errors
const DOMError = error{
    /// SyntaxError - Token is empty string
    SyntaxError,

    /// InvalidCharacterError - Token contains ASCII whitespace
    InvalidCharacterError,

    /// TypeError - No supported tokens defined for this attribute
    TypeError,
};
/// DOMTokenList interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=Window]
/// interface DOMTokenList {
/// readonly attribute unsigned long length;
/// getter DOMString? item(unsigned long index);
/// boolean contains(DOMString token);
/// [CEReactions] undefined add(DOMString... tokens);
/// [CEReactions] undefined remove(DOMString... tokens);
/// [CEReactions] boolean toggle(DOMString token, optional boolean force);
/// [CEReactions] boolean replace(DOMString token, DOMString newToken);
/// boolean supports(DOMString token);
/// [CEReactions] stringifier attribute DOMString value;
/// iterable<DOMString>;
/// };
/// ```
/// 
/// From spec:
/// - Has an associated token set (a set), initially empty
/// - Has an associated element and attribute's local name
/// - Token set is synchronized with the element's attribute
pub const DOMTokenList = struct {
    allocator: std.mem.Allocator,
    /// Token set (ordered set of tokens)
    /// 
    /// From spec: "A DOMTokenList object has an associated token set (a set),
    /// which is initially empty."
    tokenSet: infra.OrderedSet([]const u8),
    /// Associated element (nullable for cases where element may not be available)
    /// 
    /// From spec: "A DOMTokenList object also has an associated element and
    /// an attribute's local name."
    associatedElement: ?*Element,
    /// Associated attribute's local name (e.g., "class")
    /// 
    /// From spec: "an attribute's local name"
    attributeLocalName: []const u8,
    /// Supported tokens (optional - for validation)
    /// 
    /// From spec: "Specifications may define supported tokens for a DOMTokenList's
    /// associated attribute's local name."
    supportedTokens: ?[]const []const u8,

    /// Create a new DOMTokenList
    /// 
    /// Spec: § 4.8 "When a DOMTokenList object is created" (steps 1-4)
    pub fn init(
        allocator: std.mem.Allocator,
        associatedElement: ?*Element,
        attributeLocalName: []const u8,
        supportedTokens: ?[]const []const u8,
    ) !*DOMTokenList {
        const self = try allocator.create(DOMTokenList);
        errdefer allocator.destroy(self);

        // Allocate copy of attribute name
        const attr_name_copy = try allocator.dupe(u8, attributeLocalName);
        errdefer allocator.free(attr_name_copy);

        // Initialize token set
        var tokenSet = infra.OrderedSet([]const u8).init(allocator);
        errdefer tokenSet.deinit();

        self.* = .{
            .allocator = allocator,
            .tokenSet = tokenSet,
            .associatedElement = associatedElement,
            .attributeLocalName = attr_name_copy,
            .supportedTokens = supportedTokens,
        };

        // Step 1-4: Initialize from element's attribute value
        if (associatedElement) |elem| {
            // Get current attribute value
            const value = elem.getAttribute(attributeLocalName);
            if (value) |v| {
                try self.parseTokens(v);
            }
        }

        return self;
    }
    /// Free the DOMTokenList and its resources
    pub fn deinit(self: *DOMTokenList) void {
        // Free all tokens in the set
        for (self.tokenSet.items()) |token| {
            self.allocator.free(token);
        }
        self.tokenSet.deinit();

        // Free attribute name
        self.allocator.free(self.attributeLocalName);

        // Free the token list itself
        self.allocator.destroy(self);
    }
    /// Parse tokens from a space-separated string into token set
    /// 
    /// From spec: "set token set to value, parsed"
    fn parseTokens(self: *DOMTokenList, value: []const u8) !void {
        // Clear existing tokens
        for (self.tokenSet.items()) |token| {
            self.allocator.free(token);
        }
        self.tokenSet.clear();

        // Parse space-separated tokens
        const ascii_whitespace = &[_]u8{ '\t', '\n', '\x0C', '\r', ' ' };
        var tokens = std.mem.tokenizeAny(u8, value, ascii_whitespace);

        while (tokens.next()) |token| {
            const owned_token = try self.allocator.dupe(u8, token);
            errdefer self.allocator.free(owned_token);

            const was_added = try self.tokenSet.add(owned_token);
            if (!was_added) {
                // Duplicate - free the unused copy
                self.allocator.free(owned_token);
            }
        }
    }
    /// Validate a token (check for empty or whitespace)
    /// 
    /// Spec: § 4.8 token validation (used by add, remove, toggle, replace)
    fn validateToken(token: []const u8) !void {
        // Step 1: If token is the empty string, then throw SyntaxError
        if (token.len == 0) {
            return DOMError.SyntaxError;
        }

        // Step 2: If token contains any ASCII whitespace, then throw InvalidCharacterError
        const ascii_whitespace = &[_]u8{ '\t', '\n', '\x0C', '\r', ' ' };
        for (token) |char| {
            for (ascii_whitespace) |ws| {
                if (char == ws) {
                    return DOMError.InvalidCharacterError;
                }
            }
        }
    }
    /// Run update steps
    /// 
    /// Spec: § 4.8 "A DOMTokenList object's update steps are:"
    /// 1. If the associated element does not have an associated attribute and
    /// token set is empty, then return.
    /// 2. Set an attribute value for the associated element using associated
    /// attribute's local name and the result of running the ordered set
    /// serializer for token set.
    fn updateSteps(self: *DOMTokenList) !void {
        // Step 1: If no element or token set is empty and no attribute, return
        const elem = self.associatedElement orelse return;

        if (self.tokenSet.len() == 0) {
            // Check if attribute exists
            const has_attr = elem.hasAttribute(self.attributeLocalName);
            if (!has_attr) {
                return;
            }
        }

        // Step 2: Serialize token set and update attribute
        const serialized = try self.serialize();
        defer self.allocator.free(serialized);

        try elem.setAttribute(self.attributeLocalName, serialized);
    }
    /// Serialize token set to space-separated string
    /// 
    /// Spec: § 4.8 serialize steps
    fn serialize(self: *DOMTokenList) ![]const u8 {
        const tokens = self.tokenSet.items();

        if (tokens.len == 0) {
            return try self.allocator.dupe(u8, "");
        }

        // Calculate total length needed
        var total_len: usize = 0;
        for (tokens) |token| {
            total_len += token.len;
        }
        // Add spaces between tokens
        if (tokens.len > 1) {
            total_len += tokens.len - 1;
        }

        // Build result string
        const result = try self.allocator.alloc(u8, total_len);
        errdefer self.allocator.free(result);

        var pos: usize = 0;
        for (tokens, 0..) |token, i| {
            @memcpy(result[pos..][0..token.len], token);
            pos += token.len;

            if (i < tokens.len - 1) {
                result[pos] = ' ';
                pos += 1;
            }
        }

        return result;
    }
    /// Get length (number of tokens)
    /// 
    /// Spec: § 4.8 "The length attribute' getter must return this's token
    /// set's size."
    pub fn getLength(self: *const DOMTokenList) u32 {
        return @intCast(self.tokenSet.len());
    }
    /// Get value (serialized token set)
    /// 
    /// Spec: § 4.8 "The value attribute must return the result of running
    /// this's serialize steps."
    pub fn getValue(self: *DOMTokenList) ![]const u8 {
        // Get from element's attribute if available
        if (self.associatedElement) |elem| {
            const value = elem.getAttribute(self.attributeLocalName);
            if (value) |v| {
                return try self.allocator.dupe(u8, v);
            }
        }

        // Otherwise serialize current token set
        return try self.serialize();
    }
    /// Set value (parse and update token set)
    /// 
    /// Spec: § 4.8 "Setting the value attribute must set an attribute value
    /// for the associated element using associated attribute's local name and
    /// the given value."
    pub fn setValue(self: *DOMTokenList, value: []const u8) !void {
        if (self.associatedElement) |elem| {
            try elem.setAttribute(self.attributeLocalName, value);
            // Parse tokens from new value
            try self.parseTokens(value);
        }
    }
    /// Get item at index
    /// 
    /// Spec: § 4.8 "The item(index) method steps are:" (steps 1-2)
    pub fn item(self: *const DOMTokenList, index: u32) ?[]const u8 {
        // Step 1: If index is equal to or greater than token set's size, return null
        if (index >= self.tokenSet.len()) {
            return null;
        }

        // Step 2: Return token set[index]
        return self.tokenSet.get(index);
    }
    /// Check if token exists
    /// 
    /// Spec: § 4.8 "The contains(token) method steps are to return true if
    /// this's token set[token] exists; otherwise false."
    pub fn contains(self: *const DOMTokenList, token: []const u8) bool {
        return self.tokenSet.contains(token);
    }
    /// Add tokens
    /// 
    /// Spec: § 4.8 "The add(tokens…) method steps are:" (steps 1-3)
    pub fn add(self: *DOMTokenList, tokens: []const []const u8) !void {
        // Step 1: For each token of tokens, validate
        for (tokens) |token| {
            try validateToken(token);
        }

        // Step 2: For each token of tokens, append to token set
        for (tokens) |token| {
            // Check if already exists
            if (!self.tokenSet.contains(token)) {
                const owned_token = try self.allocator.dupe(u8, token);
                errdefer self.allocator.free(owned_token);

                _ = try self.tokenSet.add(owned_token);
            }
        }

        // Step 3: Run the update steps
        try self.updateSteps();
    }
    /// Remove tokens
    /// 
    /// Spec: § 4.8 "The remove(tokens…) method steps are:" (steps 1-3)
    pub fn remove(self: *DOMTokenList, tokens: []const []const u8) !void {
        // Step 1: For each token of tokens, validate
        for (tokens) |token| {
            try validateToken(token);
        }

        // Step 2: For each token in tokens, remove from token set
        for (tokens) |token| {
            if (self.tokenSet.remove(token)) |removed_token| {
                self.allocator.free(removed_token);
            }
        }

        // Step 3: Run the update steps
        try self.updateSteps();
    }
    /// Toggle token
    /// 
    /// Spec: § 4.8 "The toggle(token, force) method steps are:" (steps 1-5)
    pub fn toggle(self: *DOMTokenList, token: []const u8, force: ?bool) !bool {
        // Step 1: If token is the empty string, throw SyntaxError
        try validateToken(token);

        // Step 3: If token exists in token set
        if (self.tokenSet.contains(token)) {
            // Step 3.1: If force is not given or is false, remove and return false
            if (force == null or force.? == false) {
                if (self.tokenSet.remove(token)) |removed_token| {
                    self.allocator.free(removed_token);
                }
                try self.updateSteps();
                return false;
            }

            // Step 3.2: Return true
            return true;
        }

        // Step 4: Otherwise, if force not given or is true, add and return true
        if (force == null or force.? == true) {
            const owned_token = try self.allocator.dupe(u8, token);
            errdefer self.allocator.free(owned_token);

            _ = try self.tokenSet.add(owned_token);
            try self.updateSteps();
            return true;
        }

        // Step 5: Return false
        return false;
    }
    /// Replace token with newToken
    /// 
    /// Spec: § 4.8 "The replace(token, newToken) method steps are:" (steps 1-6)
    pub fn replace(self: *DOMTokenList, token: []const u8, new_token: []const u8) !bool {
        // Step 1: If either token or newToken is empty, throw SyntaxError
        try validateToken(token);
        try validateToken(new_token);

        // Step 3: If token set does not contain token, return false
        if (!self.tokenSet.contains(token)) {
            return false;
        }

        // Step 4: Replace token in token set with newToken
        // If newToken already exists, just remove token
        if (self.tokenSet.contains(new_token) and !std.mem.eql(u8, token, new_token)) {
            if (self.tokenSet.remove(token)) |removed_token| {
                self.allocator.free(removed_token);
            }
        } else {
            // Replace token with newToken
            if (self.tokenSet.remove(token)) |removed_token| {
                self.allocator.free(removed_token);
            }

            const owned_new_token = try self.allocator.dupe(u8, new_token);
            errdefer self.allocator.free(owned_new_token);

            _ = try self.tokenSet.add(owned_new_token);
        }

        // Step 5: Run the update steps
        try self.updateSteps();

        // Step 6: Return true
        return true;
    }
    /// Check if token is supported
    /// 
    /// Spec: § 4.8 "The supports(token) method steps are:" (steps 1-2)
    pub fn supports(self: *const DOMTokenList, token: []const u8) !bool {
        // Step 1: Let result be the return value of validation steps called with token
        const supported = self.supportedTokens orelse {
            // From validation steps: If no supported tokens defined, throw TypeError
            return DOMError.TypeError;
        };

        // Convert token to lowercase for comparison
        const lowercase_token = try std.ascii.allocLowerString(self.allocator, token);
        defer self.allocator.free(lowercase_token);

        // Check if lowercase token is in supported tokens
        for (supported) |supported_token| {
            if (std.mem.eql(u8, lowercase_token, supported_token)) {
                return true;
            }
        }

        // Step 2: Return result
        return false;
    }
};


// ===== Tests =====

test "DOMTokenList - initialization" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try std.testing.expectEqual(@as(u32, 0), token_list.getLength());
}

test "DOMTokenList - add single token" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{"foo"});

    try std.testing.expectEqual(@as(u32, 1), token_list.getLength());
    try std.testing.expect(token_list.contains("foo"));
}

test "DOMTokenList - add multiple tokens" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{ "foo", "bar", "baz" });

    try std.testing.expectEqual(@as(u32, 3), token_list.getLength());
    try std.testing.expect(token_list.contains("foo"));
    try std.testing.expect(token_list.contains("bar"));
    try std.testing.expect(token_list.contains("baz"));
}

test "DOMTokenList - add duplicate tokens" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{ "foo", "bar" });
    try token_list.add(&[_][]const u8{ "foo", "baz" });

    try std.testing.expectEqual(@as(u32, 3), token_list.getLength());
}

test "DOMTokenList - add empty token throws SyntaxError" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    const result = token_list.add(&[_][]const u8{""});
    try std.testing.expectError(DOMError.SyntaxError, result);
}

test "DOMTokenList - add token with whitespace throws InvalidCharacterError" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    const result = token_list.add(&[_][]const u8{"foo bar"});
    try std.testing.expectError(DOMError.InvalidCharacterError, result);
}

test "DOMTokenList - remove tokens" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{ "foo", "bar", "baz" });
    try token_list.remove(&[_][]const u8{"bar"});

    try std.testing.expectEqual(@as(u32, 2), token_list.getLength());
    try std.testing.expect(token_list.contains("foo"));
    try std.testing.expect(!token_list.contains("bar"));
    try std.testing.expect(token_list.contains("baz"));
}

test "DOMTokenList - remove non-existent token" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{"foo"});
    try token_list.remove(&[_][]const u8{"bar"});

    try std.testing.expectEqual(@as(u32, 1), token_list.getLength());
}

test "DOMTokenList - contains" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{"foo"});

    try std.testing.expect(token_list.contains("foo"));
    try std.testing.expect(!token_list.contains("bar"));
}

test "DOMTokenList - item" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{ "foo", "bar", "baz" });

    const item0 = token_list.item(0);
    try std.testing.expect(item0 != null);
    try std.testing.expectEqualStrings("foo", item0.?);

    const item1 = token_list.item(1);
    try std.testing.expect(item1 != null);
    try std.testing.expectEqualStrings("bar", item1.?);

    const item2 = token_list.item(2);
    try std.testing.expect(item2 != null);
    try std.testing.expectEqualStrings("baz", item2.?);

    const item3 = token_list.item(3);
    try std.testing.expect(item3 == null);
}

test "DOMTokenList - toggle adds when not present" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    const result = try token_list.toggle("foo", null);

    try std.testing.expect(result);
    try std.testing.expect(token_list.contains("foo"));
}

test "DOMTokenList - toggle removes when present" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{"foo"});
    const result = try token_list.toggle("foo", null);

    try std.testing.expect(!result);
    try std.testing.expect(!token_list.contains("foo"));
}

test "DOMTokenList - toggle with force true adds" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    const result = try token_list.toggle("foo", true);

    try std.testing.expect(result);
    try std.testing.expect(token_list.contains("foo"));
}

test "DOMTokenList - toggle with force false removes" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{"foo"});
    const result = try token_list.toggle("foo", false);

    try std.testing.expect(!result);
    try std.testing.expect(!token_list.contains("foo"));
}

test "DOMTokenList - replace token" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{ "foo", "bar", "baz" });
    const result = try token_list.replace("bar", "qux");

    try std.testing.expect(result);
    try std.testing.expectEqual(@as(u32, 3), token_list.getLength());
    try std.testing.expect(token_list.contains("foo"));
    try std.testing.expect(!token_list.contains("bar"));
    try std.testing.expect(token_list.contains("qux"));
    try std.testing.expect(token_list.contains("baz"));
}

test "DOMTokenList - replace non-existent token returns false" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{"foo"});
    const result = try token_list.replace("bar", "qux");

    try std.testing.expect(!result);
    try std.testing.expectEqual(@as(u32, 1), token_list.getLength());
}

test "DOMTokenList - replace with existing token" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{ "foo", "bar", "baz" });
    const result = try token_list.replace("bar", "foo");

    try std.testing.expect(result);
    try std.testing.expectEqual(@as(u32, 2), token_list.getLength());
    try std.testing.expect(token_list.contains("foo"));
    try std.testing.expect(!token_list.contains("bar"));
    try std.testing.expect(token_list.contains("baz"));
}

test "DOMTokenList - supports without supported tokens throws TypeError" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    const result = token_list.supports("foo");
    try std.testing.expectError(DOMError.TypeError, result);
}

test "DOMTokenList - supports with supported tokens" {
    const allocator = std.testing.allocator;

    const supported = [_][]const u8{ "async", "defer" };
    const token_list = try DOMTokenList.init(allocator, null, "script", &supported);
    defer token_list.deinit();

    try std.testing.expect(try token_list.supports("async"));
    try std.testing.expect(try token_list.supports("ASYNC")); // Case-insensitive
    try std.testing.expect(!try token_list.supports("unknown"));
}

test "DOMTokenList - serialize" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    try token_list.add(&[_][]const u8{ "foo", "bar", "baz" });

    const serialized = try token_list.serialize();
    defer allocator.free(serialized);

    try std.testing.expectEqualStrings("foo bar baz", serialized);
}

test "DOMTokenList - serialize empty" {
    const allocator = std.testing.allocator;

    const token_list = try DOMTokenList.init(allocator, null, "class", null);
    defer token_list.deinit();

    const serialized = try token_list.serialize();
    defer allocator.free(serialized);

    try std.testing.expectEqualStrings("", serialized);
}
