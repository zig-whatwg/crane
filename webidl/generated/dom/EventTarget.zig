// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! EventTarget interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-eventtarget

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

const Allocator = std.mem.Allocator;
pub const Event = @import("event").Event;
pub const AbortSignal = @import("abort_signal").AbortSignal;

/// DOM §2.7 - Event listener structure
/// An event listener can be used to observe a specific event and consists of:
pub const EventListener = struct {
    /// type (a string)
    type: []const u8,

    /// callback (null or an EventListener object)
    callback: ?webidl.JSValue,

    /// capture (a boolean, initially false)
    capture: bool = false,

    /// passive (null or a boolean, initially null)
    passive: ?bool = null,

    /// once (a boolean, initially false)
    once: bool = false,

    /// signal (null or an AbortSignal object)
    signal: ?*AbortSignal = null,

    /// removed (a boolean for bookkeeping purposes, initially false)
    removed: bool = false,
};

/// DOM §2.7 - EventListenerOptions dictionary
pub const EventListenerOptions = struct {
    capture: bool = false,
};

/// DOM §2.7 - AddEventListenerOptions dictionary
pub const AddEventListenerOptions = struct {
    capture: bool = false,
    passive: ?bool = null,
    once: bool = false,
    signal: ?*AbortSignal = null,
};
/// Runtime type tag for EventTarget hierarchy.
/// Used for safe downcasting from EventTargetBase to derived types.
pub const EventTargetTypeTag = enum {
    EventTarget,
    Element,
    DocumentType,
    Node,
    Document,
    AbortSignal,
    Attr,
};

/// Base struct for EventTarget hierarchy polymorphism.
/// All EventTarget-derived types have `base: EventTargetBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const EventTargetBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: EventTargetTypeTag,

    allocator: Allocator,
    /// DOM §2.7 - Each EventTarget has an associated event listener list
    /// (a list of zero or more event listeners). It is initially the empty list.
    /// 
    /// OPTIMIZATION: Lazy allocation - most EventTargets never have listeners attached.
    /// This saves ~40% memory on typical DOM trees where 90% of nodes have no listeners.
    /// Pattern borrowed from WebKit's NodeRareData and Chromium's NodeRareData.
    event_listener_list: ?*std.ArrayList(EventListener),

    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for Element.
    /// Use this in Element.init() to properly initialize the base field.
    pub fn initForElement(allocator: Allocator) EventTargetBase {
        return .{
            .type_tag = .Element,
            .event_listener_list = null,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for DocumentType.
    /// Use this in DocumentType.init() to properly initialize the base field.
    pub fn initForDocumentType(allocator: Allocator) EventTargetBase {
        return .{
            .type_tag = .DocumentType,
            .event_listener_list = null,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for Node.
    /// Use this in Node.init() to properly initialize the base field.
    pub fn initForNode(allocator: Allocator) EventTargetBase {
        return .{
            .type_tag = .Node,
            .event_listener_list = null,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for Document.
    /// Use this in Document.init() to properly initialize the base field.
    pub fn initForDocument(allocator: Allocator) EventTargetBase {
        return .{
            .type_tag = .Document,
            .event_listener_list = null,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for AbortSignal.
    /// Use this in AbortSignal.init() to properly initialize the base field.
    pub fn initForAbortSignal(allocator: Allocator) EventTargetBase {
        return .{
            .type_tag = .AbortSignal,
            .event_listener_list = null,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for Attr.
    /// Use this in Attr.init() to properly initialize the base field.
    pub fn initForAttr(allocator: Allocator) EventTargetBase {
        return .{
            .type_tag = .Attr,
            .event_listener_list = null,
            .allocator = allocator,
        };
    }


    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *EventTargetBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    /// 
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *EventTargetBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(EventTargetTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const EventTargetBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(EventTargetTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in EventTarget hierarchy:
    //   - Element
    //   - DocumentType
    //   - Node
    //   - Document
    //   - AbortSignal
    //   - Attr
    //

};

/// EventTarget WebIDL interface
pub const EventTarget = struct {
    // ========================================================================
    // EventTarget fields
    // ========================================================================
    allocator: Allocator,
    /// DOM §2.7 - Each EventTarget has an associated event listener list
    /// (a list of zero or more event listeners). It is initially the empty list.
    /// 
    /// OPTIMIZATION: Lazy allocation - most EventTargets never have listeners attached.
    /// This saves ~40% memory on typical DOM trees where 90% of nodes have no listeners.
    /// Pattern borrowed from WebKit's NodeRareData and Chromium's NodeRareData.
    event_listener_list: ?*std.ArrayList(EventListener),

    pub fn init(allocator: Allocator) !EventTarget {
        return .{
            .allocator = allocator,
            .event_listener_list = null, // Lazy allocation - created on first addEventListener
        };
    }
    pub fn deinit(self: *EventTarget) void {
        if (self.event_listener_list) |list| {
            list.deinit();
            self.allocator.destroy(list);
        }
    }
    // ========================================================================
    // EventTarget methods
    // ========================================================================

    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *EventTarget) !*std.ArrayList(EventListener) {
        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    }
    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const EventTarget) []const EventListener {
        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    }
    /// DOM §2.7 - flatten options
    /// To flatten options, run these steps:
    /// 1. If options is a boolean, then return options.
    /// 2. Return options["capture"].
    fn flattenOptions(options: anytype) bool {
        // TODO: Handle boolean or dictionary
        // For now, return false
        _ = options;
        return false;
    }
    /// DOM §2.7 - flatten more options
    /// Returns: capture, passive, once, signal
    fn flattenMoreOptions(options: anytype) struct { capture: bool, passive: ?bool, once: bool, signal: ?*AbortSignal } {
        // TODO: Handle boolean or AddEventListenerOptions dictionary
        // For now, return defaults
        _ = options;
        return .{
            .capture = false,
            .passive = null,
            .once = false,
            .signal = null,
        };
    }
    /// DOM §2.7 - default passive value
    /// The default passive value, given an event type type and an EventTarget eventTarget
    fn defaultPassiveValue(event_type: []const u8, event_target: *EventTarget) bool {
        _ = event_target;
        // Step 1: Return true if type is touchstart, touchmove, wheel, or mousewheel
        // AND eventTarget is Window or specific node conditions
        // For now, simplified: return true for touch/wheel events
        if (std.mem.eql(u8, event_type, "touchstart") or
            std.mem.eql(u8, event_type, "touchmove") or
            std.mem.eql(u8, event_type, "wheel") or
            std.mem.eql(u8, event_type, "mousewheel"))
        {
            // TODO: Check eventTarget conditions per spec
            return true;
        }
        // Step 2: Return false
        return false;
    }
    /// DOM §2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *EventTarget, listener: EventListener) !void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            _ = signal;
            // TODO: Check if signal is aborted
            // if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture)
            {
                // TODO: Compare callbacks properly
                // For now, assume same callback if type and capture match
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        if (listener.signal) |_| {
            // TODO: Add abort steps to signal to remove listener
        }
    }
    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {
        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    }
    /// DOM §2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *EventTarget, listener: EventListener) void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture)
            {
                // TODO: Compare callbacks properly
                // For now, assume match if type and capture match
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    }
    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {
        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    }
    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *EventTarget, event: *Event) !bool {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this
        // TODO: Implement dispatch algorithm (see whatwg-cbk)
        _ = self;
        @panic("dispatchEvent - dispatch algorithm not yet implemented (see whatwg-cbk)");
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "EventTarget",
        .kind = .interface,
        .exposed = &.{.global},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// ============================================================================
// Tests for lazy event listener list allocation
// ============================================================================

test "EventTarget - event_listener_list starts as null (lazy allocation)" {
    const allocator = std.testing.allocator;

    const target = try allocator.create(EventTarget);
    defer allocator.destroy(target);
    target.* = try EventTarget.init(allocator);
    defer target.deinit();

    // Should start as null (not allocated)
    try std.testing.expect(target.event_listener_list == null);
}

test "EventTarget - addEventListener allocates list on first use" {
    const allocator = std.testing.allocator;

    const target = try allocator.create(EventTarget);
    defer allocator.destroy(target);
    target.* = try EventTarget.init(allocator);
    defer target.deinit();

    // Starts null
    try std.testing.expect(target.event_listener_list == null);

    // Add first listener
    try target.call_addEventListener("click", .{ .js_value = 42 }, .{});

    // Should now be allocated
    try std.testing.expect(target.event_listener_list != null);
    try std.testing.expectEqual(@as(usize, 1), target.event_listener_list.?.items.len);
}

test "EventTarget - removeEventListener on never-used target is safe" {
    const allocator = std.testing.allocator;

    const target = try allocator.create(EventTarget);
    defer allocator.destroy(target);
    target.* = try EventTarget.init(allocator);
    defer target.deinit();

    // Remove from target that never had listeners added
    target.call_removeEventListener("click", null, .{});

    // Should still be null (no allocation needed)
    try std.testing.expect(target.event_listener_list == null);
}

test "EventTarget - memory savings from lazy allocation" {
    const allocator = std.testing.allocator;

    // Create 100 targets, only 10 get listeners
    var targets: [100]*EventTarget = undefined;

    // Initialize all targets
    for (&targets) |*t| {
        t.* = try allocator.create(EventTarget);
        t.*.* = try EventTarget.init(allocator);
    }
    defer {
        for (targets) |t| {
            t.deinit();
            allocator.destroy(t);
        }
    }

    // Only 10% get listeners
    for (targets[0..10]) |t| {
        try t.call_addEventListener("click", .{ .js_value = 1 }, .{});
    }

    // Count how many have allocated lists
    var allocated_count: usize = 0;
    for (targets) |t| {
        if (t.event_listener_list != null) {
            allocated_count += 1;
        }
    }

    // Only 10 should have allocated lists
    try std.testing.expectEqual(@as(usize, 10), allocated_count);

    // 90 targets saved memory by not allocating
    try std.testing.expectEqual(@as(usize, 90), 100 - allocated_count);
}

test "EventTarget - getEventListenerList returns empty for unused target" {
    const allocator = std.testing.allocator;

    const target = try allocator.create(EventTarget);
    defer allocator.destroy(target);
    target.* = try EventTarget.init(allocator);
    defer target.deinit();

    // Should return empty slice, not crash
    const listeners = target.getEventListenerList();
    try std.testing.expectEqual(@as(usize, 0), listeners.len);
}

test "EventTarget - deinit handles both null and allocated list" {
    const allocator = std.testing.allocator;

    // Target with no listeners (null list)
    {
        const target = try allocator.create(EventTarget);
        defer allocator.destroy(target);
        target.* = try EventTarget.init(allocator);
        target.deinit(); // Should not crash
    }

    // Target with listeners (allocated list)
    {
        const target = try allocator.create(EventTarget);
        defer allocator.destroy(target);
        target.* = try EventTarget.init(allocator);
        try target.call_addEventListener("click", .{ .js_value = 1 }, .{});
        target.deinit(); // Should clean up list
    }

    // No leaks should be detected by testing allocator
}
