// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortSignal = @import("abort_signal").AbortSignal;
const Allocator = @import("std.mem").Allocator;
const Event = @import("event").Event;
const EventListener = @import("event_target").EventListener;
const infra = @import("infra").infra;
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง2.7 - Event listener structure
/// An event listener can be used to observe a specific event and consists of:
pub const EventListener = struct {
    /// type (a string)
    type: []const u8,

    /// callback (null or an EventListener object)
    callback: ?webidl.JSValue,

    /// capture (a boolean, initially false)
    capture: bool = false,

    /// passive (null or a boolean, initially null)
    passive: ?bool = null,

    /// once (a boolean, initially false)
    once: bool = false,

    /// signal (null or an AbortSignal object)
    signal: ?*AbortSignal = null,

    /// removed (a boolean for bookkeeping purposes, initially false)
    removed: bool = false,
};

/// DOM ยง2.7 - EventListenerOptions dictionary
pub const EventListenerOptions = struct {
    capture: bool = false,
};

/// DOM ยง2.7 - AddEventListenerOptions dictionary
pub const AddEventListenerOptions = struct {
    capture: bool = false,
    passive: ?bool = null,
    once: bool = false,
    signal: ?*AbortSignal = null,
};

/// Compare two callbacks for equality
/// Used when matching event listeners in addEventListener/removeEventListener
/// In JavaScript, callbacks are compared by reference.
/// For JSValue, we compare the union tags and values.
pub fn callbackEquals(a: ?webidl.JSValue, b: ?webidl.JSValue) bool {
    // If both null, equal
    if (a == null and b == null) return true;
    // If only one is null, not equal
    if (a == null or b == null) return false;

    const a_val = a.?;
    const b_val = b.?;

    // Must have same tag
    if (@as(std.meta.Tag(webidl.JSValue), a_val) != @as(std.meta.Tag(webidl.JSValue), b_val)) {
        return false;
    }

    // Compare based on type
    return switch (a_val) {
        .undefined, .null => true, // Both same type means equal
        .boolean => |a_bool| a_bool == b_val.boolean,
        .number => |a_num| a_num == b_val.number,
        .string => |a_str| std.mem.eql(u8, a_str, b_val.string),
        .object => |a_obj| @intFromPtr(&a_obj) == @intFromPtr(&b_val.object),
        else => false, // Unknown types not equal
    };
}

/// EventTarget WebIDL interface

pub const EventTarget = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    event_listener_list: ?*std.ArrayList(EventListener),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: Allocator) !EventTarget {

        return .{
            .allocator = allocator,
            .event_listener_list = null, // Lazy allocation - created on first addEventListener
        };
    
    }

    pub fn deinit(self: *EventTarget) void {

        if (self.event_listener_list) |list| {
            list.deinit();
            self.allocator.destroy(list);
        }
    
    }

    pub fn call_addEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {

        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    
    }

    pub fn call_removeEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {

        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    
    }

    pub fn call_dispatchEvent(self: *EventTarget, event: *Event) !bool {

        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this using full dispatch algorithm
        const event_dispatch = @import("dom").event_dispatch;
        return event_dispatch.dispatch(event, self, false, null) catch |err| {
            // Handle dispatch errors
            return err;
        };
    
    }

};


