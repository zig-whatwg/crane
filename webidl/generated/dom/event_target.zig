// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! EventTarget class per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-eventtarget
//! Section: 2.7 "Interface EventTarget"
//!
//! EventTarget is the base interface for objects that can receive events
//! and have event listeners registered on them.

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

/// DOM operation errors
///
/// These correspond to WebIDL DOMException names and will be converted
/// to proper DOMException objects when integrated with a JavaScript runtime.
/// See src/dom/errors.zig and webidl/errors.zig for mapping details.
const DOMError = error{
    /// InvalidStateError - Object in invalid state for operation (WebIDL DOMException)
    InvalidStateError,

    /// Internal error for invalid list indices
    InvalidIndex,
};
/// EventTarget WebIDL interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=*]
/// interface EventTarget {
/// constructor();
/// 
/// undefined addEventListener(DOMString type, EventListener? callback, optional (AddEventListenerOptions or boolean) options = {});
/// undefined removeEventListener(DOMString type, EventListener? callback, optional (EventListenerOptions or boolean) options = {});
/// boolean dispatchEvent(Event event);
/// };
/// ```
/// 
/// From spec:
/// - Has an associated event listener list (list of event listeners)
/// - Has an associated "get the parent" algorithm (returns EventTarget or null)
/// - Can have an associated activation behavior algorithm
pub const EventTarget = struct {
    allocator: std.mem.Allocator,
    /// Event listener list (initially empty)
    /// 
    /// From spec: "Each EventTarget object has an associated event listener list
    /// (a list of zero or more event listeners). It is initially the empty list."
    eventListenerList: infra.List(EventListener),

    /// Constructor: new EventTarget()
    /// 
    /// Spec algorithm (§2.7 - "The new EventTarget() constructor steps are to do nothing"):
    /// Creates a new EventTarget object, which can be used by developers to
    /// dispatch and listen for events.
    pub fn init(allocator: std.mem.Allocator) !EventTarget {
        return EventTarget{
            .allocator = allocator,
            .eventListenerList = infra.List(EventListener).init(allocator),
        };
    }
    pub fn deinit(self: *EventTarget) void {
        // Clean up event listener list
        // Note: Each listener owns its own memory that needs cleanup
        for (self.eventListenerList.items()) |*listener| {
            if (listener.typeOwned) |t| {
                self.allocator.free(t);
            }
        }
        self.eventListenerList.deinit();
    }
    /// addEventListener(type, callback [, options])
    /// 
    /// Spec algorithm (§2.7 - "The addEventListener(type, callback, options) method steps are:"):
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    /// 
    /// Note: Using []const u8 for typeStr since event types are ASCII strings in practice.
    pub fn call_addEventListener(
        self: *EventTarget,
        typeStr: []const u8,
        callback: ?*const EventListenerCallback,
        options: AddEventListenerOptions,
    ) !void {
        // Step 1: flatten more options (already done via struct)
        const capture = options.capture;
        const passive = options.passive;
        const once = options.once;
        const signal = options.signal;

        // Step 2: Add an event listener
        try self.addEventListenerInternal(.{
            .typeOwned = try self.allocator.dupe(u8, typeStr),
            .callback = callback,
            .capture = capture,
            .passive = passive,
            .once = once,
            .signal = signal,
            .removed = false,
        });
    }
    /// removeEventListener(type, callback [, options])
    /// 
    /// Spec algorithm (§2.7 - "The removeEventListener(type, callback, options) method steps are:"):
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    /// 
    /// Note: Using []const u8 for typeStr since event types are ASCII strings in practice.
    pub fn call_removeEventListener(
        self: *EventTarget,
        typeStr: []const u8,
        callback: ?*const EventListenerCallback,
        options: EventListenerOptions,
    ) !void {
        // Step 1: flatten options (already done via struct)
        const capture = options.capture;

        // Step 2: Find and remove matching listener
        var i: usize = 0;
        while (i < self.eventListenerList.size()) : (i += 1) {
            const listener = self.eventListenerList.get(i) orelse continue;

            // Check if this listener matches: same type, callback, and capture
            if (listener.typeOwned) |listener_type| {
                const types_match = std.mem.eql(u8, listener_type, typeStr);
                const callbacks_match = listener.callback == callback;
                const captures_match = listener.capture == capture;

                if (types_match and callbacks_match and captures_match) {
                    try self.removeEventListenerInternal(i);
                    return;
                }
            }
        }
    }
    /// dispatchEvent(event)
    /// 
    /// Spec algorithm (§2.7 - "The dispatchEvent(event) method steps are:"):
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(
        self: *EventTarget,
        event: *Event,
    ) !webidl.boolean {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Set isTrusted to false (synthetic event)
        event.is_trusted = false;

        // Step 3: Dispatch event (simplified - full dispatch is complex)
        return try self.dispatchEventInternal(event);
    }
    /// Add an event listener (internal)
    /// 
    /// Spec algorithm (§2.7 - "To add an event listener"):
    /// 1-2. Early returns for ServiceWorkerGlobalScope (skipped - not applicable)
    /// 3. If listener's signal is not null and is aborted, then return.
    /// 4. If listener's callback is null, then return.
    /// 5. If listener's passive is null, then set it to the default passive value.
    /// 6. If eventTarget's event listener list does not contain a listener with
    /// same type, callback, and capture, then append listener.
    /// 7. If listener's signal is not null, add abort steps.
    fn addEventListenerInternal(
        self: *EventTarget,
        listener: EventListener,
    ) !void {
        // Step 3: Check if signal is aborted
        if (listener.signal) |sig| {
            _ = sig; // TODO: Check if aborted when AbortSignal is available
        }

        // Step 4: If callback is null, return
        if (listener.callback == null) {
            if (listener.typeOwned) |t| {
                self.allocator.free(t);
            }
            return;
        }

        // Step 5: Set passive to default if null (simplified - default is null)
        var final_listener = listener;
        if (final_listener.passive == null) {
            final_listener.passive = null; // TODO: Implement default passive value algorithm
        }

        // Step 6: Check for duplicates
        for (self.eventListenerList.items()) |existing| {
            if (existing.typeOwned) |existing_type| {
                if (listener.typeOwned) |listener_type| {
                    const types_match = std.mem.eql(u8, existing_type, listener_type);
                    const callbacks_match = existing.callback == listener.callback;
                    const captures_match = existing.capture == listener.capture;

                    if (types_match and callbacks_match and captures_match) {
                        // Duplicate found, don't add
                        if (listener.typeOwned) |t| {
                            self.allocator.free(t);
                        }
                        return;
                    }
                }
            }
        }

        // No duplicate, append listener
        try self.eventListenerList.append(final_listener);

        // Step 7: Add abort steps (TODO: Implement when AbortSignal is integrated)
    }
    /// Remove an event listener by index (internal)
    /// 
    /// Spec algorithm (§2.7 - "To remove an event listener"):
    /// 1. ServiceWorkerGlobalScope check (skipped - not applicable)
    /// 2. Set listener's removed to true and remove listener from list.
    fn removeEventListenerInternal(
        self: *EventTarget,
        index: usize,
    ) !void {
        const listener = self.eventListenerList.get(index) orelse return error.InvalidIndex;

        // Step 2: Free owned type string
        if (listener.typeOwned) |t| {
            self.allocator.free(t);
        }

        // Remove from list (list.remove returns the removed item)
        _ = try self.eventListenerList.remove(index);
    }
    /// Dispatch event (internal, simplified)
    /// 
    /// Full dispatch algorithm is very complex (see spec §2.9 "Dispatching events").
    /// This is a simplified version for basic event dispatch without tree traversal.
    /// 
    /// Simplified algorithm:
    /// 1. Set event's dispatch flag
    /// 2. Set event's target to this
    /// 3. Set event's eventPhase to AT_TARGET
    /// 4. Invoke listeners
    /// 5. Unset dispatch flag
    /// 6. Return !event.canceled_flag
    fn dispatchEventInternal(
        self: *EventTarget,
        event: *Event,
    ) !webidl.boolean {
        // Step 1: Set dispatch flag
        event.dispatch_flag = true;
        defer event.dispatch_flag = false;

        // Step 2: Set target (store as opaque pointer for now)
        event.target = @ptrCast(self);

        // Step 3: Set eventPhase to AT_TARGET
        event.event_phase = .AT_TARGET;

        // Step 4: Invoke matching listeners
        for (self.eventListenerList.items()) |listener| {
            // Skip if removed
            if (listener.removed) continue;

            // Skip if type doesn't match
            if (listener.typeOwned) |listener_type| {
                if (!std.mem.eql(u8, listener_type, event.event_type)) {
                    continue;
                }
            } else {
                continue;
            }

            // Skip if callback is null
            if (listener.callback == null) continue;

            // Call the callback
            if (listener.callback) |cb| {
                cb.handleEvent(event);
            }

            // If once is true, mark as removed
            if (listener.once) {
                // Note: This doesn't actually remove from list during iteration
                // In real implementation, should handle removal properly
            }

            // Check stop immediate propagation
            if (event.stop_immediate_propagation_flag) {
                break;
            }
        }

        // Step 5: Unset flags
        event.event_phase = .NONE;
        event.target = null;

        // Step 6: Return based on canceled flag
        return !event.canceled_flag;
    }
};


/// Event Listener structure
///
/// Spec (§2.7 - "An event listener"):
/// - type (a string)
/// - callback (null or an EventListener object)
/// - capture (a boolean, initially false)
/// - passive (null or a boolean, initially null)
/// - once (a boolean, initially false)
/// - signal (null or an AbortSignal object)
/// - removed (a boolean for bookkeeping purposes, initially false)
pub const EventListener = struct {
    /// Type (a string) - the event type this listener observes
    typeOwned: ?[]const u8,

    /// Callback (null or an EventListener object)
    callback: ?*const EventListenerCallback,

    /// Capture (a boolean, initially false)
    capture: bool,

    /// Passive (null or a boolean, initially null)
    passive: ?bool,

    /// Once (a boolean, initially false)
    once: bool,

    /// Signal (null or an AbortSignal object)
    /// TODO: Change to ?*AbortSignal when DOM AbortSignal is available
    signal: ?*anyopaque,

    /// Removed (a boolean for bookkeeping purposes, initially false)
    removed: bool,
};

/// EventListener callback interface
///
/// Spec: "callback interface EventListener {
///   undefined handleEvent(Event event);
/// };"
pub const EventListenerCallback = struct {
    handleEvent: *const fn (event: *Event) void,
};

/// EventListenerOptions dictionary
///
/// Spec (§2.7):
/// ```webidl
/// dictionary EventListenerOptions {
///   boolean capture = false;
/// };
/// ```
pub const EventListenerOptions = struct {
    capture: bool = false,
};

/// AddEventListenerOptions dictionary
///
/// Spec (§2.7):
/// ```webidl
/// dictionary AddEventListenerOptions : EventListenerOptions {
///   boolean passive;
///   boolean once = false;
///   AbortSignal signal;
/// };
/// ```
pub const AddEventListenerOptions = struct {
    capture: bool = false,
    passive: ?bool = null,
    once: bool = false,
    signal: ?*anyopaque = null, // TODO: Change to ?*AbortSignal when available
};

/// Event (simplified for EventTarget implementation)
///
/// This is a minimal Event structure needed for EventTarget.
/// Full Event implementation would be in a separate file.
///
/// Spec (§2.6 - "Interface Event")
pub const Event = struct {
    allocator: std.mem.Allocator,

    // Event type (e.g., "click", "load")
    event_type: []const u8,

    // Event flags (§2.6)
    initialized_flag: bool = false,
    dispatch_flag: bool = false,
    stop_propagation_flag: bool = false,
    stop_immediate_propagation_flag: bool = false,
    canceled_flag: bool = false,
    in_passive_listener_flag: bool = false,
    composed_flag: bool = false,

    // Event attributes
    is_trusted: bool = false,
    target: ?*anyopaque = null,
    event_phase: EventPhase = .NONE,
    bubbles: bool = false,
    cancelable: bool = false,

    pub fn init(allocator: std.mem.Allocator, event_type: []const u8) !Event {
        return Event{
            .allocator = allocator,
            .event_type = try allocator.dupe(u8, event_type),
            .initialized_flag = true,
        };
    }

    pub fn deinit(self: *Event) void {
        self.allocator.free(self.event_type);
    }
};

/// EventPhase enum
///
/// Spec (§2.6):
/// - NONE (0): Events not currently dispatched
/// - CAPTURING_PHASE (1): Before reaching target
/// - AT_TARGET (2): At target
/// - BUBBLING_PHASE (3): After target
pub const EventPhase = enum(u16) {
    NONE = 0,
    CAPTURING_PHASE = 1,
    AT_TARGET = 2,
    BUBBLING_PHASE = 3,
};

// ========== Tests ==========

test "EventTarget - constructor creates empty listener list" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);
    defer target.deinit();

    try std.testing.expectEqual(@as(usize, 0), target.eventListenerList.size());
}

test "EventTarget - addEventListener adds listener" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);
    defer target.deinit();

    const TestCallback = struct {
        fn handleEvent(event: *Event) void {
            _ = event;
        }
    };
    const callback = EventListenerCallback{ .handleEvent = TestCallback.handleEvent };

    try target.call_addEventListener("click", &callback, .{});

    try std.testing.expectEqual(@as(usize, 1), target.eventListenerList.size());

    const listener = target.eventListenerList.get(0).?;
    try std.testing.expect(listener.typeOwned != null);
    try std.testing.expectEqualStrings("click", listener.typeOwned.?);
    try std.testing.expectEqual(false, listener.capture);
    try std.testing.expectEqual(false, listener.once);
}

test "EventTarget - addEventListener prevents duplicate listeners" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);
    defer target.deinit();

    const TestCallback = struct {
        fn handleEvent(event: *Event) void {
            _ = event;
        }
    };
    const callback = EventListenerCallback{ .handleEvent = TestCallback.handleEvent };

    // Add same listener twice
    try target.call_addEventListener("click", &callback, .{});
    try target.call_addEventListener("click", &callback, .{});

    // Should only have one listener
    try std.testing.expectEqual(@as(usize, 1), target.eventListenerList.size());
}

test "EventTarget - removeEventListener removes listener" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);
    defer target.deinit();

    const TestCallback = struct {
        fn handleEvent(event: *Event) void {
            _ = event;
        }
    };
    const callback = EventListenerCallback{ .handleEvent = TestCallback.handleEvent };

    try target.call_addEventListener("click", &callback, .{});
    try std.testing.expectEqual(@as(usize, 1), target.eventListenerList.size());

    try target.call_removeEventListener("click", &callback, .{});
    try std.testing.expectEqual(@as(usize, 0), target.eventListenerList.size());
}

test "EventTarget - dispatchEvent with no listeners returns true" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);
    defer target.deinit();

    var event = try Event.init(allocator, "click");
    defer event.deinit();

    const result = try target.call_dispatchEvent(&event);
    try std.testing.expectEqual(true, result);
}

test "EventTarget - dispatchEvent throws on dispatch flag set" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);
    defer target.deinit();

    var event = try Event.init(allocator, "click");
    defer event.deinit();

    event.dispatch_flag = true;

    try std.testing.expectError(error.InvalidStateError, target.call_dispatchEvent(&event));
}

test "EventTarget - dispatchEvent sets isTrusted to false" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);
    defer target.deinit();

    var event = try Event.init(allocator, "click");
    defer event.deinit();

    event.is_trusted = true; // Set to true initially

    _ = try target.call_dispatchEvent(&event);

    try std.testing.expectEqual(false, event.is_trusted);
}

test "EventTarget - memory cleanup on deinit" {
    const allocator = std.testing.allocator;

    var target = try EventTarget.init(allocator);

    const TestCallback = struct {
        fn handleEvent(event: *Event) void {
            _ = event;
        }
    };
    const callback = EventListenerCallback{ .handleEvent = TestCallback.handleEvent };

    try target.call_addEventListener("click", &callback, .{});
    try target.call_addEventListener("load", &callback, .{});
    try target.call_addEventListener("error", &callback, .{});

    // deinit should clean up all listeners
    target.deinit();
}
