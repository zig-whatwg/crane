// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Slottable mixin per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#mixin-slottable

const std = @import("std");
const webidl = @import("webidl");
/// DOM ยง4.3.7 - Slottable mixin
/// 
/// Element and Text nodes are slottables. They can be assigned to slots
/// in shadow trees.
/// 
/// A slottable has:
/// - An associated name (a string, empty string by default)
/// - An associated assigned slot (null or a slot)
/// - An associated manual slot assignment (null or a slot)
pub const Slottable = struct {
    allocator: std.mem.Allocator,

    // ========================================================================
    // Slottable fields
    // ========================================================================
    /// Slottable name (from "slot" attribute)
    slottable_name: []const u8 = "",
    /// Currently assigned slot (null if not assigned)
    /// TODO: Implement when HTMLSlotElement is available
    assigned_slot: ?*anyopaque = null,
    /// Manual slot assignment (for manual slot assignment mode)
    /// TODO: Implement when HTMLSlotElement is available
    /// Should use weak reference per spec
    manual_slot_assignment: ?*anyopaque = null,

    pub fn deinit(self: *Slottable) void {
        self.allocator.free(self.slottable_name);
    }
    // ========================================================================
    // Slottable methods
    // ========================================================================

    /// DOM ยง4.3.7 - Slottable.assignedSlot
    /// 
    /// Returns the slot element this slottable is assigned to, if any.
    /// Returns null if not assigned or if the shadow root is closed.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-slottable-assignedslot
    pub fn get_assignedSlot(self: *const @This()) ?*anyopaque {
        // The assignedSlot getter steps are to return the result of
        // find a slot given this and true (open flag)

        // TODO: Implement findSlot algorithm from shadow_dom_algorithms
        // For now, return the assigned slot if it exists
        // The "open" parameter means we only return slots in open shadow roots

        _ = self;
        return null; // TODO: Implement when slot algorithms are available
    }

    // ========================================================================
    // Internal Methods
    // ========================================================================

    /// Get the slottable name
    pub fn getSlottableName(self: *const @This()) []const u8 {
        return self.slottable_name;
    }
    /// Set the slottable name
    pub fn setSlottableName(self: *@This(), name: []const u8) void {
        self.slottable_name = name;
    }
    /// Check if this slottable is assigned
    pub fn isAssigned(self: *const @This()) bool {
        return self.assigned_slot != null;
    }
    /// Set the assigned slot
    pub fn setAssignedSlot(self: *@This(), slot: ?*anyopaque) void {
        self.assigned_slot = slot;
    }
    /// Set the manual slot assignment
    pub fn setManualSlotAssignment(self: *@This(), slot: ?*anyopaque) void {
        self.manual_slot_assignment = slot;
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Slottable",
        .kind = .mixin,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Tests

test "Slottable - initial state" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};

    try std.testing.expectEqualStrings("", obj.slottable.getSlottableName());
    try std.testing.expectEqual(false, obj.slottable.isAssigned());
    try std.testing.expectEqual(@as(?*anyopaque, null), obj.slottable.getAssignedSlotInternal());
}

test "Slottable - set name" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};

    obj.slottable.setSlottableName("test-slot");
    try std.testing.expectEqualStrings("test-slot", obj.slottable.getSlottableName());
}

test "Slottable - assign to slot" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};
    var mock_slot: u32 = 42;

    obj.slottable.setAssignedSlot(@ptrCast(&mock_slot));
    try std.testing.expect(obj.slottable.isAssigned());
    try std.testing.expect(obj.slottable.getAssignedSlotInternal() != null);
}

test "Slottable - manual slot assignment" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};
    var mock_slot: u32 = 42;

    obj.slottable.setManualSlotAssignment(@ptrCast(&mock_slot));
    try std.testing.expect(obj.slottable.getManualSlotAssignment() != null);
}
