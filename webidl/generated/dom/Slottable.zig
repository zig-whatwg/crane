// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง4.3.7 - Slottable mixin
///
/// Element and Text nodes are slottables. They can be assigned to slots
/// in shadow trees.
///
/// A slottable has:
/// - An associated name (a string, empty string by default)
/// - An associated assigned slot (null or a slot)
/// - An associated manual slot assignment (null or a slot)

pub const Slottable = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    slottable_name: []const u8,
    assigned_slot: ?*anyopaque,
    manual_slot_assignment: ?*anyopaque,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn get_assignedSlot(self: *const Slottable) ?*anyopaque {

        // The assignedSlot getter steps are to return the result of
        // find a slot given this and true (open flag)

        // TODO: Implement findSlot algorithm from shadow_dom_algorithms
        // For now, return the assigned slot if it exists
        // The "open" parameter means we only return slots in open shadow roots

        _ = self;
        return null; // TODO: Implement when slot algorithms are available
    
    }

    pub fn getSlottableName(self: *const Slottable) []const u8 {

        return self.slottable_name;
    
    }

    pub fn setSlottableName(self: *Slottable, name: []const u8) void {

        self.slottable_name = name;
    
    }

    pub fn isAssigned(self: *const Slottable) bool {

        return self.assigned_slot != null;
    
    }

    pub fn getAssignedSlotInternal(self: *const Slottable) ?*anyopaque {

        return self.assigned_slot;
    
    }

    pub fn setAssignedSlot(self: *Slottable, slot: ?*anyopaque) void {

        self.assigned_slot = slot;
    
    }

    pub fn getManualSlotAssignment(self: *const Slottable) ?*anyopaque {

        return self.manual_slot_assignment;
    
    }

    pub fn setManualSlotAssignment(self: *Slottable, slot: ?*anyopaque) void {

        self.manual_slot_assignment = slot;
    
    }

};


// Tests

test "Slottable - initial state" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};

    try std.testing.expectEqualStrings("", obj.slottable.getSlottableName());
    try std.testing.expectEqual(false, obj.slottable.isAssigned());
    try std.testing.expectEqual(@as(?*anyopaque, null), obj.slottable.getAssignedSlotInternal());
}

test "Slottable - set name" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};

    obj.slottable.setSlottableName("test-slot");
    try std.testing.expectEqualStrings("test-slot", obj.slottable.getSlottableName());
}

test "Slottable - assign to slot" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};
    var mock_slot: u32 = 42;

    obj.slottable.setAssignedSlot(@ptrCast(&mock_slot));
    try std.testing.expect(obj.slottable.isAssigned());
    try std.testing.expect(obj.slottable.getAssignedSlotInternal() != null);
}

test "Slottable - manual slot assignment" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};
    var mock_slot: u32 = 42;

    obj.slottable.setManualSlotAssignment(@ptrCast(&mock_slot));
    try std.testing.expect(obj.slottable.getManualSlotAssignment() != null);
}


