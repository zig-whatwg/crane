// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง4.3.7 - Slottable mixin
///
/// Element and Text nodes are slottables. They can be assigned to slots
/// in shadow trees.
///
/// A slottable has:
/// - An associated name (a string, empty string by default)
/// - An associated assigned slot (null or a slot)
/// - An associated manual slot assignment (null or a slot)

/// DOM ยง4.3.7 - Slottable mixin
/// 
/// Element and Text nodes are slottables. They can be assigned to slots
/// in shadow trees.
/// 
/// A slottable has:
/// - An associated name (a string, empty string by default)
/// - An associated assigned slot (null or a slot)
/// - An associated manual slot assignment (null or a slot)
pub const Slottable = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    /// Slottable name (from "slot" attribute)
    slottable_name: []const u8,
    /// Currently assigned slot (null if not assigned)
    /// TODO: Implement when HTMLSlotElement is available
    assigned_slot: ?*anyopaque,
    /// Manual slot assignment (for manual slot assignment mode)
    /// TODO: Implement when HTMLSlotElement is available
    /// Should use weak reference per spec
    manual_slot_assignment: ?*anyopaque,

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "Slottable",
        .kind = .mixin,
    };

    // ========================================================================
    // Methods
    // ========================================================================

    /// DOM ยง4.3.7 - Slottable.assignedSlot
    /// 
    /// Returns the slot element this slottable is assigned to, if any.
    /// Returns null if not assigned or if the shadow root is closed.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-slottable-assignedslot
    pub fn get_assignedSlot(self: *const Slottable) ?*anyopaque {
        const self_parent: *const @This() = @ptrCast(self);

        // The assignedSlot getter steps are to return the result of
        // find a slot given this and true (open flag)

        // TODO: Implement findSlot algorithm from shadow_dom_algorithms
        // For now, return the assigned slot if it exists
        // The "open" parameter means we only return slots in open shadow roots

        _ = self_parent;
        return null; // TODO: Implement when slot algorithms are available
    
    }

    /// Get the slottable name
    pub fn getSlottableName(self: *const Slottable) []const u8 {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.slottable_name;
    
    }

    /// Set the slottable name
    pub fn setSlottableName(self: *Slottable, name: []const u8) void {
        const self_parent: *@This() = @ptrCast(self);

        self_parent.slottable_name = name;
    
    }

    /// Check if this slottable is assigned
    pub fn isAssigned(self: *const Slottable) bool {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.assigned_slot != null;
    
    }

    /// Get the assigned slot
    pub fn getAssignedSlotInternal(self: *const Slottable) ?*anyopaque {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.assigned_slot;
    
    }

    /// Set the assigned slot
    pub fn setAssignedSlot(self: *Slottable, slot: ?*anyopaque) void {
        const self_parent: *@This() = @ptrCast(self);

        self_parent.assigned_slot = slot;
    
    }

    /// Get the manual slot assignment
    pub fn getManualSlotAssignment(self: *const Slottable) ?*anyopaque {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.manual_slot_assignment;
    
    }

    /// Set the manual slot assignment
    pub fn setManualSlotAssignment(self: *Slottable, slot: ?*anyopaque) void {
        const self_parent: *@This() = @ptrCast(self);

        self_parent.manual_slot_assignment = slot;
    
    }

};


// Tests

test "Slottable - initial state" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};

    try std.testing.expectEqualStrings("", obj.slottable.getSlottableName());
    try std.testing.expectEqual(false, obj.slottable.isAssigned());
    try std.testing.expectEqual(@as(?*anyopaque, null), obj.slottable.getAssignedSlotInternal());
}

test "Slottable - set name" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};

    obj.slottable.setSlottableName("test-slot");
    try std.testing.expectEqualStrings("test-slot", obj.slottable.getSlottableName());
}

test "Slottable - assign to slot" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};
    var mock_slot: u32 = 42;

    obj.slottable.setAssignedSlot(@ptrCast(&mock_slot));
    try std.testing.expect(obj.slottable.isAssigned());
    try std.testing.expect(obj.slottable.getAssignedSlotInternal() != null);
}

test "Slottable - manual slot assignment" {
    const TestSlottable = struct {
        slottable: Slottable = .{},
    };

    var obj = TestSlottable{};
    var mock_slot: u32 = 42;

    obj.slottable.setManualSlotAssignment(@ptrCast(&mock_slot));
    try std.testing.expect(obj.slottable.getManualSlotAssignment() != null);
}


