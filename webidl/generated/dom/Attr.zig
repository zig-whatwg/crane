// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Attr interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-attr
//! DOM §4.9

const std = @import("std");
const webidl = @import("webidl");
/// DOM §4.9 - Attr interface
/// Attr nodes represent attributes.
/// Attributes have a namespace, namespace prefix, local name, value, and element.
const NodeBase = @import("node").NodeBase;
const EventListener = @import("event_target").EventListener;
const Event = @import("event").Event;
const flattenOptions = @import("event_target").flattenOptions;
const flattenMoreOptions = @import("event_target").flattenMoreOptions;
const defaultPassiveValue = @import("event_target").defaultPassiveValue;
const callbackEquals = @import("event_target").callbackEquals;
const Node = @import("node").Node;
const Allocator = std.mem.Allocator;
const infra = @import("infra");
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const GetRootNodeOptions = @import("node").GetRootNodeOptions;
const Document = @import("document").Document;
const Element = @import("element").Element;
const ELEMENT_NODE = @import("node").ELEMENT_NODE;
const DOCUMENT_NODE = @import("node").DOCUMENT_NODE;
const DOCUMENT_POSITION_DISCONNECTED = @import("node").DOCUMENT_POSITION_DISCONNECTED;
pub const Attr = struct {
    base: NodeBase,

    // ========================================================================
    // Attr fields
    // ========================================================================
    allocator: std.mem.Allocator,
    /// The attribute's namespace (null or a non-empty string)
    namespace_uri: ?[]const u8,
    /// The attribute's namespace prefix (null or a non-empty string)
    prefix: ?[]const u8,
    /// The attribute's local name (a non-empty string)
    local_name: []const u8,
    /// The attribute's value (a string)
    value: []u8,
    /// The element this attribute belongs to (null or an element)
    owner_element: ?*Element,

    pub fn init(
        allocator: std.mem.Allocator,
        namespace_uri: ?[]const u8,
        prefix: ?[]const u8,
        local_name: []const u8,
        value: []const u8,
    ) !Attr {
        return .{
            .base = NodeBase.initForAttr(allocator),
            .allocator = allocator,
            .namespace_uri = if (namespace_uri) |ns| try allocator.dupe(u8, ns) else null,
            .prefix = if (prefix) |p| try allocator.dupe(u8, p) else null,
            .local_name = try allocator.dupe(u8, local_name),
            .value = try allocator.dupe(u8, value),
            .owner_element = null,
            // NOTE: Parent Node initialization is handled by codegen
        };
    }
    pub fn deinit(self: *Attr) void {
        if (self.namespace_uri) |ns| self.allocator.free(ns);
        if (self.prefix) |p| self.allocator.free(p);
        self.allocator.free(self.local_name);
        self.allocator.free(self.value);
        // NOTE: Parent Node cleanup is handled by codegen
    
        
        // Clean up base fields
        if (self.base.event_listener_list) |list| {
            list.deinit(self.allocator);
            self.allocator.destroy(list);
        }
        self.base.child_nodes.deinit();
        self.base.registered_observers.deinit();
}

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to NodeBase for type-generic code.
    pub fn toBase(self: *Attr) *NodeBase {
        return &self.base;
    }

    // ========================================================================
    // Attr methods
    // ========================================================================

    /// DOM §4.9 - namespaceURI getter
    /// Returns this's namespace.
    pub fn get_namespaceURI(self: *const Attr) ?[]const u8 {
        return self.namespace_uri;
    }
    /// DOM §4.9 - prefix getter
    /// Returns this's namespace prefix.
    pub fn get_prefix(self: *const Attr) ?[]const u8 {
        return self.prefix;
    }
    /// DOM §4.9 - localName getter
    /// Returns this's local name.
    pub fn get_localName(self: *const Attr) []const u8 {
        return self.local_name;
    }
    /// DOM §4.9 - name getter
    /// Returns this's qualified name.
    /// The qualified name is local name if namespace prefix is null,
    /// otherwise it's prefix + ":" + local name.
    pub fn get_name(self: *const Attr) ![]const u8 {
        if (self.prefix) |p| {
            // Qualified name: prefix + ":" + localName
            const qualified = try std.fmt.allocPrint(
                self.allocator,
                "{s}:{s}",
                .{ p, self.local_name },
            );
            return qualified;
        }
        // No prefix, just return local name
        return self.local_name;
    }
    /// DOM §4.9 - value getter
    /// Returns this's value.
    pub fn get_value(self: *const Attr) []const u8 {
        return self.value;
    }
    /// DOM §4.9 - value setter
    /// Sets this's value.
    /// Steps: Set an existing attribute value with this and the given value.
    pub fn set_value(self: *Attr, new_value: []const u8) !void {
        try Attr.setExistingAttributeValue(self, new_value);
    }
    /// Set an existing attribute value - DOM Spec algorithm
    pub fn setExistingAttributeValue(attribute: *Attr, value: []const u8) !void {
        // Step 1: If attribute's element is null, set attribute's value
        if (attribute.owner_element == null) {
            attribute.allocator.free(attribute.value);
            attribute.value = try attribute.allocator.dupe(u8, value);
            return;
        }

        // Step 2: Otherwise, change attribute to value
        try Attr.changeAttribute(attribute, value);
    }
    /// Change an attribute - DOM Spec algorithm
    pub fn changeAttribute(attribute: *Attr, value: []const u8) !void {
        // Step 1: Let oldValue be attribute's value
        const old_value = attribute.value;

        // Step 2: Set attribute's value to value
        attribute.value = try attribute.allocator.dupe(u8, value);

        // Free old value after duplication succeeds
        attribute.allocator.free(old_value);

        // Step 3: Handle attribute changes
        try Attr.handleAttributeChanges(attribute, attribute.owner_element.?, old_value, value);
    }
    /// Handle attribute changes - DOM Spec algorithm
    pub fn handleAttributeChanges(
        attribute: *Attr,
        element: *Element,
        old_value: ?[]const u8,
        new_value: []const u8,
    ) !void {
        // Step 1: Queue a mutation record of "attributes"
        // TODO: Implement mutation record queuing when mutation observer is ready
        // queueMutationRecord("attributes", element, attribute.local_name, attribute.namespace_uri, old_value, ...)
        _ = old_value;
        _ = new_value;

        // Step 2: If element is custom, enqueue custom element callback reaction
        // TODO: Implement custom element callback when custom elements are supported

        // Step 3: Run the attribute change steps
        // TODO: Call extension point for attribute change steps (used by HTML, SVG, etc.)
        _ = element;
        _ = attribute;
    }
    /// DOM §4.9 - ownerElement getter
    /// Returns this's element.
    pub fn get_ownerElement(self: *const Attr) ?*Element {
        return self.owner_element;
    }
    /// DOM §4.9 - specified getter
    /// Always returns true (this is a legacy attribute).
    pub fn get_specified(self: *const Attr) bool {
        _ = self;
        return true;
    }
    /// insertBefore(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-insertbefore
    pub fn call_insertBefore(self: *Attr, node: *Attr, child: ?*Attr) !*Attr {
        // Call mutation.preInsert algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preInsert(node, self, child) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// appendChild(node)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-appendchild
    pub fn call_appendChild(self: *Attr, node: *Attr) !*Attr {
        // Call mutation.append algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.append(node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// replaceChild(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-replacechild
    pub fn call_replaceChild(self: *Attr, node: *Attr, child: *Attr) !*Attr {
        // Call mutation.replace algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.replace(child, node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// removeChild(child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-removechild
    pub fn call_removeChild(self: *Attr, child: *Attr) !*Attr {
        // Call mutation.preRemove algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preRemove(child, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// getRootNode(options)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-getrootnode
    pub fn call_getRootNode(self: *Attr, options: ?GetRootNodeOptions) *Attr {
        // TODO: Support shadow-including root when options.composed is true
        _ = options;
        // For now, return regular root (from tree.zig)
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        return current;
    }
    /// contains(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-contains
    pub fn call_contains(self: *const Attr, other: ?*const Attr) bool {
        if (other == null) return false;
        // Check if other is an inclusive descendant of this
        // TODO: Use tree.isInclusiveDescendant from src/dom/tree.zig
        const other_node = other.?;
        if (self == other_node) return true;

        var current = other_node.parent_node;
        while (current) |parent| {
            if (parent == self) return true;
            current = parent.parent_node;
        }
        return false;
    }
    /// compareDocumentPosition(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    pub fn call_compareDocumentPosition(self: *const Attr, other: *const Attr) u16 {
        const tree = @import("dom").tree;

        // Step 1: If this is other, then return zero
        if (self == other) {
            return 0;
        }

        // Step 2: Let node1 be other and node2 be this
        const node1 = other;
        const node2 = self;

        // Step 3: Let attr1 and attr2 be null
        // Step 4-5: Handle attributes (not implemented yet - attributes don't participate in tree)
        // For now, we skip attribute handling as Attr nodes are handled separately

        // Step 6: If node1 or node2 is null, or node1's root is not node2's root
        // Check if nodes are in the same tree by comparing roots
        const root1 = tree.root(@constCast(node1));
        const root2 = tree.root(@constCast(node2));

        if (root1 != root2) {
            // Return disconnected + implementation specific + preceding/following
            // Use pointer comparison for consistent ordering
            const ptr1 = @intFromPtr(node1);
            const ptr2 = @intFromPtr(node2);
            const ordering = if (ptr1 < ptr2) Attr.DOCUMENT_POSITION_PRECEDING else Attr.DOCUMENT_POSITION_FOLLOWING;
            return Attr.DOCUMENT_POSITION_DISCONNECTED | Attr.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | ordering;
        }

        // Step 7: If node1 is an ancestor of node2
        if (tree.isAncestor(node1, node2)) {
            return Attr.DOCUMENT_POSITION_CONTAINS | Attr.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 8: If node1 is a descendant of node2
        if (tree.isDescendant(node1, node2)) {
            return Attr.DOCUMENT_POSITION_CONTAINED_BY | Attr.DOCUMENT_POSITION_FOLLOWING;
        }

        // Step 9: If node1 is preceding node2
        if (tree.isPreceding(node1, node2)) {
            return Attr.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 10: Return DOCUMENT_POSITION_FOLLOWING
        return Attr.DOCUMENT_POSITION_FOLLOWING;
    }
    /// isEqualNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isequalnode
    pub fn call_isEqualNode(self: *const Attr, other_node: ?*const Attr) bool {
        // Step 1: Return true if otherNode is non-null and this equals otherNode
        if (other_node == null) return false;
        return Attr.nodeEquals(self, other_node.?);
    }
    /// isSameNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-issamenode
    pub fn call_isSameNode(self: *const Attr, other_node: ?*const Attr) bool {
        // Legacy alias of === (pointer equality)
        if (other_node == null) return false;
        return self == other_node.?;
    }
    /// hasChildNodes()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-haschildnodes
    pub fn call_hasChildNodes(self: *const Attr) bool {
        return self.child_nodes.len > 0;
    }
    /// cloneNode(deep)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-clonenode
    pub fn call_cloneNode(self: *Attr, deep: bool) !*Attr {
        // Step 1: If this is a shadow root, throw NotSupportedError
        if (self.node_type == Attr.DOCUMENT_FRAGMENT_NODE) {
            // TODO: Check if this is specifically a ShadowRoot and throw error
            // For now, allow cloning of DocumentFragment
        }

        // Step 2: Return the result of cloning this node with subtree set to deep
        return try Attr.cloneNodeInternal(self, self.owner_document, deep, null, null);
    }
    /// normalize()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-normalize
    pub fn call_normalize(self: *Attr) void {
        _ = self;
        // Normalize adjacent text nodes
    }
    /// Getters
    pub fn get_nodeType(self: *const Attr) u16 {
        return self.node_type;
    }
    pub fn get_nodeName(self: *const Attr) []const u8 {
        return self.node_name;
    }
    pub fn get_parentNode(self: *const Attr) ?*Attr {
        return self.parent_node;
    }
    pub fn get_parentElement(self: *const Attr) ?*Element {
        // Returns parent if it's an Element, null otherwise
        const parent = self.parent_node orelse return null;
        if (parent.node_type == ELEMENT_NODE) {
            // TODO: Proper type casting when Element type is integrated
            return @ptrCast(parent);
        }
        return null;
    }
    pub fn get_childNodes(self: *const Attr) *const infra.List(*Attr) {
        // Returns a NodeList rooted at this matching only children
        // TODO: Return actual NodeList interface when implemented
        return &self.child_nodes;
    }
    pub fn get_firstChild(self: *const Attr) ?*Attr {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(0);
        }
        return null;
    }
    pub fn get_lastChild(self: *const Attr) ?*Attr {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(self.child_nodes.len - 1);
        }
        return null;
    }
    pub fn get_ownerDocument(self: *const Attr) ?*Document {
        return self.owner_document;
    }
    pub fn get_previousSibling(self: *const Attr) ?*Attr {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i == 0) return null;
                return parent.child_nodes.items[i - 1];
            }
        }
        return null;
    }
    pub fn get_nextSibling(self: *const Attr) ?*Attr {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i + 1 >= parent.child_nodes.items.len) return null;
                return parent.child_nodes.items[i + 1];
            }
        }
        return null;
    }
    pub fn get_isConnected(self: *const Attr) bool {
        // A node is connected if its root is a document
        // TODO: Use tree.root from src/dom/tree.zig
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        // Check if root is a document (node_type == DOCUMENT_NODE)
        return current.node_type == DOCUMENT_NODE;
    }
    /// DOM §4.4 - Node.baseURI getter
    /// Returns this's node document's document base URL, serialized.
    /// 
    /// The baseURI getter steps are to return this's node document's
    /// document base URL, serialized.
    pub fn get_baseURI(self: *const Attr) []const u8 {
        // Get owner document
        const doc = self.owner_document orelse {
            // If no owner document, return empty string (should not happen in normal DOM)
            return "about:blank";
        };

        // Return document's base URI
        return doc.base_uri;
    }
    pub fn get_nodeValue(self: *const Attr) ?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // Returns value for Attr and CharacterData, null otherwise
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        return null;
    }
    pub fn set_nodeValue(self: *Attr, value: ?[]const u8) void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // If null, treat as empty string
        // Set value for Attr, replace data for CharacterData
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        _ = value;
    }
    pub fn get_textContent(self: *const Attr) !?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // Return the result of running get text content with this
        return Attr.getTextContent(self, self.allocator);
    }
    pub fn set_textContent(self: *Attr, value: ?[]const u8) !void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // If the given value is null, act as if it was the empty string instead
        const str_value = value orelse "";
        try Attr.setTextContent(self, str_value);
    }
    /// lookupPrefix(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupprefix
    pub fn call_lookupPrefix(self: *const Attr, namespace_param: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return null;
    }
    /// lookupNamespaceURI(prefix)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
    pub fn call_lookupNamespaceURI(self: *const Attr, prefix: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = prefix;
        return null;
    }
    /// isDefaultNamespace(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
    pub fn call_isDefaultNamespace(self: *const Attr, namespace_param: ?[]const u8) bool {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return false;
    }
    /// Get the list of registered observers for this node
    pub fn getRegisteredObservers(self: *Attr) *std.ArrayList(RegisteredObserver) {
        return &self.registered_observers;
    }
    /// Add a registered observer to this node's list
    pub fn addRegisteredObserver(self: *Attr, registered: RegisteredObserver) !void {
        try self.registered_observers.append(registered);
    }
    /// Remove all registered observers for a specific MutationObserver
    pub fn removeRegisteredObserver(self: *Attr, observer: *const @import("mutation_observer").MutationObserver) void {
        var i: usize = 0;
        while (i < self.registered_observers.items.len) {
            if (self.registered_observers.items[i].observer == observer) {
                _ = self.registered_observers.orderedRemove(i);
                // Don't increment i, we just shifted everything down
            } else {
                i += 1;
            }
        }
    }
    /// Remove all transient registered observers whose source matches the given registered observer
    pub fn removeTransientObservers(self: *Attr, source: *const RegisteredObserver) !void {
        // TODO: Implement transient registered observers
        // For now, this is a no-op since we haven't implemented transient observers yet
        _ = self;
        _ = source;
    }
    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *Attr) !*std.ArrayList(EventListener) {
        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    }
    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const Attr) []const EventListener {
        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    }
    /// DOM §2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *Attr, listener: EventListener) !void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        if (listener.signal) |_| {
            // TODO: Add abort steps to signal to remove listener
        }
    }
    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *Attr,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {
        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    }
    /// DOM §2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *Attr, listener: EventListener) void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    }
    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *Attr,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {
        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    }
    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *Attr, event: *Event) !bool {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this
        // TODO: Implement dispatch algorithm (see whatwg-cbk)
        _ = self;
        @panic("dispatchEvent - dispatch algorithm not yet implemented (see whatwg-cbk)");
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Attr",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

