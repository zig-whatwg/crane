// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! AbstractRange interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-abstractrange
//!
//! AbstractRange is a base interface for Range and StaticRange.
//! It provides readonly access to boundary points.

const std = @import("std");
const webidl = @import("webidl");
/// Runtime type tag for AbstractRange hierarchy.
/// Used for safe downcasting from AbstractRangeBase to derived types.
pub const AbstractRangeTypeTag = enum {
    AbstractRange,
    Range,
    StaticRange,
};

/// Base struct for AbstractRange hierarchy polymorphism.
/// All AbstractRange-derived types have `base: AbstractRangeBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const AbstractRangeBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: AbstractRangeTypeTag,

    /// Start boundary point - node
    start_container: *Node,
    /// Start boundary point - offset
    start_offset: u32,
    /// End boundary point - node
    end_container: *Node,
    /// End boundary point - offset
    end_offset: u32,

    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for Range.
    /// Use this in Range.init() to properly initialize the base field.
    pub fn initForRange() AbstractRangeBase {
        return .{
            .type_tag = .Range,
        };
    }

    /// Create a base struct initialized for StaticRange.
    /// Use this in StaticRange.init() to properly initialize the base field.
    pub fn initForStaticRange() AbstractRangeBase {
        return .{
            .type_tag = .StaticRange,
        };
    }

    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *AbstractRangeBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    ///
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *AbstractRangeBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(AbstractRangeTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const AbstractRangeBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(AbstractRangeTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in AbstractRange hierarchy:
    //   - Range
    //   - StaticRange
    //

};

/// DOM §5 - interface AbstractRange
///
/// Objects implementing AbstractRange are known as ranges.
/// A range has two associated boundary points - a start and end.
const Node = @import("node").Node;
pub const AbstractRange = struct {
    // ========================================================================
    // AbstractRange fields
    // ========================================================================
    /// Start boundary point - node
    start_container: *Node,
    /// Start boundary point - offset
    start_offset: u32,
    /// End boundary point - node
    end_container: *Node,
    /// End boundary point - offset
    end_offset: u32,

    pub fn init(allocator: std.mem.Allocator, start_container: *Node, start_offset: u32, end_container: *Node, end_offset: u32) !AbstractRange {
        return try AbstractRange.initFields(allocator, &.{
            .start_container = start_container,
            .start_offset = start_offset,
            .end_container = end_container,
            .end_offset = end_offset,
        });
    }
    fn initFields(_: std.mem.Allocator, fields: *const struct {
        start_container: *Node,
        start_offset: u32,
        end_container: *Node,
        end_offset: u32,
    }) !AbstractRange {
        return .{
            .start_container = fields.start_container,
            .start_offset = fields.start_offset,
            .end_container = fields.end_container,
            .end_offset = fields.end_offset,
        };
    }
    // ========================================================================
    // AbstractRange methods
    // ========================================================================

    /// DOM §5 - AbstractRange.startContainer
    /// Returns the node at the start of the range
    pub fn get_startContainer(self: *const AbstractRange) *Node {
        return self.start_container;
    }
    /// DOM §5 - AbstractRange.startOffset
    /// Returns the offset within the start node
    pub fn get_startOffset(self: *const AbstractRange) u32 {
        return self.start_offset;
    }
    /// DOM §5 - AbstractRange.endContainer
    /// Returns the node at the end of the range
    pub fn get_endContainer(self: *const AbstractRange) *Node {
        return self.end_container;
    }
    /// DOM §5 - AbstractRange.endOffset
    /// Returns the offset within the end node
    pub fn get_endOffset(self: *const AbstractRange) u32 {
        return self.end_offset;
    }
    /// DOM §5 - AbstractRange.collapsed
    /// Returns true if the range's start and end are the same position
    pub fn get_collapsed(self: *const AbstractRange) bool {
        return self.start_container == self.end_container and
            self.start_offset == self.end_offset;
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "AbstractRange",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};
