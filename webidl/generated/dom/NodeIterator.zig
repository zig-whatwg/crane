// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const Attributes = @import("attributes").Attributes;
const BeRemovedNode = @import("be_removed_node").BeRemovedNode;
const BeforeReferenceNode = @import("before_reference_node").BeforeReferenceNode;
const Branch = @import("branch").Branch;
const Call = @import("call").Call;
const DOM = @import("d_o_m").DOM;
const Direction = @import("direction").Direction;
const Do = @import("do").Do;
const FILTER_ACCEPT = @import("f_i_l_t_e_r__a_c_c_e_p_t").FILTER_ACCEPT;
const FILTER_SKIP = @import("f_i_l_t_e_r__s_k_i_p").FILTER_SKIP;
const Find = @import("find").Find;
const For = @import("for").For;
const Given = @import("given").Given;
const If = @import("if").If;
const In = @import("in").In;
const InclusiveAncestor = @import("inclusive_ancestor").InclusiveAncestor;
const Internal = @import("internal").Internal;
const InvalidStateError = @import("invalid_state_error").InvalidStateError;
const LastInclusiveDescendant = @import("last_inclusive_descendant").LastInclusiveDescendant;
const Legacy = @import("legacy").Legacy;
const Let = @import("let").Let;
const Navigation = @import("navigation").Navigation;
const NextNodeInTree = @import("next_node_in_tree").NextNodeInTree;
const NextNodeNotInSubtree = @import("next_node_not_in_subtree").NextNodeNotInSubtree;
const No = @import("no").No;
const Node = @import("node").Node;
const NodeFilter = @import("node_filter").NodeFilter;
const NodeFilter.OptionalAcceptNodeFn = @import("node_filter._optional_accept_node_fn").NodeFilter.OptionalAcceptNodeFn;
const NodeTypeShown = @import("node_type_shown").NodeTypeShown;
const Note = @import("note").Note;
const OptionalAcceptNodeFn = @import("optional_accept_node_fn").OptionalAcceptNodeFn;
const Otherwise = @import("otherwise").Otherwise;
const PreviousNodeInTree = @import("previous_node_in_tree").PreviousNodeInTree;
const Return = @import("return").Return;
const Returns = @import("returns").Returns;
const Set = @import("set").Set;
const Start = @import("start").Start;
const Step = @import("step").Step;
const Steps = @import("steps").Steps;
const ToShow = @import("to_show").ToShow;
const Unset = @import("unset").Unset;
const Use = @import("use").Use;
const WebIDL = @import("web_i_d_l").WebIDL;
const While = @import("while").While;
const std = @import("std");
const webidl = @import("webidl");


/// DOM §6.2 - NodeIterator interface
///
/// NodeIterator objects can be used to filter and traverse node trees.
/// They maintain a reference pointer that moves through the tree as you
/// call nextNode() and previousNode().

pub const NodeIterator = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    root: *Node,
    reference: *Node,
    pointer_before_reference: bool,
    what_to_show: u32,
    filter: NodeFilter.OptionalAcceptNodeFn,
    active_flag: bool,

    // ========================================================================
    // Constants
    // ========================================================================

    pub const Direction = enum { next, previous };

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: Allocator,
        root: *Node,
        what_to_show: u32,
        filter: NodeFilter.OptionalAcceptNodeFn,
    ) !NodeIterator {

        return .{
            .allocator = allocator,
            .root = root,
            .reference = root, // Start at root
            .pointer_before_reference = true, // Start before root
            .what_to_show = what_to_show,
            .filter = filter,
            .active_flag = false,
        };
    
    }

    pub fn deinit(self: *NodeIterator) void {
        _ = self;
        // No cleanup needed - we don't own the nodes
    }

    // ========================================================================
    // Attributes
    // ========================================================================

    /// DOM §6.2 - NodeIterator.root
    /// Returns the root node
    pub fn get_root(self: *const NodeIterator) *Node {
        return self.root;
    }

    /// DOM §6.2 - NodeIterator.referenceNode
    /// Returns the current reference node
    pub fn get_referenceNode(self: *const NodeIterator) *Node {
        return self.reference;
    }

    /// DOM §6.2 - NodeIterator.pointerBeforeReferenceNode
    /// Returns true if pointer is before the reference node
    pub fn get_pointerBeforeReferenceNode(self: *const NodeIterator) bool {
        return self.pointer_before_reference;
    }

    /// DOM §6.2 - NodeIterator.whatToShow
    /// Returns the whatToShow bitmask
    pub fn get_whatToShow(self: *const NodeIterator) u32 {
        return self.what_to_show;
    }

    /// DOM §6.2 - NodeIterator.filter
    /// Returns the filter callback (may be null)
    pub fn get_filter(self: *const NodeIterator) NodeFilter.OptionalAcceptNodeFn {
        return self.filter;
    }

    // ========================================================================
    // Navigation methods
    // ========================================================================

    /// DOM §6.2 - NodeIterator.nextNode()
    /// Returns the next node in the iteration, or null if none
    pub fn nextNode(self: *NodeIterator) !?*Node {
        return try self.traverse(.next);
    }

    /// DOM §6.2 - NodeIterator.previousNode()
    /// Returns the previous node in the iteration, or null if none
    pub fn previousNode(self: *NodeIterator) !?*Node {
        return try self.traverse(.previous);
    }

    /// DOM §6.2 - NodeIterator.detach()
    /// Legacy method - does nothing (functionality removed, kept for compatibility)
    pub fn detach(self: *NodeIterator) void {
        _ = self;
        // Do nothing per spec
    }

    // ========================================================================
    // Internal algorithms
    // ========================================================================

    /// Direction for traverse algorithm
    pub const Direction = enum { next, previous };

    /// DOM §6.2 - traverse algorithm
    /// Given a direction, traverse the tree and return the next accepted node
    fn traverse(self: *NodeIterator, direction: Direction) !?*Node {

        const dom = @import("dom");

        // Step 1: Let node be iterator's reference
        var node = self.reference;

        // Step 2: Let beforeNode be iterator's pointer before reference
        var before_node = self.pointer_before_reference;

        // Step 3: While true
        while (true) {
            // Step 3.1: Branch on direction
            switch (direction) {
                .next => {
                    if (!before_node) {
                        // Find first node following node in iterator collection
                        const next_node = dom.tree_helpers.getNextNodeInTree(node, self.root);
                        if (next_node == null) return null;
                        node = next_node.?;
                    } else {
                        // Set beforeNode to false
                        before_node = false;
                    }
                },
                .previous => {
                    if (before_node) {
                        // Find first node preceding node in iterator collection
                        const prev_node = dom.tree_helpers.getPreviousNodeInTree(node, self.root);
                        if (prev_node == null) return null;
                        node = prev_node.?;
                    } else {
                        // Set beforeNode to true
                        before_node = true;
                    }
                },
            }

            // Step 3.2: Let result be the result of filtering node within iterator
            const result = try self.filterNode(node);

            // Step 3.3: If result is FILTER_ACCEPT, then break
            if (result == NodeFilter.FILTER_ACCEPT) {
                break;
            }
        }

        // Step 4: Set iterator's reference to node
        self.reference = node;

        // Step 5: Set iterator's pointer before reference to beforeNode
        self.pointer_before_reference = before_node;

        // Step 6: Return node
        return node;
    
    }

    fn filterNode(self: *NodeIterator, node: *Node) !u16 {

        // Step 1: If traverser's active flag is set, throw InvalidStateError
        if (self.active_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Let n be node's nodeType attribute value − 1
        const n = node.node_type - 1;

        // Step 3: If the nth bit of whatToShow is not set, return FILTER_SKIP
        if (!NodeFilter.isNodeTypeShown(self.what_to_show, n)) {
            return NodeFilter.FILTER_SKIP;
        }

        // Step 4: If filter is null, return FILTER_ACCEPT
        if (self.filter == null) {
            return NodeFilter.FILTER_ACCEPT;
        }

        // Step 5: Set traverser's active flag
        self.active_flag = true;

        // Step 6: Call filter callback
        // Note: In real implementation, this would be a WebIDL callback invocation
        // For now, we call the function pointer directly
        const result = self.filter.?(node);

        // Step 7: Unset traverser's active flag
        self.active_flag = false;

        // Step 8: Return result
        return result;
    
    }

    pub fn preRemoveSteps(self: *NodeIterator, to_be_removed: *Node) void {

        const dom = @import("dom");

        // Step 1: If toBeRemovedNode is not an inclusive ancestor of reference,
        // or toBeRemovedNode is root, then return
        if (to_be_removed == self.root) return;
        if (!dom.tree_helpers.isInclusiveAncestor(to_be_removed, self.reference)) return;

        // Step 2: If pointer before reference is true
        if (self.pointer_before_reference) {
            // Step 2.1: Let next be toBeRemovedNode's first following node that is
            // an inclusive descendant of root and is not an inclusive descendant of toBeRemovedNode
            const next = dom.tree_helpers.getNextNodeNotInSubtree(to_be_removed, self.root);

            // Step 2.2: If next is non-null, set reference to next and return
            if (next) |next_node| {
                self.reference = next_node;
                return;
            }

            // Step 2.3: Otherwise, set pointer before reference to false
            // (Steps are not terminated here)
            self.pointer_before_reference = false;
        }

        // Step 3: Set reference appropriately
        if (to_be_removed.previous_sibling == null) {
            // If previous sibling is null, use parent
            if (to_be_removed.parent_node) |parent| {
                self.reference = parent;
            }
        } else {
            // Use the inclusive descendant of previous sibling that appears last in tree order
            self.reference = dom.tree_helpers.getLastInclusiveDescendant(to_be_removed.previous_sibling.?);
        }
    
    }

};


