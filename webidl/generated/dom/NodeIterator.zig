// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const Node = @import("node").Node;
const NodeFilter = @import("node_filter").NodeFilter;
const std = @import("std");
const webidl = @import("webidl");


/// DOM §6.2 - NodeIterator interface
///
/// NodeIterator objects can be used to filter and traverse node trees.
/// They maintain a reference pointer that moves through the tree as you
/// call nextNode() and previousNode().

/// DOM §6.2 - NodeIterator interface
/// 
/// NodeIterator objects can be used to filter and traverse node trees.
/// They maintain a reference pointer that moves through the tree as you
/// call nextNode() and previousNode().
pub const NodeIterator = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    /// The root node of the iterator (never changes)
    root: *Node,
    /// The reference node (current position in iteration)
    reference: *Node,
    /// Whether the pointer is before the reference node
    pointer_before_reference: bool,
    /// Bitmask indicating which node types to show
    what_to_show: u32,
    /// Optional filter callback
    filter: NodeFilter.OptionalAcceptNodeFn,
    /// Active flag to prevent recursive invocations
    active_flag: bool,

    // ========================================================================
    // Constants
    // ========================================================================

    pub const Direction = enum { next, previous };

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "NodeIterator",
        .kind = .interface,
        .parent = null,
        .extended_attrs = &.{},
    };

    // ========================================================================
    // Methods
    // ========================================================================

    /// DOM §6.2 - NodeIterator constructor (internal)
    /// Use Document.createNodeIterator() to create instances
    pub fn init(
        allocator: Allocator,
        root: *Node,
        what_to_show: u32,
        filter: NodeFilter.OptionalAcceptNodeFn,
    ) !NodeIterator {

        return .{
            .allocator = allocator,
            .root = root,
            .reference = root, // Start at root
            .pointer_before_reference = true, // Start before root
            .what_to_show = what_to_show,
            .filter = filter,
            .active_flag = false,
        };
    
    }

    pub fn deinit(self: *NodeIterator) void {

        _ = self;
        // No cleanup needed - we don't own the nodes
    
    }

    /// DOM §6.2 - NodeIterator.root
    /// Returns the root node
    pub fn get_root(self: *const NodeIterator) *Node {

        return self.root;
    
    }

    /// DOM §6.2 - NodeIterator.referenceNode
    /// Returns the current reference node
    pub fn get_referenceNode(self: *const NodeIterator) *Node {

        return self.reference;
    
    }

    /// DOM §6.2 - NodeIterator.pointerBeforeReferenceNode
    /// Returns true if pointer is before the reference node
    pub fn get_pointerBeforeReferenceNode(self: *const NodeIterator) bool {

        return self.pointer_before_reference;
    
    }

    /// DOM §6.2 - NodeIterator.whatToShow
    /// Returns the whatToShow bitmask
    pub fn get_whatToShow(self: *const NodeIterator) u32 {

        return self.what_to_show;
    
    }

    /// DOM §6.2 - NodeIterator.filter
    /// Returns the filter callback (may be null)
    pub fn get_filter(self: *const NodeIterator) NodeFilter.OptionalAcceptNodeFn {

        return self.filter;
    
    }

    /// DOM §6.2 - NodeIterator.nextNode()
    /// Returns the next node in the iteration, or null if none
    pub fn call_nextNode(self: *NodeIterator) !?*Node {

        return try self.traverse(.next);
    
    }

    /// DOM §6.2 - NodeIterator.previousNode()
    /// Returns the previous node in the iteration, or null if none
    pub fn call_previousNode(self: *NodeIterator) !?*Node {

        return try self.traverse(.previous);
    
    }

    /// DOM §6.2 - NodeIterator.detach()
    /// Legacy method - does nothing (functionality removed, kept for compatibility)
    pub fn call_detach(self: *NodeIterator) void {

        _ = self;
        // Do nothing per spec
    
    }

    /// DOM §6.2 - traverse algorithm
    /// Given a direction, traverse the tree and return the next accepted node
    fn traverse(self: *NodeIterator, direction: Direction) !?*Node {

        const dom = @import("dom");

        // Step 1: Let node be iterator's reference
        var node = self.reference;

        // Step 2: Let beforeNode be iterator's pointer before reference
        var before_node = self.pointer_before_reference;

        // Step 3: While true
        while (true) {
            // Step 3.1: Branch on direction
            switch (direction) {
                .next => {
                    if (!before_node) {
                        // Find first node following node in iterator collection
                        const next_node = dom.tree_helpers.getNextNodeInTree(node, self.root);
                        if (next_node == null) return null;
                        node = next_node.?;
                    } else {
                        // Set beforeNode to false
                        before_node = false;
                    }
                },
                .previous => {
                    if (before_node) {
                        // Find first node preceding node in iterator collection
                        const prev_node = dom.tree_helpers.getPreviousNodeInTree(node, self.root);
                        if (prev_node == null) return null;
                        node = prev_node.?;
                    } else {
                        // Set beforeNode to true
                        before_node = true;
                    }
                },
            }

            // Step 3.2: Let result be the result of filtering node within iterator
            const result = try self.filterNode(node);

            // Step 3.3: If result is FILTER_ACCEPT, then break
            if (result == NodeFilter.FILTER_ACCEPT) {
                break;
            }
        }

        // Step 4: Set iterator's reference to node
        self.reference = node;

        // Step 5: Set iterator's pointer before reference to beforeNode
        self.pointer_before_reference = before_node;

        // Step 6: Return node
        return node;
    
    }

    /// DOM §6 - filter algorithm
    /// Filter a node within this iterator
    fn filterNode(self: *NodeIterator, node: *Node) !u16 {

        // Step 1: If traverser's active flag is set, throw InvalidStateError
        if (self.active_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Let n be node's nodeType attribute value − 1
        const n = node.node_type - 1;

        // Step 3: If the nth bit of whatToShow is not set, return FILTER_SKIP
        if (!NodeFilter.isNodeTypeShown(self.what_to_show, n)) {
            return NodeFilter.FILTER_SKIP;
        }

        // Step 4: If filter is null, return FILTER_ACCEPT
        if (self.filter == null) {
            return NodeFilter.FILTER_ACCEPT;
        }

        // Step 5: Set traverser's active flag
        self.active_flag = true;

        // Step 6: Call filter callback
        // Note: In real implementation, this would be a WebIDL callback invocation
        // For now, we call the function pointer directly
        const result = self.filter.?(node);

        // Step 7: Unset traverser's active flag
        self.active_flag = false;

        // Step 8: Return result
        return result;
    
    }

    /// DOM §6.2 - NodeIterator pre-remove steps
    /// Called when a node is about to be removed from the tree
    /// Updates iterator state to handle the removal gracefully
    pub fn preRemoveSteps(self: *NodeIterator, to_be_removed: *Node) void {

        const dom = @import("dom");

        // Step 1: If toBeRemovedNode is not an inclusive ancestor of reference,
        // or toBeRemovedNode is root, then return
        if (to_be_removed == self.root) return;
        if (!dom.tree_helpers.isInclusiveAncestor(to_be_removed, self.reference)) return;

        // Step 2: If pointer before reference is true
        if (self.pointer_before_reference) {
            // Step 2.1: Let next be toBeRemovedNode's first following node that is
            // an inclusive descendant of root and is not an inclusive descendant of toBeRemovedNode
            const next = dom.tree_helpers.getNextNodeNotInSubtree(to_be_removed, self.root);

            // Step 2.2: If next is non-null, set reference to next and return
            if (next) |next_node| {
                self.reference = next_node;
                return;
            }

            // Step 2.3: Otherwise, set pointer before reference to false
            // (Steps are not terminated here)
            self.pointer_before_reference = false;
        }

        // Step 3: Set reference appropriately
        if (dom.tree_helpers.getPreviousSibling(to_be_removed)) |prev_sibling| {
            // Use the inclusive descendant of previous sibling that appears last in tree order
            self.reference = dom.tree_helpers.getLastInclusiveDescendant(prev_sibling);
        } else {
            // If previous sibling is null, use parent
            if (to_be_removed.parent_node) |parent| {
                self.reference = parent;
            }
        }
    
    }

};


