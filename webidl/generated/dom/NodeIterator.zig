// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const Node = @import("node").Node;
const NodeFilter = @import("node_filter").NodeFilter;
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง6.2 - NodeIterator interface
///
/// NodeIterator objects can be used to filter and traverse node trees.
/// They maintain a reference pointer that moves through the tree as you
/// call nextNode() and previousNode().

pub const NodeIterator = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    root: *Node,
    reference: *Node,
    pointer_before_reference: bool,
    what_to_show: u32,
    filter: NodeFilter.OptionalAcceptNodeFn,
    active_flag: bool,

    // ========================================================================
    // Constants
    // ========================================================================

    pub const Direction = enum { next, previous };

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: Allocator,
        root: *Node,
        what_to_show: u32,
        filter: NodeFilter.OptionalAcceptNodeFn,
    ) !NodeIterator {

        return .{
            .allocator = allocator,
            .root = root,
            .reference = root, // Start at root
            .pointer_before_reference = true, // Start before root
            .what_to_show = what_to_show,
            .filter = filter,
            .active_flag = false,
        };
    
    }

    pub fn deinit(self: *NodeIterator) void {

        _ = self;
        // No cleanup needed - we don't own the nodes
    
    }

    pub fn get_root(self: *const NodeIterator) *Node {

        return self.root;
    
    }

    pub fn get_referenceNode(self: *const NodeIterator) *Node {

        return self.reference;
    
    }

    pub fn get_pointerBeforeReferenceNode(self: *const NodeIterator) bool {

        return self.pointer_before_reference;
    
    }

    pub fn get_whatToShow(self: *const NodeIterator) u32 {

        return self.what_to_show;
    
    }

    pub fn get_filter(self: *const NodeIterator) NodeFilter.OptionalAcceptNodeFn {

        return self.filter;
    
    }

    pub fn nextNode(self: *NodeIterator) !?*Node {

        return try self.traverse(.next);
    
    }

    pub fn previousNode(self: *NodeIterator) !?*Node {

        return try self.traverse(.previous);
    
    }

    pub fn detach(self: *NodeIterator) void {

        _ = self;
        // Do nothing per spec
    
    }

    pub fn preRemoveSteps(self: *NodeIterator, to_be_removed: *Node) void {

        const dom = @import("dom");

        // Step 1: If toBeRemovedNode is not an inclusive ancestor of reference,
        // or toBeRemovedNode is root, then return
        if (to_be_removed == self.root) return;
        if (!dom.tree_helpers.isInclusiveAncestor(to_be_removed, self.reference)) return;

        // Step 2: If pointer before reference is true
        if (self.pointer_before_reference) {
            // Step 2.1: Let next be toBeRemovedNode's first following node that is
            // an inclusive descendant of root and is not an inclusive descendant of toBeRemovedNode
            const next = dom.tree_helpers.getNextNodeNotInSubtree(to_be_removed, self.root);

            // Step 2.2: If next is non-null, set reference to next and return
            if (next) |next_node| {
                self.reference = next_node;
                return;
            }

            // Step 2.3: Otherwise, set pointer before reference to false
            // (Steps are not terminated here)
            self.pointer_before_reference = false;
        }

        // Step 3: Set reference appropriately
        if (to_be_removed.previous_sibling == null) {
            // If previous sibling is null, use parent
            if (to_be_removed.parent_node) |parent| {
                self.reference = parent;
            }
        } else {
            // Use the inclusive descendant of previous sibling that appears last in tree order
            self.reference = dom.tree_helpers.getLastInclusiveDescendant(to_be_removed.previous_sibling.?);
        }
    
    }

};


