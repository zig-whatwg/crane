// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Comment interface per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-comment
//! Section: 4.10 "Interface Comment"
//!
//! Comment nodes represent comments in the markup.

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

// Forward declarations
const character_data_mod = @import("character_data");
pub const CharacterData = character_data_mod.CharacterData;
/// Comment interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=Window]
/// interface Comment : CharacterData {
/// constructor(optional DOMString data = "");
/// };
/// ```
/// 
/// From spec: "Comment nodes represent comments in the markup."
/// 
/// Comment extends CharacterData, so it inherits all CharacterData methods:
/// - data (attribute)
/// - length (attribute)
/// - substringData(offset, count)
/// - appendData(data)
/// - insertData(offset, data)
/// - deleteData(offset, count)
/// - replaceData(offset, count, data)
pub const Comment = struct {
    allocator: std.mem.Allocator,
    /// The comment's text data (inherited from CharacterData)
    /// 
    /// From spec: Comment extends CharacterData which has associated mutable
    /// string called "data"
    data: []u8,

    /// Create a new Comment
    /// 
    /// Spec: § 4.10 constructor steps
    /// From spec: "The new Comment(data) constructor steps are to set this's
    /// data to data and this's node document to current global object's
    /// associated Document."
    /// 
    /// Note: We don't track node document yet, so we just set data
    pub fn init(allocator: std.mem.Allocator, data: []const u8) !*Comment {
        const self = try allocator.create(Comment);
        errdefer allocator.destroy(self);

        // Allocate mutable copy of data
        const data_copy = try allocator.alloc(u8, data.len);
        errdefer allocator.free(data_copy);
        @memcpy(data_copy, data);

        self.* = .{
            .allocator = allocator,
            .data = data_copy,
        };

        return self;
    }
    /// Free the Comment and its resources
    pub fn deinit(self: *Comment) void {
        self.allocator.free(self.data);
        self.allocator.destroy(self);
    }
    /// Get data
    /// 
    /// Spec: CharacterData § "The data getter steps are to return this's data."
    pub fn getData(self: *const Comment) []const u8 {
        return self.data;
    }
    /// Set data
    /// 
    /// Spec: CharacterData § "Its setter must replace data with node this,
    /// offset 0, count this's length, and data new value."
    pub fn setData(self: *Comment, new_data: []const u8) !void {
        // Free old data
        self.allocator.free(self.data);

        // Allocate new data
        const data_copy = try self.allocator.alloc(u8, new_data.len);
        @memcpy(data_copy, new_data);

        self.data = data_copy;
    }
    /// Get length
    /// 
    /// Spec: CharacterData § "The length getter steps are to return this's length."
    pub fn getLength(self: *const Comment) u32 {
        return @intCast(self.data.len);
    }
    /// Substring data
    /// 
    /// Spec: CharacterData § substringData algorithm
    pub fn substringData(self: *const Comment, offset: u32, count: u32) ![]const u8 {
        const len: u32 = @intCast(self.data.len);

        // Step 2: If offset is greater than length, throw IndexSizeError
        if (offset > len) {
            return error.IndexSizeError;
        }

        // Step 3: If offset + count is greater than length, return from offset to end
        if (offset + count > len) {
            const result = try self.allocator.alloc(u8, len - offset);
            @memcpy(result, self.data[offset..]);
            return result;
        }

        // Step 4: Return substring from offset to offset+count
        const result = try self.allocator.alloc(u8, count);
        @memcpy(result, self.data[offset..][0..count]);
        return result;
    }
    /// Append data
    /// 
    /// Spec: CharacterData § "The appendData(data) method steps are to replace
    /// data with node this, offset this's length, count 0, and data data."
    pub fn appendData(self: *Comment, data: []const u8) !void {
        const new_len = self.data.len + data.len;
        const new_data = try self.allocator.alloc(u8, new_len);

        @memcpy(new_data[0..self.data.len], self.data);
        @memcpy(new_data[self.data.len..], data);

        self.allocator.free(self.data);
        self.data = new_data;
    }
    /// Insert data
    /// 
    /// Spec: CharacterData § "The insertData(offset, data) method steps are to
    /// replace data with node this, offset offset, count 0, and data data."
    pub fn insertData(self: *Comment, offset: u32, data: []const u8) !void {
        const len: u32 = @intCast(self.data.len);

        if (offset > len) {
            return error.IndexSizeError;
        }

        const new_len = self.data.len + data.len;
        const new_data = try self.allocator.alloc(u8, new_len);

        // Copy before insertion point
        @memcpy(new_data[0..offset], self.data[0..offset]);

        // Copy inserted data
        @memcpy(new_data[offset..][0..data.len], data);

        // Copy after insertion point
        @memcpy(new_data[offset + data.len ..], self.data[offset..]);

        self.allocator.free(self.data);
        self.data = new_data;
    }
    /// Delete data
    /// 
    /// Spec: CharacterData § "The deleteData(offset, count) method steps are to
    /// replace data with node this, offset offset, count count, and data the
    /// empty string."
    pub fn deleteData(self: *Comment, offset: u32, count: u32) !void {
        const len: u32 = @intCast(self.data.len);

        if (offset > len) {
            return error.IndexSizeError;
        }

        // Adjust count if it goes past the end
        const actual_count = @min(count, len - offset);

        const new_len = self.data.len - actual_count;
        const new_data = try self.allocator.alloc(u8, new_len);

        // Copy before deletion point
        @memcpy(new_data[0..offset], self.data[0..offset]);

        // Copy after deletion point
        @memcpy(new_data[offset..], self.data[offset + actual_count ..]);

        self.allocator.free(self.data);
        self.data = new_data;
    }
    /// Replace data
    /// 
    /// Spec: CharacterData § "The replaceData(offset, count, data) method steps
    /// are to replace data with node this, offset offset, count count, and data data."
    pub fn replaceData(self: *Comment, offset: u32, count: u32, data: []const u8) !void {
        const len: u32 = @intCast(self.data.len);

        if (offset > len) {
            return error.IndexSizeError;
        }

        // Adjust count if it goes past the end
        const actual_count = @min(count, len - offset);

        const new_len = self.data.len - actual_count + data.len;
        const new_data = try self.allocator.alloc(u8, new_len);

        // Copy before replacement point
        @memcpy(new_data[0..offset], self.data[0..offset]);

        // Copy replacement data
        @memcpy(new_data[offset..][0..data.len], data);

        // Copy after replacement point
        @memcpy(new_data[offset + data.len ..], self.data[offset + actual_count ..]);

        self.allocator.free(self.data);
        self.data = new_data;
    }
};


// ===== Tests =====

test "Comment - initialization with empty data" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "");
    defer comment.deinit();

    try std.testing.expectEqualStrings("", comment.getData());
    try std.testing.expectEqual(@as(u32, 0), comment.getLength());
}

test "Comment - initialization with data" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "This is a comment");
    defer comment.deinit();

    try std.testing.expectEqualStrings("This is a comment", comment.getData());
    try std.testing.expectEqual(@as(u32, 17), comment.getLength());
}

test "Comment - setData updates data" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "original");
    defer comment.deinit();

    try comment.setData("updated");

    try std.testing.expectEqualStrings("updated", comment.getData());
    try std.testing.expectEqual(@as(u32, 7), comment.getLength());
}

test "Comment - substringData returns substring" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "Hello World");
    defer comment.deinit();

    const substring = try comment.substringData(0, 5);
    defer allocator.free(substring);

    try std.testing.expectEqualStrings("Hello", substring);
}

test "Comment - substringData with offset past end throws" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "test");
    defer comment.deinit();

    const result = comment.substringData(10, 5);
    try std.testing.expectError(error.IndexSizeError, result);
}

test "Comment - appendData appends to end" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "Hello");
    defer comment.deinit();

    try comment.appendData(" World");

    try std.testing.expectEqualStrings("Hello World", comment.getData());
}

test "Comment - insertData inserts at position" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "Hello World");
    defer comment.deinit();

    try comment.insertData(6, "Beautiful ");

    try std.testing.expectEqualStrings("Hello Beautiful World", comment.getData());
}

test "Comment - deleteData removes characters" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "Hello Beautiful World");
    defer comment.deinit();

    try comment.deleteData(6, 10); // Remove "Beautiful "

    try std.testing.expectEqualStrings("Hello World", comment.getData());
}

test "Comment - replaceData replaces characters" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "Hello World");
    defer comment.deinit();

    try comment.replaceData(6, 5, "Universe");

    try std.testing.expectEqualStrings("Hello Universe", comment.getData());
}

test "Comment - multiple operations" {
    const allocator = std.testing.allocator;

    const comment = try Comment.init(allocator, "Start");
    defer comment.deinit();

    try comment.appendData(" Middle");
    try comment.appendData(" End");
    try std.testing.expectEqualStrings("Start Middle End", comment.getData());

    try comment.replaceData(6, 6, "Center");
    try std.testing.expectEqualStrings("Start Center End", comment.getData());

    try comment.deleteData(12, 4); // Delete " End"
    try std.testing.expectEqualStrings("Start Center", comment.getData());
}
