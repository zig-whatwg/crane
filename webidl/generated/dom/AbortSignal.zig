// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AND = @import("a_n_d").AND;
const AbortAlgorithm = @import("abort_algorithm").AbortAlgorithm;
const AbortError = @import("abort_error").AbortError;
const AbortSignalType = @import("abort_signal_type").AbortSignalType;
const AbortSteps = @import("abort_steps").AbortSteps;
const Aborted = @import("aborted").Aborted;
const Add = @import("add").Add;
const AddEventListenerOptions = @import("add_event_listener_options").AddEventListenerOptions;
const Algorithm = @import("algorithm").Algorithm;
const Allocator = @import("std.mem").Allocator;
const AnEventListener = @import("an_event_listener").AnEventListener;
const Append = @import("append").Append;
const Check = @import("check").Check;
const Create = @import("create").Create;
const Default = @import("default").Default;
const DependentAbortSignal = @import("dependent_abort_signal").DependentAbortSignal;
const Dispatch = @import("dispatch").Dispatch;
const Early = @import("early").Early;
const Empty = @import("empty").Empty;
const Equals = @import("equals").Equals;
const Event = @import("event").Event;
const EventListener = @import("event_target").EventListener;
const EventListenerList = @import("event_listener_list").EventListenerList;
const EventListenerOptions = @import("event_listener_options").EventListenerOptions;
const EventListenerRemoval = @import("event_listener_removal").EventListenerRemoval;
const EventListenerRemovalContext = @import("event_listener_removal_context").EventListenerRemovalContext;
const EventTarget = @import("event_target").EventTarget;
const Exception = @import("exception").Exception;
const Field = @import("field").Field;
const Fire = @import("fire").Fire;
const First = @import("first").First;
const Flatten = @import("flatten").Flatten;
const For = @import("for").For;
const Handle = @import("handle").Handle;
const If = @import("if").If;
const IfAborted = @import("if_aborted").IfAborted;
const Implement = @import("implement").Implement;
const Initialize = @import("initialize").Initialize;
const Interface = @import("interface").Interface;
const InvalidStateError = @import("invalid_state_error").InvalidStateError;
const JSValue = @import("j_s_value").JSValue;
const Let = @import("let").Let;
const List = @import("list").List;
const Mark = @import("mark").Mark;
const Match = @import("match").Match;
const MoreOptions = @import("more_options").MoreOptions;
const NOTE = @import("n_o_t_e").NOTE;
const Options = @import("options").Options;
const OptionsType = @import("options_type").OptionsType;
const Otherwise = @import("otherwise").Otherwise;
const Parent = @import("parent").Parent;
const PassiveValue = @import("passive_value").PassiveValue;
const Remove = @import("remove").Remove;
const Return = @import("return").Return;
const Run = @import("run").Run;
const ServiceWorkerGlobalScope = @import("service_worker_global_scope").ServiceWorkerGlobalScope;
const Set = @import("set").Set;
const Signal = @import("signal").Signal;
const SignalsToAbort = @import("signals_to_abort").SignalsToAbort;
const Spec = @import("spec").Spec;
const Step = @import("step").Step;
const Steps = @import("steps").Steps;
const TODO = @import("t_o_d_o").TODO;
const Target = @import("target").Target;
const This = @import("this").This;
const Trusted = @import("trusted").Trusted;
const TypeError = @import("type_error").TypeError;
const TypeOf = @import("type_of").TypeOf;
const Window = @import("window").Window;
const infra = @import("infra").infra;
const std = @import("std");
const std.ArrayList(EventListener) = @import("std._array_list(_event_listener)").std.ArrayList(EventListener);
const webidl = @import("webidl");


/// Algorithm function type for abort handlers
/// Takes the abort reason as parameter
pub const AbortAlgorithm = *const fn (reason: webidl.Exception) void;

/// Event listener removal context for abort signal
/// Stores the target and listener to be removed when signal is aborted
pub const EventListenerRemovalContext = struct {
    target: *EventTarget,
    listener_type: []const u8,
    listener_callback: ?webidl.JSValue,
    listener_capture: bool,
}
;
/// DOM Spec: interface AbortSignal : EventTarget

/// Compare two callbacks for equality (from EventTarget)
pub fn callbackEquals(a: ?webidl.JSValue, b: ?webidl.JSValue) bool {
    if (a == null and b == null) return true;
    if (a == null or b == null) return false;
    const a_val = a.?;
    const b_val = b.?;
    if (@as(std.meta.Tag(webidl.JSValue), a_val) != @as(std.meta.Tag(webidl.JSValue), b_val)) {
        return false;
    }
    return switch (a_val) {
        .undefined, .null => true,
        .boolean => |a_bool| a_bool == b_val.boolean,
        .number => |a_num| a_num == b_val.number,
        .string => |a_str| std.mem.eql(u8, a_str, b_val.string),
        .object => |a_obj| @intFromPtr(&a_obj) == @intFromPtr(&b_val.object),
        else => false,
    };
}

pub const AbortSignal = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    event_listener_list: ?*std.ArrayList(EventListener),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !AbortSignal {

        return .{
            .allocator = allocator,
            .aborted = false,
            .reason = null,
            .abort_algorithms = infra.List(AbortAlgorithm).init(allocator),
            .event_listener_removals = infra.List(EventListenerRemovalContext).init(allocator),
            .source_signals = infra.List(*AbortSignal).init(allocator),
            .dependent_signals = infra.List(*AbortSignal).init(allocator),
        };
    
    }

    pub fn deinit(self: *AbortSignal) void {
        self.abort_algorithms.deinit();
        self.event_listener_removals.deinit();
        self.source_signals.deinit();
        self.dependent_signals.deinit();
        // NOTE: Parent EventTarget cleanup is handled by codegen
    }

    pub fn get_aborted(self: *const AbortSignal) bool {
        return self.aborted;
    }

    pub fn get_reason(self: *const AbortSignal) ?webidl.Exception {
        return self.reason;
    }

    pub fn call_throwIfAborted(self: *const AbortSignal) !void {

        if (self.aborted) {
            return error.Aborted;
        }
    
    }

    pub fn call_any(allocator: std.mem.Allocator, signals: []const *AbortSignal) !*AbortSignal {
        // This calls "create a dependent abort signal" algorithm
        return createDependentAbortSignal(allocator, signals);
    }

    /// Create a dependent abort signal
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-create-a-dependent-abort-signal
    ///
    /// Steps:
    /// 1. Let resultSignal be a new object implementing signalInterface using realm
    /// 2. For each signal of signals:
    ///    - If signal is aborted, then set resultSignal's abort reason to signal's abort reason
    ///    - Otherwise:
    ///      - Append signal to resultSignal's source signals
    ///      - Append resultSignal to signal's dependent signals
    /// 3. Return resultSignal
    fn createDependentAbortSignal(allocator: std.mem.Allocator, signals: []const *AbortSignal) !*AbortSignal {

        // Step 1: Let resultSignal be a new object implementing AbortSignal
        const result_signal = try allocator.create(AbortSignal);
        errdefer allocator.destroy(result_signal);
        result_signal.* = try AbortSignal.init(allocator);

        // Step 2: For each signal of signals
        for (signals) |signal| {
            // If signal is aborted, then set resultSignal's abort reason to signal's abort reason
            if (signal.aborted) {
                result_signal.reason = signal.reason;
                result_signal.aborted = true;
            } else {
                // Otherwise:
                // Append signal to resultSignal's source signals
                try result_signal.source_signals.append(signal);
                // Append resultSignal to signal's dependent signals
                try signal.dependent_signals.append(result_signal);
            }
        }

        // Step 3: Return resultSignal
        return result_signal;
    
    }

    pub fn addAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) !void {
        try self.abort_algorithms.append(algorithm);
    }

    /// Remove an algorithm from abort algorithms
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-remove
    pub fn removeAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) void {

        var i: usize = 0;
        while (i < self.abort_algorithms.len) {
            if (self.abort_algorithms.get(i) == algorithm) {
                self.abort_algorithms.remove(i) catch return;
                return;
            }
            i += 1;
        }
    
    }

    pub fn signalAbort(self: *AbortSignal, opt_reason: ?webidl.Exception) void {

        // Spec step 1: If signal is aborted, then return
        if (self.aborted) return;

        // Spec step 2: Set signal's abort reason
        self.reason = opt_reason orelse webidl.Exception{ .simple = .{ .type = .TypeError, .message = "AbortError" } };

        // Mark as aborted
        self.aborted = true;

        // Spec step 3: Let dependentSignalsToAbort be a new list
        var dependent_signals_to_abort = infra.List(*AbortSignal).init(self.allocator);
        defer dependent_signals_to_abort.deinit();

        // Spec step 4: For each dependentSignal of signal's dependent signals
        for (self.dependent_signals.items()) |dependent_signal| {
            // If dependentSignal is not aborted
            if (!dependent_signal.aborted) {
                // Set dependentSignal's abort reason to signal's abort reason
                dependent_signal.reason = self.reason;
                dependent_signal.aborted = true;
                // Append dependentSignal to dependentSignalsToAbort
                dependent_signals_to_abort.append(dependent_signal) catch continue;
            }
        }

        // Spec step 5: Run the abort steps for signal
        self.runAbortSteps();

        // Spec step 6: For each dependentSignal of dependentSignalsToAbort, run the abort steps
        for (dependent_signals_to_abort.items()) |dependent_signal| {
            dependent_signal.runAbortSteps();
        }
    
    }

    pub fn addEventListenerRemoval(self: *AbortSignal, context: EventListenerRemovalContext) !void {
        try self.event_listener_removals.append(context);
    }

    /// Run the abort steps for an AbortSignal
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-run-abort-steps
    fn runAbortSteps(self: *AbortSignal) void {

        // Spec step 1: For each algorithm of signal's abort algorithms: run algorithm
        const reason = self.reason orelse webidl.Exception{ .simple = .{ .type = .TypeError, .message = "AbortError" } };
        for (0..self.abort_algorithms.len) |i| {
            const algorithm = self.abort_algorithms.get(i) orelse continue;
            algorithm(reason);
        }

        // Spec step 2: Empty signal's abort algorithms
        self.abort_algorithms.clear();

        // Remove all event listeners registered with this signal
        // Spec: Step 6 of "add an event listener" - remove listener when signal is aborted
        for (self.event_listener_removals.items()) |removal| {
            const listener = EventListener{
                .type = removal.listener_type,
                .callback = removal.listener_callback,
                .capture = removal.listener_capture,
            };
            removal.target.call_removeEventListener(listener.type, listener.callback, listener.capture);
        }
        self.event_listener_removals.clear();

        // Spec step 3: Fire an event named 'abort' at signal
        // TODO: Implement when event firing infrastructure is available
    
    }

    fn ensureEventListenerList(self: *EventTarget) !*std.ArrayList(EventListener) {

        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    
    }

    fn getEventListenerList(self: *const EventTarget) []const EventListener {

        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    
    }

    fn flattenOptions(options: anytype) bool {

        const OptionsType = @TypeOf(options);

        // Step 1: If options is a boolean, return it
        if (OptionsType == bool) {
            return options;
        }

        // Step 2: If it's EventListenerOptions or AddEventListenerOptions, return capture field
        if (@hasField(OptionsType, "capture")) {
            return options.capture;
        }

        // Default: return false
        return false;
    
    }

    fn flattenMoreOptions(options: anytype) struct { capture: bool, passive: ?bool, once: bool, signal: ?*AbortSignal } {

        const OptionsType = @TypeOf(options);

        // If options is a boolean, only capture is set to that value
        if (OptionsType == bool) {
            return .{
                .capture = options,
                .passive = null,
                .once = false,
                .signal = null,
            };
        }

        // If options is AddEventListenerOptions dictionary, extract all fields
        if (@hasField(OptionsType, "capture")) {
            return .{
                .capture = if (@hasField(OptionsType, "capture")) options.capture else false,
                .passive = if (@hasField(OptionsType, "passive")) options.passive else null,
                .once = if (@hasField(OptionsType, "once")) options.once else false,
                .signal = if (@hasField(OptionsType, "signal")) options.signal else null,
            };
        }

        // Default: return all defaults
        return .{
            .capture = false,
            .passive = null,
            .once = false,
            .signal = null,
        };
    
    }

    fn defaultPassiveValue(event_type: []const u8, event_target: *EventTarget) bool {

        _ = event_target;
        // Step 1: Return true if type is touchstart, touchmove, wheel, or mousewheel
        // AND eventTarget is Window or specific node conditions
        // For now, simplified: return true for touch/wheel events
        if (std.mem.eql(u8, event_type, "touchstart") or
            std.mem.eql(u8, event_type, "touchmove") or
            std.mem.eql(u8, event_type, "wheel") or
            std.mem.eql(u8, event_type, "mousewheel"))
        {
            // TODO: Check eventTarget conditions per spec
            return true;
        }
        // Step 2: Return false
        return false;
    
    }

    fn addAnEventListener(self: *EventTarget, listener: EventListener) !void {

        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        // Spec: "If listener's signal is not null, then add the following abort steps to it:
        // Remove an event listener with eventTarget and listener."
        // https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
        if (listener.signal) |signal| {
            const AbortSignalType = @import("abort_signal").AbortSignal;
            const removal_context = AbortSignalType.EventListenerRemovalContext{
                .target = self,
                .listener_type = updated_listener.type,
                .listener_callback = updated_listener.callback,
                .listener_capture = updated_listener.capture,
            };
            try signal.addEventListenerRemoval(removal_context);
        }
    
    }

    pub fn call_addEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {

        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    
    }

    fn removeAnEventListener(self: *EventTarget, listener: EventListener) void {

        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    
    }

    pub fn call_removeEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {

        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    
    }

    pub fn call_dispatchEvent(self: *EventTarget, event: *Event) !bool {

        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this using full dispatch algorithm
        const event_dispatch = @import("dom").event_dispatch;
        return event_dispatch.dispatch(event, self, false, null) catch |err| {
            // Handle dispatch errors
            return err;
        };
    
    }

};


