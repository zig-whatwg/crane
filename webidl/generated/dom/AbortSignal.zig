// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const Event = @import("event").Event;
const EventListener = @import("event_target").EventListener;
const EventTarget = @import("event_target").EventTarget;
const infra = @import("infra").infra;
const std = @import("std");
const webidl = @import("webidl");

pub const AbortSignal = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    event_listener_list: ?*std.ArrayList(EventListener),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !AbortSignal {

        return .{
            .allocator = allocator,
            .aborted = false,
            .reason = null,
            .abort_algorithms = infra.List(AbortAlgorithm).init(allocator),
            .event_listener_removals = infra.List(EventListenerRemovalContext).init(allocator),
            .source_signals = infra.List(*AbortSignal).init(allocator),
            .dependent_signals = infra.List(*AbortSignal).init(allocator),
        };
    
    }

    pub fn deinit(self: *AbortSignal) void {

        self.abort_algorithms.deinit();
        self.event_listener_removals.deinit();
        self.source_signals.deinit();
        self.dependent_signals.deinit();
        // NOTE: Parent EventTarget cleanup is handled by codegen
    
    }

    pub fn get_aborted(self: *const AbortSignal) bool {

        return self.aborted;
    
    }

    pub fn get_reason(self: *const AbortSignal) ?webidl.Exception {

        return self.reason;
    
    }

    pub fn call_throwIfAborted(self: *const AbortSignal) !void {

        if (self.aborted) {
            return error.Aborted;
        }
    
    }

    pub fn call_any(allocator: std.mem.Allocator, signals: []const *AbortSignal) !*AbortSignal {

        // This calls "create a dependent abort signal" algorithm
        return createDependentAbortSignal(allocator, signals);
    
    }

    pub fn addAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) !void {

        try self.abort_algorithms.append(algorithm);
    
    }

    pub fn removeAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) void {

        var i: usize = 0;
        while (i < self.abort_algorithms.len) {
            if (self.abort_algorithms.get(i) == algorithm) {
                self.abort_algorithms.remove(i) catch return;
                return;
            }
            i += 1;
        }
    
    }

    pub fn signalAbort(self: *AbortSignal, opt_reason: ?webidl.Exception) void {

        // Spec step 1: If signal is aborted, then return
        if (self.aborted) return;

        // Spec step 2: Set signal's abort reason
        self.reason = opt_reason orelse webidl.Exception{ .simple = .{ .type = .TypeError, .message = "AbortError" } };

        // Mark as aborted
        self.aborted = true;

        // Spec step 3: Let dependentSignalsToAbort be a new list
        var dependent_signals_to_abort = infra.List(*AbortSignal).init(self.allocator);
        defer dependent_signals_to_abort.deinit();

        // Spec step 4: For each dependentSignal of signal's dependent signals
        for (self.dependent_signals.items()) |dependent_signal| {
            // If dependentSignal is not aborted
            if (!dependent_signal.aborted) {
                // Set dependentSignal's abort reason to signal's abort reason
                dependent_signal.reason = self.reason;
                dependent_signal.aborted = true;
                // Append dependentSignal to dependentSignalsToAbort
                dependent_signals_to_abort.append(dependent_signal) catch continue;
            }
        }

        // Spec step 5: Run the abort steps for signal
        self.runAbortSteps();

        // Spec step 6: For each dependentSignal of dependentSignalsToAbort, run the abort steps
        for (dependent_signals_to_abort.items()) |dependent_signal| {
            dependent_signal.runAbortSteps();
        }
    
    }

    pub fn addEventListenerRemoval(self: *AbortSignal, context: EventListenerRemovalContext) !void {

        try self.event_listener_removals.append(context);
    
    }

    pub fn call_addEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {

        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    
    }

    pub fn call_removeEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {

        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    
    }

    pub fn call_dispatchEvent(self: *EventTarget, event: *Event) !bool {

        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this using full dispatch algorithm
        const event_dispatch = @import("dom").event_dispatch;
        return event_dispatch.dispatch(event, self, false, null) catch |err| {
            // Handle dispatch errors
            return err;
        };
    
    }

};


