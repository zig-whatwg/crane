// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! AbortSignal interface per WHATWG DOM Standard

const std = @import("std");
const infra = @import("infra");
const webidl = @import("webidl");
pub const EventTarget = @import("event_target").EventTarget;

/// Algorithm function type for abort handlers
/// Takes the abort reason as parameter
pub const AbortAlgorithm = *const fn (reason: webidl.Exception) void;
/// DOM Spec: interface AbortSignal : EventTarget
const EventTargetBase = @import("event_target").EventTargetBase;
const EventListener = @import("event_target").EventListener;
const Event = @import("event").Event;
const flattenOptions = @import("event_target").flattenOptions;
const flattenMoreOptions = @import("event_target").flattenMoreOptions;
const defaultPassiveValue = @import("event_target").defaultPassiveValue;
pub const AbortSignal = struct {
    base: EventTargetBase,

    // ========================================================================
    // AbortSignal fields
    // ========================================================================
    allocator: std.mem.Allocator,
    aborted: bool,
    reason: ?webidl.Exception,
    /// [[abortAlgorithms]]: List of algorithms to run when aborted
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-abort-algorithms
    abort_algorithms: infra.List(AbortAlgorithm),

    pub fn init(allocator: std.mem.Allocator) !AbortSignal {
        return .{
            .base = undefined,
            .allocator = allocator,
            .aborted = false,
            .reason = null,
            .abort_algorithms = infra.List(AbortAlgorithm).init(allocator),
            // TODO: Initialize EventTarget parent fields (will be added by codegen)
        };
    }
    pub fn deinit(self: *AbortSignal) void {
        self.abort_algorithms.deinit();
        // NOTE: Parent EventTarget cleanup will be handled by codegen
        // TODO: Call parent EventTarget deinit (will be added by codegen)
    }

    // ========================================================================
    // AbortSignal methods
    // ========================================================================

    pub fn get_aborted(self: *const AbortSignal) bool {
        return self.aborted;
    }
    pub fn get_reason(self: *const AbortSignal) ?webidl.Exception {
        return self.reason;
    }
    pub fn call_throwIfAborted(self: *const AbortSignal) !void {
        if (self.aborted) {
            return error.Aborted;
        }
    }
    /// Add an algorithm to be run when signal is aborted
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-add
    pub fn addAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) !void {
        try self.abort_algorithms.append(algorithm);
    }
    /// Remove an algorithm from abort algorithms
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-remove
    pub fn removeAlgorithm(self: *AbortSignal, algorithm: AbortAlgorithm) void {
        var i: usize = 0;
        while (i < self.abort_algorithms.len) {
            if (self.abort_algorithms.get(i) == algorithm) {
                self.abort_algorithms.remove(i) catch return;
                return;
            }
            i += 1;
        }
    }
    /// Signal abort algorithm
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-signal-abort
    /// 
    /// Simplified implementation for Streams spec compliance.
    /// TODO: Full DOM compliance requires:
    /// - Dependent signals support
    /// - Event firing with proper event loop integration
    /// - Task queuing for cross-realm scenarios
    pub fn signalAbort(self: *AbortSignal, opt_reason: ?webidl.Exception) void {
        // Spec step 1: If signal is aborted, then return
        if (self.aborted) return;

        // Spec step 2: Set signal's abort reason
        self.reason = opt_reason orelse webidl.Exception{ .simple = .{ .type = .TypeError, .message = "AbortError" } };

        // Mark as aborted
        self.aborted = true;

        // Spec step 5: Run the abort steps for signal
        self.runAbortSteps();

        // TODO: Spec step 3-4, 6: Handle dependent signals (not needed for basic Streams support)
        // TODO: Fire 'abort' event (requires full event loop integration)
    }
    /// Run the abort steps for an AbortSignal
    /// Spec: https://dom.spec.whatwg.org/#abortsignal-run-abort-steps
    fn runAbortSteps(self: *AbortSignal) void {
        // Spec step 1: For each algorithm of signal's abort algorithms: run algorithm
        const reason = self.reason orelse webidl.Exception{ .simple = .{ .type = .TypeError, .message = "AbortError" } };
        for (0..self.abort_algorithms.len) |i| {
            const algorithm = self.abort_algorithms.get(i) orelse continue;
            algorithm(reason);
        }

        // Spec step 2: Empty signal's abort algorithms
        self.abort_algorithms.clear();

        // Spec step 3: Fire an event named 'abort' at signal
        // TODO: Implement when event firing infrastructure is available
    }
    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *AbortSignal) !*std.ArrayList(EventListener) {
        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    }
    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const AbortSignal) []const EventListener {
        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    }
    /// DOM ยง2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *AbortSignal, listener: EventListener) !void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            _ = signal;
            // TODO: Check if signal is aborted
            // if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture)
            {
                // TODO: Compare callbacks properly
                // For now, assume same callback if type and capture match
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        if (listener.signal) |_| {
            // TODO: Add abort steps to signal to remove listener
        }
    }
    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *AbortSignal,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {
        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    }
    /// DOM ยง2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *AbortSignal, listener: EventListener) void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture)
            {
                // TODO: Compare callbacks properly
                // For now, assume match if type and capture match
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    }
    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *AbortSignal,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {
        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    }
    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *AbortSignal, event: *Event) !bool {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this
        // TODO: Implement dispatch algorithm (see whatwg-cbk)
        _ = self;
        @panic("dispatchEvent - dispatch algorithm not yet implemented (see whatwg-cbk)");
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "AbortSignal",
        .kind = .interface,
        .exposed = &.{.global},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

