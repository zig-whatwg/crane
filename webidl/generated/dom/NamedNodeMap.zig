// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const Attr = @import("attr").Attr;
const Element = @import("element").Element;
const infra = @import("infra").infra;
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง4.9 - NamedNodeMap interface
/// A NamedNodeMap is a live collection of attributes.
///
/// A NamedNodeMap has an associated element (an element).
/// A NamedNodeMap object's attribute list is its element's attribute list.

pub const NamedNodeMap = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    element: *Element,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(element: *Element) NamedNodeMap {

        return .{
            .element = element,
        };
    
    }

    pub fn deinit(self: *NamedNodeMap) void {

        _ = self;
        // No cleanup needed - we don't own the element
    
    }

    pub fn get_length(self: *const NamedNodeMap) u32 {

        return @intCast(self.element.attributes.items.len);
    
    }

    pub fn call_item(self: *const NamedNodeMap, index: u32) ?*Attr {

        if (index >= self.element.attributes.items.len) {
            return null;
        }
        return &self.element.attributes.items[index];
    
    }

    pub fn call_getNamedItem(self: *const NamedNodeMap, qualified_name: []const u8) ?*Attr {

        // Get an attribute given qualifiedName and element
        for (self.element.attributes.items) |*attr| {
            if (std.mem.eql(u8, attr.name, qualified_name)) {
                return attr;
            }
        }
        return null;
    
    }

    pub fn call_getNamedItemNS(
        self: *const NamedNodeMap,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) ?*Attr {

        // Get an attribute given namespace, localName, and element
        return getAttributeByNamespaceAndLocalName(namespace, local_name, self.element);
    
    }

    pub fn call_setNamedItem(self: *NamedNodeMap, attr: *Attr) !?*Attr {

        return try NamedNodeMap.setAttribute(attr, self.element);
    
    }

    pub fn call_setNamedItemNS(self: *NamedNodeMap, attr: *Attr) !?*Attr {

        // Same as setNamedItem - the method handles namespaces automatically via attr's properties
        return try NamedNodeMap.setAttribute(attr, self.element);
    
    }

    pub fn call_removeNamedItem(self: *NamedNodeMap, qualified_name: []const u8) !*Attr {

        // Step 1: Remove an attribute by name
        const attr_opt = try NamedNodeMap.removeAttributeByName(qualified_name, self.element);

        // Step 2: If attr is null, throw NotFoundError
        if (attr_opt == null) {
            return error.NotFoundError;
        }

        // Step 3: Return attr
        return attr_opt.?;
    
    }

    pub fn call_removeNamedItemNS(
        self: *NamedNodeMap,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) !*Attr {

        // Step 1: Remove an attribute by namespace and local name
        const attr_opt = try NamedNodeMap.removeAttributeByNamespaceAndLocalName(namespace, local_name, self.element);

        // Step 2: If attr is null, throw NotFoundError
        if (attr_opt == null) {
            return error.NotFoundError;
        }

        // Step 3: Return attr
        return attr_opt.?;
    
    }

    pub fn setAttribute(attr: *Attr, element: *Element) !?*Attr {

        // Step 1: If attr's element is neither null nor element, throw InUseAttributeError
        if (attr.owner_element != null and attr.owner_element != element) {
            return error.InUseAttributeError;
        }

        // Step 2: Let oldAttr be the result of getting an attribute
        const old_attr = NamedNodeMap.getAttributeByNamespaceAndLocalName(
            attr.namespace_uri,
            attr.local_name,
            element,
        );

        // Step 3: If oldAttr is attr, return attr
        if (old_attr != null and old_attr.? == attr) {
            return attr;
        }

        // Step 4: If oldAttr is non-null, replace oldAttr with attr
        if (old_attr) |old| {
            try NamedNodeMap.replaceAttribute(old, attr);
            return old;
        }

        // Step 5: Otherwise, append attr to element
        try NamedNodeMap.appendAttribute(attr, element);

        // Step 6: Return oldAttr (null in this case)
        return null;
    
    }

    pub fn appendAttribute(attribute: *Attr, element: *Element) !void {

        // Step 1: Append attribute to element's attribute list
        try element.attributes.append(attribute.*);

        // Step 2: Set attribute's element to element
        attribute.owner_element = element;

        // Step 3: Set attribute's node document to element's node document
        // Access through Node base class
        if (element.base.owner_document) |doc| {
            attribute.base.owner_document = doc;
        }

        // Step 4: Handle attribute changes
        try Attr.handleAttributeChanges(attribute, element, null, attribute.value);
    
    }

    pub fn removeAttribute(attribute: *Attr) !void {

        // Step 1: Let element be attribute's element
        const element = attribute.owner_element orelse return;

        // Step 2: Remove attribute from element's attribute list
        for (element.attributes.items, 0..) |*attr, i| {
            if (attr == attribute) {
                _ = element.attributes.orderedRemove(i);
                break;
            }
        }

        // Step 3: Set attribute's element to null
        attribute.owner_element = null;

        // Step 4: Handle attribute changes
        try Attr.handleAttributeChanges(attribute, element, attribute.value, "");
    
    }

    pub fn replaceAttribute(old_attribute: *Attr, new_attribute: *Attr) !void {

        // Step 1: Let element be oldAttribute's element
        const element = old_attribute.owner_element orelse return error.InvalidState;

        // Step 2: Replace oldAttribute by newAttribute in element's attribute list
        for (element.attributes.items, 0..) |*attr, i| {
            if (attr == old_attribute) {
                element.attributes.items[i] = new_attribute.*;
                break;
            }
        }

        // Step 3: Set newAttribute's element to element
        new_attribute.owner_element = element;

        // Step 4: Set newAttribute's node document to element's node document
        if (element.base.owner_document) |doc| {
            new_attribute.base.owner_document = doc;
        }

        // Step 5: Set oldAttribute's element to null
        old_attribute.owner_element = null;

        // Step 6: Handle attribute changes
        try Attr.handleAttributeChanges(new_attribute, element, old_attribute.value, new_attribute.value);
    
    }

    fn getAttributeByNamespaceAndLocalName(
        namespace: ?[]const u8,
        local_name: []const u8,
        element: *Element,
    ) ?*Attr {

        for (element.attributes.items) |*attr| {
            // Check namespace match
            const ns_match = if (namespace == null and attr.namespace_uri == null)
                true
            else if (namespace != null and attr.namespace_uri != null)
                std.mem.eql(u8, namespace.?, attr.namespace_uri.?)
            else
                false;

            // Check local name match
            if (ns_match and std.mem.eql(u8, attr.local_name, local_name)) {
                return attr;
            }
        }
        return null;
    
    }

    pub fn removeAttributeByName(qualified_name: []const u8, element: *Element) !?*Attr {

        // Step 1: Let attr be the result of getting an attribute
        // Get an attribute given qualifiedName and element
        for (element.attributes.items, 0..) |*attr, i| {
            // Compare qualified name (prefix:localName or just localName)
            const attr_qualified_name = try attr.get_name();
            defer if (attr.prefix != null) element.allocator.free(attr_qualified_name);

            if (std.mem.eql(u8, attr_qualified_name, qualified_name)) {
                // Step 2: If attr is non-null, remove attr
                const removed = element.attributes.orderedRemove(i);
                removed.owner_element = null;

                // Step 3: Return attr
                return &removed;
            }
        }

        // Step 3: Return null if not found
        return null;
    
    }

    pub fn removeAttributeByNamespaceAndLocalName(
        namespace: ?[]const u8,
        local_name: []const u8,
        element: *Element,
    ) !?*Attr {

        // Step 1: Let attr be the result of getting an attribute
        const attr = getAttributeByNamespaceAndLocalName(namespace, local_name, element);

        // Step 2: If attr is non-null, remove attr
        if (attr) |a| {
            try removeAttribute(a);
        }

        // Step 3: Return attr
        return attr;
    
    }

};


