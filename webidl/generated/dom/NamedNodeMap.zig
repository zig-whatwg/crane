// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! NamedNodeMap interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-namednodemap
//! DOM §4.9

const std = @import("std");
const webidl = @import("webidl");
pub const Attr = @import("attr").Attr;
/// DOM §4.9 - NamedNodeMap interface
/// A NamedNodeMap is a live collection of attributes.
/// 
/// A NamedNodeMap has an associated element (an element).
/// A NamedNodeMap object's attribute list is its element's attribute list.
pub const NamedNodeMap = struct {
    // ========================================================================
    // NamedNodeMap fields
    // ========================================================================
    /// Associated element
    element: *Element,

    pub fn init(element: *Element) NamedNodeMap {
        return .{
            .element = element,
        };
    }
    pub fn deinit(self: *NamedNodeMap) void {
        _ = self;
        // No cleanup needed - we don't own the element
    }
    // ========================================================================
    // NamedNodeMap methods
    // ========================================================================

    /// DOM §4.9 - length getter
    /// Returns the attribute list's size.
    pub fn get_length(self: *const NamedNodeMap) u32 {
        return @intCast(self.element.attributes.items.len);
    }
    /// DOM §4.9 - item(index)
    /// Returns the attribute at the given index, or null if out of bounds.
    /// 
    /// Steps:
    /// 1. If index is equal to or greater than this's attribute list's size, then return null.
    /// 2. Otherwise, return this's attribute list[index].
    pub fn call_item(self: *const NamedNodeMap, index: u32) ?*Attr {
        if (index >= self.element.attributes.items.len) {
            return null;
        }
        return &self.element.attributes.items[index];
    }
    /// DOM §4.9 - getNamedItem(qualifiedName)
    /// Returns the attribute with the given qualified name, or null if not found.
    /// 
    /// Steps: Return the result of getting an attribute given qualifiedName and element.
    pub fn call_getNamedItem(self: *const NamedNodeMap, qualified_name: []const u8) ?*Attr {
        // Get an attribute given qualifiedName and element
        for (self.element.attributes.items) |*attr| {
            if (std.mem.eql(u8, attr.name, qualified_name)) {
                return attr;
            }
        }
        return null;
    }
    /// DOM §4.9 - getNamedItemNS(namespace, localName)
    /// Returns the attribute with the given namespace and local name, or null if not found.
    /// 
    /// Steps: Return the result of getting an attribute given namespace, localName, and element.
    pub fn call_getNamedItemNS(
        self: *const NamedNodeMap,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) !?*Attr {
        _ = self;
        _ = namespace;
        _ = local_name;
        // TODO: Implement namespace-aware attribute handling
        return error.NotImplemented;
    }
    /// DOM §4.9 - setNamedItem(attr)
    /// Sets the given attribute. Returns the old attribute if replaced, or null.
    /// 
    /// Steps: Return the result of setting an attribute given attr and element.
    /// [CEReactions] - Causes DOM mutations
    pub fn call_setNamedItem(self: *NamedNodeMap, attr: *Attr) !?*Attr {
        return try NamedNodeMap.setAttribute(attr, self.element);
    }
    /// DOM §4.9 - setNamedItemNS(attr)
    /// Sets the given attribute with namespace. Returns the old attribute if replaced, or null.
    /// 
    /// Steps: Return the result of setting an attribute given attr and element.
    /// [CEReactions] - Causes DOM mutations
    pub fn call_setNamedItemNS(self: *NamedNodeMap, attr: *Attr) !?*Attr {
        // Same as setNamedItem - the method handles namespaces automatically via attr's properties
        return try NamedNodeMap.setAttribute(attr, self.element);
    }
    /// DOM §4.9 - removeNamedItem(qualifiedName)
    /// Removes the attribute with the given qualified name.
    /// Throws NotFoundError if the attribute doesn't exist.
    /// 
    /// Steps:
    /// 1. Let attr be the result of removing an attribute given qualifiedName and element.
    /// 2. If attr is null, then throw a "NotFoundError" DOMException.
    /// 3. Return attr.
    /// [CEReactions] - Causes DOM mutations
    pub fn call_removeNamedItem(self: *NamedNodeMap, qualified_name: []const u8) !*Attr {
        // Step 1: Remove an attribute by name
        const attr_opt = try NamedNodeMap.removeAttributeByName(qualified_name, self.element);

        // Step 2: If attr is null, throw NotFoundError
        if (attr_opt == null) {
            return error.NotFoundError;
        }

        // Step 3: Return attr
        return attr_opt.?;
    }
    /// DOM §4.9 - removeNamedItemNS(namespace, localName)
    /// Removes the attribute with the given namespace and local name.
    /// Throws NotFoundError if the attribute doesn't exist.
    /// 
    /// Steps:
    /// 1. Let attr be the result of removing an attribute given namespace, localName, and element.
    /// 2. If attr is null, then throw a "NotFoundError" DOMException.
    /// 3. Return attr.
    /// [CEReactions] - Causes DOM mutations
    pub fn call_removeNamedItemNS(
        self: *NamedNodeMap,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) !*Attr {
        // Step 1: Remove an attribute by namespace and local name
        const attr_opt = try NamedNodeMap.removeAttributeByNamespaceAndLocalName(namespace, local_name, self.element);

        // Step 2: If attr is null, throw NotFoundError
        if (attr_opt == null) {
            return error.NotFoundError;
        }

        // Step 3: Return attr
        return attr_opt.?;
    }
    /// Set an attribute - DOM Spec algorithm
    /// Given an attribute attr and an element element
    pub fn setAttribute(attr: *Attr, element: *Element) !?*Attr {
        // Step 1: If attr's element is neither null nor element, throw InUseAttributeError
        if (attr.owner_element != null and attr.owner_element != element) {
            return error.InUseAttributeError;
        }

        // Step 2: Let oldAttr be the result of getting an attribute
        const old_attr = NamedNodeMap.getAttributeByNamespaceAndLocalName(
            attr.namespace_uri,
            attr.local_name,
            element,
        );

        // Step 3: If oldAttr is attr, return attr
        if (old_attr != null and old_attr.? == attr) {
            return attr;
        }

        // Step 4: If oldAttr is non-null, replace oldAttr with attr
        if (old_attr) |old| {
            try NamedNodeMap.replaceAttribute(old, attr);
            return old;
        }

        // Step 5: Otherwise, append attr to element
        try NamedNodeMap.appendAttribute(attr, element);

        // Step 6: Return oldAttr (null in this case)
        return null;
    }
    /// Append an attribute - DOM Spec algorithm
    pub fn appendAttribute(attribute: *Attr, element: *Element) !void {
        // Step 1: Append attribute to element's attribute list
        try element.attributes.append(attribute.*);

        // Step 2: Set attribute's element to element
        attribute.owner_element = element;

        // Step 3: Set attribute's node document to element's node document
        // TODO: Set node document when Attr has Node fields accessible

        // Step 4: Handle attribute changes
        // TODO: Call handleAttributeChanges(attribute, element, null, attribute.value)
    }
    /// Remove an attribute - DOM Spec algorithm
    pub fn removeAttribute(attribute: *Attr) !void {
        // Step 1: Let element be attribute's element
        const element = attribute.owner_element orelse return;

        // Step 2: Remove attribute from element's attribute list
        for (element.attributes.items, 0..) |*attr, i| {
            if (attr == attribute) {
                _ = element.attributes.orderedRemove(i);
                break;
            }
        }

        // Step 3: Set attribute's element to null
        attribute.owner_element = null;

        // Step 4: Handle attribute changes
        // TODO: Call handleAttributeChanges(attribute, element, attribute.value, null)
    }
    /// Replace an attribute - DOM Spec algorithm
    pub fn replaceAttribute(old_attribute: *Attr, new_attribute: *Attr) !void {
        // Step 1: Let element be oldAttribute's element
        const element = old_attribute.owner_element orelse return error.InvalidState;

        // Step 2: Replace oldAttribute by newAttribute in element's attribute list
        for (element.attributes.items, 0..) |*attr, i| {
            if (attr == old_attribute) {
                element.attributes.items[i] = new_attribute.*;
                break;
            }
        }

        // Step 3: Set newAttribute's element to element
        new_attribute.owner_element = element;

        // Step 4: Set newAttribute's node document to element's node document
        // TODO: Set node document when accessible

        // Step 5: Set oldAttribute's element to null
        old_attribute.owner_element = null;

        // TODO: Handle attribute changes
    }
    /// Get an attribute by namespace and local name
    fn getAttributeByNamespaceAndLocalName(
        namespace: ?[]const u8,
        local_name: []const u8,
        element: *Element,
    ) ?*Attr {
        for (element.attributes.items) |*attr| {
            // Check namespace match
            const ns_match = if (namespace == null and attr.namespace_uri == null)
                true
            else if (namespace != null and attr.namespace_uri != null)
                std.mem.eql(u8, namespace.?, attr.namespace_uri.?)
            else
                false;

            // Check local name match
            if (ns_match and std.mem.eql(u8, attr.local_name, local_name)) {
                return attr;
            }
        }
        return null;
    }
    /// Remove an attribute by name - DOM Spec algorithm
    pub fn removeAttributeByName(qualified_name: []const u8, element: *Element) !?*Attr {
        // Step 1: Let attr be the result of getting an attribute
        for (element.attributes.items, 0..) |*attr, i| {
            // For now, compare qualified name to local name (simplified)
            // TODO: Full qualified name handling with namespace prefix
            if (std.mem.eql(u8, attr.local_name, qualified_name)) {
                // Step 2: If attr is non-null, remove attr
                const removed = element.attributes.orderedRemove(i);
                removed.owner_element = null;

                // Step 3: Return attr
                return &removed;
            }
        }

        // Step 3: Return null if not found
        return null;
    }
    /// Remove an attribute by namespace and local name - DOM Spec algorithm
    pub fn removeAttributeByNamespaceAndLocalName(
        namespace: ?[]const u8,
        local_name: []const u8,
        element: *Element,
    ) !?*Attr {
        // Step 1: Let attr be the result of getting an attribute
        const attr = getAttributeByNamespaceAndLocalName(namespace, local_name, element);

        // Step 2: If attr is non-null, remove attr
        if (attr) |a| {
            try removeAttribute(a);
        }

        // Step 3: Return attr
        return attr;
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "NamedNodeMap",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

