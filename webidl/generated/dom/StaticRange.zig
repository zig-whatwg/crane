// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! StaticRange interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-staticrange
//!
//! A StaticRange is a range that does not update when the node tree mutates.

const std = @import("std");
const webidl = @import("webidl");
pub const AbstractRange = @import("abstract_range").AbstractRange;

/// StaticRangeInit dictionary
pub const StaticRangeInit = struct {
    startContainer: *Node,
    startOffset: u32,
    endContainer: *Node,
    endOffset: u32,
};
/// DOM §5 - interface StaticRange : AbstractRange
/// 
/// A StaticRange is a range object that does not update when the node tree mutates.
/// This makes it more efficient for one-time range operations.
const AbstractRangeBase = @import("abstract_range").AbstractRangeBase;
const Node = @import("node").Node;
pub const StaticRange = struct {
    base: AbstractRangeBase,

    /// DOM §5 - new StaticRange(init) constructor
    /// 
    /// Steps:
    /// 1. If init["startContainer"] or init["endContainer"] is a DocumentType or Attr node,
    /// then throw an "InvalidNodeTypeError" DOMException.
    /// 2. Set this's start to (init["startContainer"], init["startOffset"])
    /// and end to (init["endContainer"], init["endOffset"]).
    pub fn init_(init_: StaticRangeInit) !StaticRange {
        const NodeType = @import("node").Node;

        // Step 1: Check for invalid node types
        if (init_.startContainer.node_type == NodeType.DOCUMENT_TYPE_NODE or
            init_.startContainer.node_type == NodeType.ATTRIBUTE_NODE)
        {
            return error.InvalidNodeTypeError;
        }

        if (init_.endContainer.node_type == NodeType.DOCUMENT_TYPE_NODE or
            init_.endContainer.node_type == NodeType.ATTRIBUTE_NODE)
        {
            return error.InvalidNodeTypeError;
        }

        // Step 2: Set start and end boundary points
        return .{
            .base = AbstractRangeBase.initForStaticRange(allocator),
            .start_container = init_.startContainer,
            .start_offset = init_.startOffset,
            .end_container = init_.endContainer,
            .end_offset = init_.endOffset,
        };
    }
    pub fn deinit(self: *StaticRange) void {
        _ = self;
        // No cleanup needed - we don't own the nodes
    }

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to AbstractRangeBase for type-generic code.
    pub fn toBase(self: *StaticRange) *AbstractRangeBase {
        return &self.base;
    }

    // ========================================================================
    // StaticRange methods
    // ========================================================================

    /// Check if this StaticRange is valid per the DOM spec
    /// 
    /// A StaticRange is valid if all of the following are true:
    /// - Its start and end are in the same node tree.
    /// - Its start offset is between 0 and its start node's length, inclusive.
    /// - Its end offset is between 0 and its end node's length, inclusive.
    /// - Its start is before or equal to its end.
    pub fn isValid(self: *const StaticRange) bool {
        const dom = @import("dom");

        // Check if start and end are in the same node tree
        const start_root = dom.tree.getRoot(self.start_container);
        const end_root = dom.tree.getRoot(self.end_container);
        if (start_root != end_root) return false;

        // Check start offset bounds
        const start_length = dom.tree.getNodeLength(self.start_container);
        if (self.start_offset > start_length) return false;

        // Check end offset bounds
        const end_length = dom.tree.getNodeLength(self.end_container);
        if (self.end_offset > end_length) return false;

        // Check that start is before or equal to end
        const position = dom.tree.getRelativePosition(
            self.start_container,
            self.start_offset,
            self.end_container,
            self.end_offset,
        );
        if (position == .after) return false;

        return true;
    }
    /// DOM §5 - AbstractRange.startContainer
    /// Returns the node at the start of the range
    pub fn get_startContainer(self: *const StaticRange) *Node {
        return self.start_container;
    }
    /// DOM §5 - AbstractRange.startOffset
    /// Returns the offset within the start node
    pub fn get_startOffset(self: *const StaticRange) u32 {
        return self.start_offset;
    }
    /// DOM §5 - AbstractRange.endContainer
    /// Returns the node at the end of the range
    pub fn get_endContainer(self: *const StaticRange) *Node {
        return self.end_container;
    }
    /// DOM §5 - AbstractRange.endOffset
    /// Returns the offset within the end node
    pub fn get_endOffset(self: *const StaticRange) u32 {
        return self.end_offset;
    }
    /// DOM §5 - AbstractRange.collapsed
    /// Returns true if the range's start and end are the same position
    pub fn get_collapsed(self: *const StaticRange) bool {
        return self.start_container == self.end_container and
            self.start_offset == self.end_offset;
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "StaticRange",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

