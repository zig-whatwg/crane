// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbstractRange = @import("abstract_range").AbstractRange;
const Allocator = std.mem.Allocator;
pub const Container = @import("container").Container;
const Node = @import("node").Node;
const std = @import("std");
const webidl = @import("webidl");


/// StaticRangeInit dictionary
pub const StaticRangeInit = struct {
    startContainer: *Node,
    startOffset: u32,
    endContainer: *Node,
    endOffset: u32,
};

/// DOM ยง5 - interface StaticRange : AbstractRange
///
/// A StaticRange is a range object that does not update when the node tree mutates.
/// This makes it more efficient for one-time range operations.

pub const StaticRange = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    start_container: *Node,
    start_offset: u32,
    end_container: *Node,
    end_offset: u32,

    // ========================================================================
    // Constants
    // ========================================================================

    // Node type constants (inherited)
    pub const ELEMENT_NODE: u16 = Node.ELEMENT_NODE;
    pub const ATTRIBUTE_NODE: u16 = Node.ATTRIBUTE_NODE;
    pub const TEXT_NODE: u16 = Node.TEXT_NODE;
    pub const CDATA_SECTION_NODE: u16 = Node.CDATA_SECTION_NODE;
    pub const PROCESSING_INSTRUCTION_NODE: u16 = Node.PROCESSING_INSTRUCTION_NODE;
    pub const COMMENT_NODE: u16 = Node.COMMENT_NODE;
    pub const DOCUMENT_NODE: u16 = Node.DOCUMENT_NODE;
    pub const DOCUMENT_TYPE_NODE: u16 = Node.DOCUMENT_TYPE_NODE;
    pub const DOCUMENT_FRAGMENT_NODE: u16 = Node.DOCUMENT_FRAGMENT_NODE;

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(options: StaticRangeInit) !StaticRange {

        const NodeType = @import("node").Node;

        // Step 1: Check for invalid node types
        if (options.startContainer.node_type == NodeType.DOCUMENT_TYPE_NODE or
            options.startContainer.node_type == NodeType.ATTRIBUTE_NODE)
        {
            return error.InvalidNodeTypeError;
        }

        if (options.endContainer.node_type == NodeType.DOCUMENT_TYPE_NODE or
            options.endContainer.node_type == NodeType.ATTRIBUTE_NODE)
        {
            return error.InvalidNodeTypeError;
        }

        // Step 2: Set start and end boundary points
        return .{
            .start_container = options.startContainer,
            .start_offset = options.startOffset,
            .end_container = options.endContainer,
            .end_offset = options.endOffset,
        };
    
    }

    pub fn deinit(self: *StaticRange) void {

        _ = self;
        // No cleanup needed - we don't own the nodes
    
    }

    pub fn isValid(self: *const StaticRange) bool {

        const dom = @import("dom");

        // Check if start and end are in the same node tree
        const start_root = dom.tree.getRoot(self.start_container);
        const end_root = dom.tree.getRoot(self.end_container);
        if (start_root != end_root) return false;

        // Check start offset bounds
        const start_length = dom.tree.getNodeLength(self.start_container);
        if (self.start_offset > start_length) return false;

        // Check end offset bounds
        const end_length = dom.tree.getNodeLength(self.end_container);
        if (self.end_offset > end_length) return false;

        // Check that start is before or equal to end
        const position = dom.tree.getRelativePosition(
            self.start_container,
            self.start_offset,
            self.end_container,
            self.end_offset,
        );
        if (position == .after) return false;

        return true;
    
    }

};


