// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const dom_types = @import("dom_types").dom_types;
const std = @import("std");
const webidl = @import("webidl");


/// ChildNode mixin provides methods for manipulating nodes relative to their siblings.
/// Included by: DocumentType, Element, CharacterData
///
/// WebIDL Definition:
/// ```
/// interface mixin ChildNode {
///   [CEReactions, Unscopable] undefined before((Node or DOMString)... nodes);
///   [CEReactions, Unscopable] undefined after((Node or DOMString)... nodes);
///   [CEReactions, Unscopable] undefined replaceWith((Node or DOMString)... nodes);
///   [CEReactions, Unscopable] undefined remove();
/// };
/// ```

pub const ChildNode = struct {

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn call_before(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null
        var viable_previous_sibling: ?*NodeType = null;

        // Walk backwards through siblings to find first one not in nodes
        var current = this_node.get_previousSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_previous_sibling = sibling;
                break;
            }

            current = sibling.get_previousSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNode.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If viablePreviousSibling is null, set it to parent's first child;
        // otherwise to viablePreviousSibling's next sibling
        const reference_child = if (viable_previous_sibling) |vps|
            vps.get_nextSibling()
        else
            parent.?.get_firstChild();

        // Step 6: Pre-insert node into parent before viablePreviousSibling
        _ = try mutation.preInsert(node, parent.?, reference_child);
    
    }

    pub fn call_after(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNode.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: Pre-insert node into parent before viableNextSibling
        _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
    
    }

    pub fn call_replaceWith(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNode.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If this's parent is parent, replace this with node within parent
        // Note: The parent could have changed during convertNodesIntoNode if one of the nodes
        // contained 'this' in its subtree
        if (this_node.parent_node == parent) {
            try mutation.replace(this_node, node, parent.?);
        } else {
            // Step 6: Otherwise, pre-insert node into parent before viableNextSibling
            _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
        }
    
    }

    pub fn call_remove(self: anytype) !void {

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const node = @as(*NodeType, @ptrCast(self));

        // Step 1: If this's parent is null, then return
        if (node.parent_node == null) {
            return;
        }

        // Step 2: Remove this
        try mutation.remove(node, false);
    
    }

};


