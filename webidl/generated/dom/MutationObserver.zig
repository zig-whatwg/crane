// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const Append = @import("append").Append;
const Call = @import("call").Call;
const Callback = @import("callback").Callback;
const Called = @import("called").Called;
const Check = @import("check").Check;
const Clear = @import("clear").Clear;
const Data = @import("data").Data;
const DataOldValue = @import("data_old_value").DataOldValue;
const Empty = @import("empty").Empty;
const Enqueue = @import("enqueue").Enqueue;
const Filter = @import("filter").Filter;
const For = @import("for").For;
const Get = @import("get").Get;
const If = @import("if").If;
const Implement = @import("implement").Implement;
const Internal = @import("internal").Internal;
const Let = @import("let").Let;
const List = @import("list").List;
const MutationCallback = @import("mutation_callback").MutationCallback;
const MutationObserverInit = @import("mutation_observer_init").MutationObserverInit;
const MutationRecord = @import("mutation_record").MutationRecord;
const MutationRecord, observer: *MutationObserver) void;

// Import types that are shared between Node and MutationObserver
const MutationObserverInit = @import("mutation_observer_init").MutationRecord, observer: *MutationObserver) void;

// Import types that are shared between Node and MutationObserver
const MutationObserverInit;
const Node = @import("node").Node;
const NodeList = @import("node_list").NodeList;
const Observing = @import("observing").Observing;
const OldValue = @import("old_value").OldValue;
const Otherwise = @import("otherwise").Otherwise;
const Record = @import("record").Record;
const RecordQueue = @import("record_queue").RecordQueue;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const RegisteredObservers = @import("registered_observers").RegisteredObservers;
const Remove = @import("remove").Remove;
const RetainingCapacity = @import("retaining_capacity").RetainingCapacity;
const Return = @import("return").Return;
const Returns = @import("returns").Returns;
const Set = @import("set").Set;
const Step = @import("step").Step;
const TODO = @import("t_o_d_o").TODO;
const This = @import("this").This;
const TransientObservers = @import("transient_observers").TransientObservers;
const TransientRegisteredObserver = @import("registered_observer").TransientRegisteredObserver;
const TypeError = @import("type_error").TypeError;
const Used = @import("used").Used;
const Useful = @import("useful").Useful;
const WebIDL = @import("web_i_d_l").WebIDL;
const fn (mutations: []const MutationRecord, observer: *MutationObserver) void;

// Import types that are shared between Node and MutationObserver
const MutationObserverInit = @import("mutation_observer_init").fn (mutations: []const MutationRecord, observer: *MutationObserver) void;

// Import types that are shared between Node and MutationObserver
const MutationObserverInit;
const infra = @import("infra").infra;
const std = @import("std");
const std.ArrayList(*Node) = @import("std._array_list(*_node)").std.ArrayList(*Node);
const std.ArrayList(MutationRecord) = @import("std._array_list(_mutation_record)").std.ArrayList(MutationRecord);
const webidl = @import("webidl");


// Re-export for convenience
pub const Init = MutationObserverInit;
pub const Registered = RegisteredObserver;
pub const TransientRegistered = TransientRegisteredObserver;
/// DOM ยง7.1 - MutationObserver interface
///
/// MutationObservers can be used to observe mutations to the tree of nodes.

pub const MutationObserver = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    callback: MutationCallback,
    node_list: std.ArrayList(*Node),
    record_queue: std.ArrayList(MutationRecord),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: Allocator, callback: MutationCallback) !MutationObserver {

        return .{
            .allocator = allocator,
            .callback = callback,
            .node_list = std.ArrayList(*Node).init(allocator),
            .record_queue = std.ArrayList(MutationRecord).init(allocator),
        };
    
    }

    pub fn deinit(self: *MutationObserver) void {

        // Clear node list (don't free nodes, we don't own them)
        self.node_list.deinit();

        // Clear record queue
        // Call deinit on each record for proper cleanup
        for (self.record_queue.items) |*record| {
            record.deinit();
        }
        self.record_queue.deinit();
    
    }

    pub fn observe(self: *MutationObserver, target: *Node, options: MutationObserverInit) !void {

        // Step 1: If either options["attributeOldValue"] or options["attributeFilter"]
        // exists, and options["attributes"] does not exist, then set
        // options["attributes"] to true.
        var normalized_options = options;
        if ((options.attributeOldValue != null or options.attributeFilter != null) and
            options.attributes == null)
        {
            normalized_options.attributes = true;
        }

        // Step 2: If options["characterDataOldValue"] exists and
        // options["characterData"] does not exist, then set
        // options["characterData"] to true.
        if (options.characterDataOldValue != null and options.characterData == null) {
            normalized_options.characterData = true;
        }

        // Step 3: If none of options["childList"], options["attributes"], and
        // options["characterData"] is true, then throw a TypeError.
        const childList = normalized_options.childList;
        const attributes = normalized_options.attributes orelse false;
        const characterData = normalized_options.characterData orelse false;

        if (!childList and !attributes and !characterData) {
            return error.TypeError;
        }

        // Step 4: If options["attributeOldValue"] is true and options["attributes"]
        // is false, then throw a TypeError.
        if (normalized_options.attributeOldValue orelse false and !attributes) {
            return error.TypeError;
        }

        // Step 5: If options["attributeFilter"] is present and options["attributes"]
        // is false, then throw a TypeError.
        if (normalized_options.attributeFilter != null and !attributes) {
            return error.TypeError;
        }

        // Step 6: If options["characterDataOldValue"] is true and
        // options["characterData"] is false, then throw a TypeError.
        if (normalized_options.characterDataOldValue orelse false and !characterData) {
            return error.TypeError;
        }

        // Step 7: For each registered of target's registered observer list,
        // if registered's observer is this:
        const registered_observers = target.getRegisteredObservers();
        for (registered_observers.items) |*registered| {
            if (registered.observer == self) {
                // Step 7.1: For each node of this's node list, remove all
                // transient registered observers whose source is registered
                // from node's registered observer list.
                for (self.node_list.items) |node| {
                    try node.removeTransientObservers(registered);
                }

                // Step 7.2: Set registered's options to options.
                registered.options = normalized_options;
                return;
            }
        }

        // Step 8: Otherwise:
        // Step 8.1: Append a new registered observer whose observer is this
        // and options is options to target's registered observer list.
        try target.addRegisteredObserver(.{
            .observer = self,
            .options = normalized_options,
        });

        // Step 8.2: Append a weak reference to target to this's node list.
        // TODO: Implement proper weak references
        // For now, just append the pointer
        try self.node_list.append(self.allocator, target);
    
    }

    pub fn disconnect(self: *MutationObserver) void {

        // Step 1: For each node of this's node list, remove any registered
        // observer from node's registered observer list for which this is
        // the observer.
        for (self.node_list.items) |node| {
            node.removeRegisteredObserver(self);
        }

        // Step 2: Empty this's record queue.
        self.record_queue.clearRetainingCapacity();
    
    }

    pub fn takeRecords(self: *MutationObserver) ![]MutationRecord {
        // Step 1: Let records be a clone of this's record queue.
        const allocator = self.allocator;
        const records = try allocator.alloc(MutationRecord, self.record_queue.items.len);
        @memcpy(records, self.record_queue.items);

        // Step 2: Empty this's record queue.
        self.record_queue.clearRetainingCapacity();

        // Step 3: Return records.
        return records;
    }

    // ========================================================================
    // Internal methods (for mutation algorithms)
    // ========================================================================

    /// Enqueue a mutation record to this observer's record queue
    ///
    /// Called by mutation observation algorithms when mutations occur.
    /// This is an internal method, not exposed in the WebIDL.
    pub fn enqueueRecord(self: *MutationObserver, record: MutationRecord) !void {
        try self.record_queue.append(self.allocator, record);
    }

    /// Get the callback for this observer
    ///
    /// Used by the notify mutation observers algorithm.
    pub fn getCallback(self: *const MutationObserver) MutationCallback {
        return self.callback;
    }

    /// Get the node list for this observer
    ///
    /// Used by the notify mutation observers algorithm.
    pub fn getNodeList(self: *MutationObserver) []const *Node {
        return self.node_list.items;
    }

    /// Get the record queue for this observer
    ///
    /// Used by the notify mutation observers algorithm.
    pub fn getRecordQueue(self: *const MutationObserver) []const MutationRecord {
        return self.record_queue.items;
    }

    /// Check if this observer is observing a specific node
    ///
    /// Useful for caller to verify observation state before node cleanup.
    /// Returns true if the node is in this observer's node list.
    pub fn isObserving(self: *const MutationObserver, node: *const Node) bool {

        for (self.node_list.items) |observed_node| {
            if (observed_node == node) {
                return true;
            }
        }
        return false;
    
    }

    pub fn unobserveNode(self: *MutationObserver, node: *const Node) void {

        var i: usize = 0;
        while (i < self.node_list.items.len) {
            if (self.node_list.items[i] == node) {
                _ = self.node_list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    
    }

};


