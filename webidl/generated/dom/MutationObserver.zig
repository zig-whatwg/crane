// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const MutationObserverInit = @import("mutation_observer_init").MutationObserverInit;
const MutationRecord = @import("mutation_record").MutationRecord;
const Node = @import("node").Node;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const TransientRegisteredObserver = @import("registered_observer").TransientRegisteredObserver;
const infra = @import("infra");
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง7.1 - MutationCallback
///
/// Callback invoked when mutations are observed.
/// Arguments: (mutations: sequence<MutationRecord>, observer: MutationObserver)
pub const MutationCallback = *const fn (mutations: []const MutationRecord, observer: *MutationObserver) void;

// Import types that are shared between Node and MutationObserver

// Re-export for convenience
pub const Init = MutationObserverInit;
pub const Registered = RegisteredObserver;
pub const TransientRegistered = TransientRegisteredObserver;

/// DOM ยง7.1 - MutationObserver interface
///
/// MutationObservers can be used to observe mutations to the tree of nodes.

pub const MutationObserver = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    callback: MutationCallback,
    node_list: std.ArrayList(*Node),
    record_queue: std.ArrayList(MutationRecord),

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: Allocator, callback: MutationCallback) !MutationObserver {

        return .{
            .allocator = allocator,
            .callback = callback,
            .node_list = std.ArrayList(*Node).init(allocator),
            .record_queue = std.ArrayList(MutationRecord).init(allocator),
        };
    
    }

    pub fn deinit(self: *MutationObserver) void {

        // Clear node list (don't free nodes, we don't own them)
        self.node_list.deinit();

        // Clear record queue
        // Call deinit on each record for proper cleanup
        for (self.record_queue.items) |*record| {
            record.deinit();
        }
        self.record_queue.deinit();
    
    }

    pub fn observe(self: *MutationObserver, target: *Node, options: MutationObserverInit) !void {

        // Step 1: If either options["attributeOldValue"] or options["attributeFilter"]
        // exists, and options["attributes"] does not exist, then set
        // options["attributes"] to true.
        var normalized_options = options;
        if ((options.attributeOldValue != null or options.attributeFilter != null) and
            options.attributes == null)
        {
            normalized_options.attributes = true;
        }

        // Step 2: If options["characterDataOldValue"] exists and
        // options["characterData"] does not exist, then set
        // options["characterData"] to true.
        if (options.characterDataOldValue != null and options.characterData == null) {
            normalized_options.characterData = true;
        }

        // Step 3: If none of options["childList"], options["attributes"], and
        // options["characterData"] is true, then throw a TypeError.
        const childList = normalized_options.childList;
        const attributes = normalized_options.attributes orelse false;
        const characterData = normalized_options.characterData orelse false;

        if (!childList and !attributes and !characterData) {
            return error.TypeError;
        }

        // Step 4: If options["attributeOldValue"] is true and options["attributes"]
        // is false, then throw a TypeError.
        if (normalized_options.attributeOldValue orelse false and !attributes) {
            return error.TypeError;
        }

        // Step 5: If options["attributeFilter"] is present and options["attributes"]
        // is false, then throw a TypeError.
        if (normalized_options.attributeFilter != null and !attributes) {
            return error.TypeError;
        }

        // Step 6: If options["characterDataOldValue"] is true and
        // options["characterData"] is false, then throw a TypeError.
        if (normalized_options.characterDataOldValue orelse false and !characterData) {
            return error.TypeError;
        }

        // Step 7: For each registered of target's registered observer list,
        // if registered's observer is this:
        const registered_observers = target.getRegisteredObservers();
        for (registered_observers.items) |*registered| {
            if (registered.observer == self) {
                // Step 7.1: For each node of this's node list, remove all
                // transient registered observers whose source is registered
                // from node's registered observer list.
                for (self.node_list.items) |node| {
                    try node.removeTransientObservers(registered);
                }

                // Step 7.2: Set registered's options to options.
                registered.options = normalized_options;
                return;
            }
        }

        // Step 8: Otherwise:
        // Step 8.1: Append a new registered observer whose observer is this
        // and options is options to target's registered observer list.
        try target.addRegisteredObserver(.{
            .observer = self,
            .options = normalized_options,
        });

        // Step 8.2: Append a weak reference to target to this's node list.
        // TODO: Implement proper weak references
        // For now, just append the pointer
        try self.node_list.append(self.allocator, target);
    
    }

    pub fn disconnect(self: *MutationObserver) void {

        // Step 1: For each node of this's node list, remove any registered
        // observer from node's registered observer list for which this is
        // the observer.
        for (self.node_list.items) |node| {
            node.removeRegisteredObserver(self);
        }

        // Step 2: Empty this's record queue.
        self.record_queue.clearRetainingCapacity();
    
    }

    pub fn takeRecords(self: *MutationObserver) ![]MutationRecord {

        // Step 1: Let records be a clone of this's record queue.
        const allocator = self.allocator;
        const records = try allocator.alloc(MutationRecord, self.record_queue.items.len);
        @memcpy(records, self.record_queue.items);

        // Step 2: Empty this's record queue.
        self.record_queue.clearRetainingCapacity();

        // Step 3: Return records.
        return records;
    
    }

    pub fn enqueueRecord(self: *MutationObserver, record: MutationRecord) !void {

        try self.record_queue.append(self.allocator, record);
    
    }

    pub fn getCallback(self: *const MutationObserver) MutationCallback {

        return self.callback;
    
    }

    pub fn getNodeList(self: *MutationObserver) []const *Node {

        return self.node_list.items;
    
    }

    pub fn getRecordQueue(self: *const MutationObserver) []const MutationRecord {

        return self.record_queue.items;
    
    }

    pub fn isObserving(self: *const MutationObserver, node: *const Node) bool {

        for (self.node_list.items) |observed_node| {
            if (observed_node == node) {
                return true;
            }
        }
        return false;
    
    }

    pub fn unobserveNode(self: *MutationObserver, node: *const Node) void {

        var i: usize = 0;
        while (i < self.node_list.items.len) {
            if (self.node_list.items[i] == node) {
                _ = self.node_list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    
    }

    pub fn clearRecordQueue(self: *MutationObserver) void {

        self.record_queue.clearRetainingCapacity();
    
    }

};


// Tests

test "MutationObserver - construction" {
    const allocator = std.testing.allocator;

    // Mock callback
    const callback = struct {
        fn cb(_: []const MutationRecord, _: *MutationObserver) void {}
    }.cb;

    var observer = try MutationObserver.init(allocator, callback);
    defer observer.deinit();

    try std.testing.expectEqual(@as(usize, 0), observer.node_list.items.len);
    try std.testing.expectEqual(@as(usize, 0), observer.record_queue.items.len);
}

test "MutationObserver - observe validation" {
    const allocator = std.testing.allocator;

    const callback = struct {
        fn cb(_: []const MutationRecord, _: *MutationObserver) void {}
    }.cb;

    var observer = try MutationObserver.init(allocator, callback);
    defer observer.deinit();

    // Create a mock node
    // TODO: Replace with real Node once we have proper Node implementation
    var mock_node = Node{};
    // This should fail - need to implement Node.getRegisteredObservers() first
    // For now, just test the option validation

    // Test: No observation flags set -> TypeError
    try std.testing.expectError(
        error.TypeError,
        observer.observe(&mock_node, .{}),
    );

    // Test: attributeOldValue without attributes -> TypeError
    try std.testing.expectError(
        error.TypeError,
        observer.observe(&mock_node, .{
            .childList = true,
            .attributes = false,
            .attributeOldValue = true,
        }),
    );

    // Test: attributeFilter without attributes -> TypeError
    try std.testing.expectError(
        error.TypeError,
        observer.observe(&mock_node, .{
            .childList = true,
            .attributes = false,
            .attributeFilter = &[_][]const u8{"class"},
        }),
    );

    // Test: characterDataOldValue without characterData -> TypeError
    try std.testing.expectError(
        error.TypeError,
        observer.observe(&mock_node, .{
            .childList = true,
            .characterData = false,
            .characterDataOldValue = true,
        }),
    );
}

test "MutationObserver - disconnect clears record queue" {
    const allocator = std.testing.allocator;

    const callback = struct {
        fn cb(_: []const MutationRecord, _: *MutationObserver) void {}
    }.cb;

    var observer = try MutationObserver.init(allocator, callback);
    defer observer.deinit();

    // Add a mock record
    // TODO: Create proper MutationRecord when we have full Node implementation
    // For now, just test that disconnect clears the queue

    observer.disconnect();
    try std.testing.expectEqual(@as(usize, 0), observer.record_queue.items.len);
}

test "MutationObserver - takeRecords clones and clears queue" {
    const allocator = std.testing.allocator;

    const callback = struct {
        fn cb(_: []const MutationRecord, _: *MutationObserver) void {}
    }.cb;

    var observer = try MutationObserver.init(allocator, callback);
    defer observer.deinit();

    // Add mock records
    // TODO: Create proper MutationRecords when we have full Node implementation

    const records = try observer.takeRecords();
    defer allocator.free(records);

    try std.testing.expectEqual(@as(usize, 0), records.len);
    try std.testing.expectEqual(@as(usize, 0), observer.record_queue.items.len);
}


