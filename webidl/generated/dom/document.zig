// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Document interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-document
//!
//! Document represents an HTML or XML document. It's the entry point to the DOM tree.

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

const Node = @import("node").Node;
const Element = @import("element").Element;
const DocumentFragment = @import("document_fragment").DocumentFragment;
const Text = @import("text").Text;
const Comment = @import("comment").Comment;
const Attr = @import("attr").Attr;
/// Document WebIDL interface
/// Spec: https://dom.spec.whatwg.org/#interface-document
/// 
/// ```webidl
/// interface Document : Node {
/// constructor();
/// [SameObject] readonly attribute DOMImplementation implementation;
/// readonly attribute USVString URL;
/// readonly attribute USVString documentURI;
/// readonly attribute DOMString compatMode;
/// readonly attribute DOMString characterSet;
/// readonly attribute DOMString charset;
/// readonly attribute DOMString inputEncoding;
/// readonly attribute DOMString contentType;
/// readonly attribute DocumentType? doctype;
/// readonly attribute Element? documentElement;
/// 
/// Element createElement(DOMString localName, optional ... options);
/// Element createElementNS(DOMString? namespace, DOMString qualifiedName, optional ... options);
/// DocumentFragment createDocumentFragment();
/// Text createTextNode(DOMString data);
/// Comment createComment(DOMString data);
/// Attr createAttribute(DOMString localName);
/// Attr createAttributeNS(DOMString? namespace, DOMString qualifiedName);
/// 
/// Node importNode(Node node, optional boolean deep = false);
/// Node adoptNode(Node node);
/// 
/// Element? getElementById(DOMString elementId);
/// HTMLCollection getElementsByTagName(DOMString qualifiedName);
/// HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
/// HTMLCollection getElementsByClassName(DOMString classNames);
/// };
/// ```
pub const Document = struct {
    const Self = @This();

    allocator: std.mem.Allocator,

    /// The document's URL
    /// Spec: https://dom.spec.whatwg.org/#concept-document-url
    url: []const u8,
    /// The document's encoding (e.g., "UTF-8")
    /// Spec: https://dom.spec.whatwg.org/#concept-document-encoding
    encoding: []const u8,
    /// The document's content type (e.g., "text/html", "application/xml")
    /// Spec: https://dom.spec.whatwg.org/#concept-document-content-type
    contentType: []const u8,
    /// The document's type ("html" or "xml")
    /// Spec: https://dom.spec.whatwg.org/#concept-document-type
    documentType: DocumentType,
    /// The document's mode ("no-quirks", "quirks", or "limited-quirks")
    /// Spec: https://dom.spec.whatwg.org/#concept-document-mode
    mode: DocumentMode,

    pub const DocumentType = enum {
            html,
            xml,
        };
    pub const DocumentMode = enum {
            no_quirks,
            quirks,
            limited_quirks,
        };

    /// Create a new empty document
    /// Spec: https://dom.spec.whatwg.org/#dom-document-document
    pub fn init(allocator: std.mem.Allocator) !*Self {
        const doc = try allocator.create(Self);
        errdefer allocator.destroy(doc);

        doc.* = .{
            .allocator = allocator,
            .url = try allocator.dupe(u8, "about:blank"),
            .encoding = try allocator.dupe(u8, "UTF-8"),
            .contentType = try allocator.dupe(u8, "application/xml"),
            .documentType = .xml,
            .mode = .no_quirks,
        };

        return doc;
    }
    pub fn deinit(self: *Self) void {
        self.allocator.free(self.url);
        self.allocator.free(self.encoding);
        self.allocator.free(self.contentType);
        self.allocator.destroy(self);
    }

    /// Get the document's URL
    /// Spec: https://dom.spec.whatwg.org/#dom-document-url
    pub fn get_URL(self: *const Self) webidl.USVString {
        return self.url;
    }
    /// Get the document's URL (alias)
    /// Spec: https://dom.spec.whatwg.org/#dom-document-documenturi
    pub fn get_documentURI(self: *const Self) webidl.USVString {
        return self.url;
    }
    /// Get the document's compatibility mode
    /// Spec: https://dom.spec.whatwg.org/#dom-document-compatmode
    /// 
    /// Returns "BackCompat" for quirks mode, "CSS1Compat" otherwise
    pub fn get_compatMode(self: *const Self) webidl.DOMString {
        return switch (self.mode) {
            .quirks => "BackCompat",
            .no_quirks, .limited_quirks => "CSS1Compat",
        };
    }
    /// Get the document's character encoding
    /// Spec: https://dom.spec.whatwg.org/#dom-document-characterset
    pub fn get_characterSet(self: *const Self) webidl.DOMString {
        return self.encoding;
    }
    /// Get the document's character encoding (legacy alias)
    /// Spec: https://dom.spec.whatwg.org/#dom-document-charset
    pub fn get_charset(self: *const Self) webidl.DOMString {
        return self.encoding;
    }
    /// Get the document's character encoding (legacy alias)
    /// Spec: https://dom.spec.whatwg.org/#dom-document-inputencoding
    pub fn get_inputEncoding(self: *const Self) webidl.DOMString {
        return self.encoding;
    }
    /// Get the document's content type
    /// Spec: https://dom.spec.whatwg.org/#dom-document-contenttype
    pub fn get_contentType(self: *const Self) webidl.DOMString {
        return self.contentType;
    }
    /// Create a new element
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createelement
    pub fn call_createElement(
        self: *Self,
        localName: webidl.DOMString,
    ) !*Element {
        // Step 1: If localName does not match Name production, throw InvalidCharacterError
        if (!isValidElementName(localName)) {
            return error.InvalidCharacterError;
        }

        // Step 2: If document is HTML document, convert localName to ASCII lowercase
        const name = if (self.documentType == .html)
            try toLowerCaseAlloc(self.allocator, localName)
        else
            try self.allocator.dupe(u8, localName);
        errdefer self.allocator.free(name);

        // Step 3-4: Create element with namespace = HTML namespace (if HTML doc) or null
        const namespace = if (self.documentType == .html)
            try self.allocator.dupe(u8, "http://www.w3.org/1999/xhtml")
        else
            null;
        errdefer if (namespace) |ns| self.allocator.free(ns);

        // Create the element
        const elem = try self.allocator.create(Element);
        errdefer self.allocator.destroy(elem);

        elem.* = .{
            .allocator = self.allocator,
            .localName = name,
            .namespace = namespace,
            .namespacePrefix = null,
            .id = null,
            .class_name = null,
            .attributes = infra.List(Element.Attribute).init(self.allocator),
        };

        return elem;
    }
    /// Create a new element with namespace
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createelementns
    pub fn call_createElementNS(
        self: *Self,
        ns: ?webidl.DOMString,
        qualified_name: webidl.DOMString,
    ) !*Element {
        // Step 1: Validate and extract namespace, prefix, and localName
        // TODO: Implement full namespace validation per spec

        if (!isValidElementName(qualified_name)) {
            return error.InvalidCharacterError;
        }

        const name = try self.allocator.dupe(u8, qualified_name);
        errdefer self.allocator.free(name);

        const namespace = if (ns) |namespace_val| try self.allocator.dupe(u8, namespace_val) else null;
        errdefer if (namespace) |n| self.allocator.free(n);

        const elem = try self.allocator.create(Element);
        errdefer self.allocator.destroy(elem);

        elem.* = .{
            .allocator = self.allocator,
            .localName = name,
            .namespace = namespace,
            .namespacePrefix = null,
            .id = null,
            .class_name = null,
            .attributes = infra.List(Element.Attribute).init(self.allocator),
        };

        return elem;
    }
    /// Create a new document fragment
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createdocumentfragment
    pub fn call_createDocumentFragment(self: *Self) !*DocumentFragment {
        return try DocumentFragment.init(self.allocator);
    }
    /// Create a new text node
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createtextnode
    pub fn call_createTextNode(self: *Self, data: webidl.DOMString) !*Text {
        // Text.init returns a Text value, not a pointer, so we need to allocate
        const text = try self.allocator.create(Text);
        errdefer self.allocator.destroy(text);

        text.* = try Text.init(self.allocator, data);

        return text;
    }
    /// Create a new comment node
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createcomment
    pub fn call_createComment(self: *Self, data: webidl.DOMString) !*Comment {
        // Comment.init returns a Comment value, not a pointer, so we need to allocate
        const comment = try self.allocator.create(Comment);
        errdefer self.allocator.destroy(comment);

        comment.* = try Comment.init(self.allocator, data);

        return comment;
    }
    /// Create a new attribute
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createattribute
    pub fn call_createAttribute(self: *Self, localName: webidl.DOMString) !*Attr {
        if (!isValidAttributeName(localName)) {
            return error.InvalidCharacterError;
        }

        // For HTML documents, convert to ASCII lowercase
        const name = if (self.documentType == .html)
            try toLowerCaseAlloc(self.allocator, localName)
        else
            try self.allocator.dupe(u8, localName);
        errdefer self.allocator.free(name);

        const attr = try self.allocator.create(Attr);
        errdefer self.allocator.destroy(attr);

        attr.* = .{
            .allocator = self.allocator,
            .localName = name,
            .namespace_uri = null,
            .prefix = null,
            .value = try self.allocator.dupe(u8, ""),
            .owner_element = null,
        };

        return attr;
    }
    /// Create a new attribute with namespace
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createattributens
    pub fn call_createAttributeNS(
        self: *Self,
        ns: ?webidl.DOMString,
        qualified_name: webidl.DOMString,
    ) !*Attr {
        // TODO: Implement namespace handling

        if (!isValidAttributeName(qualified_name)) {
            return error.InvalidCharacterError;
        }

        const name = try self.allocator.dupe(u8, qualified_name);
        errdefer self.allocator.free(name);

        const namespace = if (ns) |namespace_val| try self.allocator.dupe(u8, namespace_val) else null;
        errdefer if (namespace) |n| self.allocator.free(n);

        const attr = try self.allocator.create(Attr);
        errdefer self.allocator.destroy(attr);

        attr.* = .{
            .allocator = self.allocator,
            .localName = name,
            .namespace_uri = namespace,
            .prefix = null,
            .value = try self.allocator.dupe(u8, ""),
            .owner_element = null,
        };

        return attr;
    }
    /// Import a node from another document
    /// Spec: https://dom.spec.whatwg.org/#dom-document-importnode
    /// 
    /// Returns a copy of node. If deep is true, the copy also includes the node's descendants.
    /// 
    /// Algorithm (from spec):
    /// 1. If node is a document or shadow root, throw NotSupportedError
    /// 2. Return the result of cloning node with document set to this and subtree set to deep
    pub fn call_importNode(
        self: *Self,
        node: *Node,
        deep: bool,
    ) !*Node {
        // Step 1: Validate node type
        // Per spec: "If node is a document or shadow root, then throw a NotSupportedError DOMException"
        // TODO: Check node type once Node has type identification
        _ = node;

        // Step 2: Clone the node
        // TODO(cloning): Implement node cloning infrastructure
        // This requires implementing the "clone a node" algorithm from DOM spec:
        // 1. Clone a single node (creates copy with same properties)
        // 2. If deep=true, recursively clone all descendants
        // 3. Run cloning steps for spec-defined behaviors
        // 4. Handle Shadow DOM (if node is shadow host with clonable root)
        // 5. Set clone's node document to this document
        //
        // Dependencies:
        // - Node.clone() method
        // - Tree traversal for recursive cloning
        // - Custom element registry handling
        // - Shadow root cloning
        _ = self;
        _ = deep;

        return error.NotImplemented;
    }
    /// Adopt a node into this document
    /// Spec: https://dom.spec.whatwg.org/#dom-document-adoptnode
    /// 
    /// Moves node from its current document to this document.
    /// 
    /// Algorithm (from spec):
    /// 1. If node is a document, throw NotSupportedError
    /// 2. If node is a shadow root, throw HierarchyRequestError
    /// 3. If node is a DocumentFragment with non-null host, return early
    /// 4. Adopt node into this document
    /// 5. Return node
    pub fn call_adoptNode(
        self: *Self,
        node: *Node,
    ) !*Node {
        // Step 1-3: Validate node type
        // Per spec:
        // - If node is document → throw NotSupportedError
        // - If node is shadow root → throw HierarchyRequestError
        // - If node is DocumentFragment with host → return early
        // TODO: Check node type once Node has type identification
        _ = node;

        // Step 4: Adopt the node
        // TODO(adoption): Implement node adoption infrastructure
        // This requires implementing the "adopt" algorithm from DOM spec:
        // 1. Let oldDocument = node's node document
        // 2. If node's parent is non-null, remove node
        // 3. If document ≠ oldDocument:
        //    a. For each descendant: set node document to this
        //    b. For each descendant: update custom element registry
        //    c. For each descendant: enqueue adoptedCallback reaction
        //    d. Run adopting steps for each descendant
        //
        // Dependencies:
        // - Node.remove() for detaching from current parent
        // - Tree traversal for updating all descendants
        // - Node document property
        // - Custom element registry support
        // - adoptedCallback reactions
        _ = self;

        return error.NotImplemented;
    }
    /// Get element by ID
    /// Spec: https://dom.spec.whatwg.org/#dom-document-getelementbyid
    /// 
    /// Returns the first element, in tree order, within this's descendants,
    /// whose ID is elementId; otherwise, if there is no such element, null.
    /// 
    /// Algorithm (from spec):
    /// 1. Return the first element, in tree order, within this's descendants,
    /// whose ID is elementId
    /// 2. If no such element exists, return null
    pub fn call_getElementById(
        self: *Self,
        element_id: webidl.DOMString,
    ) ?*Element {
        // TODO(tree-traversal): Implement tree traversal to find element by ID
        // This requires:
        // 1. Document to have children (as Node)
        // 2. Recursive descendant traversal in tree order
        // 3. Check each Element node's id field against element_id
        //
        // Pseudo-code:
        // ```
        // for each descendant of self in tree order:
        //     if descendant is Element:
        //         if descendant.id == element_id:
        //             return descendant
        // return null
        // ```
        _ = self;
        _ = element_id;
        return null;
    }
    /// Validate element name
    fn isValidElementName(name: []const u8) bool {
        if (name.len == 0) return false;

        // Basic validation - check for invalid characters
        for (name) |c| {
            if (c == 0 or c == ' ' or c == '\t' or c == '\n' or c == '\r' or
                c == '/' or c == '>')
            {
                return false;
            }
        }

        return true;
    }
    /// Validate attribute name
    fn isValidAttributeName(name: []const u8) bool {
        if (name.len == 0) return false;

        for (name) |c| {
            if (c == 0 or c == ' ' or c == '\t' or c == '\n' or c == '\r' or
                c == '/' or c == '=' or c == '>')
            {
                return false;
            }
        }

        return true;
    }
    /// Convert string to lowercase (allocates)
    fn toLowerCaseAlloc(allocator: std.mem.Allocator, str: []const u8) ![]const u8 {
        const result = try allocator.alloc(u8, str.len);
        errdefer allocator.free(result);

        for (str, 0..) |c, i| {
            result[i] = std.ascii.toLower(c);
        }

        return result;
    }
};

