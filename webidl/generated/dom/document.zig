// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Document interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-document

const std = @import("std");
const webidl = @import("webidl");
pub const dom = @import("dom");
pub const Node = @import("node").Node;
pub const NodeList = @import("node_list").NodeList;
pub const HTMLCollection = @import("html_collection").HTMLCollection;
pub const dom_types = @import("dom_types");
pub const ProcessingInstruction = @import("processing_instruction").ProcessingInstruction;
pub const CDATASection = @import("cdata_section").CDATASection;
pub const DocumentType = @import("document_type").DocumentType;
pub const DOMImplementation = @import("dom_implementation").DOMImplementation;
/// DOM Spec: interface Document : Node
const NodeBase = @import("node").NodeBase;
const EventListener = @import("event_target").EventListener;
const Event = @import("event").Event;
const flattenOptions = @import("event_target").flattenOptions;
const flattenMoreOptions = @import("event_target").flattenMoreOptions;
const defaultPassiveValue = @import("event_target").defaultPassiveValue;
const Allocator = std.mem.Allocator;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const GetRootNodeOptions = @import("node").GetRootNodeOptions;
const Element = @import("element").Element;
const ELEMENT_NODE = @import("node").ELEMENT_NODE;
const DOCUMENT_NODE = @import("node").DOCUMENT_NODE;
const DOCUMENT_POSITION_DISCONNECTED = @import("node").DOCUMENT_POSITION_DISCONNECTED;
const infra = @import("infra");
const ParentNode = @import("parent_node").ParentNode;
const NonElementParentNode = @import("non_element_parent_node").NonElementParentNode;
const DocumentOrShadowRoot = @import("document_or_shadow_root").DocumentOrShadowRoot;
pub const Document = struct {
    base: NodeBase,

    // ========================================================================
    // Fields from DocumentOrShadowRoot mixin
    // ========================================================================
    /// Custom element registry for this document or shadow root
    /// TODO: Implement when CustomElementRegistry is available
    custom_element_registry: ?*anyopaque = null,

    // ========================================================================
    // Document fields
    // ========================================================================
    allocator: Allocator,
    /// Cached DOMImplementation instance ([SameObject])
    _implementation: ?DOMImplementation,
    /// String interning pool for tag names, attribute names, etc.
    /// Provides memory savings (20-30%) and O(1) string comparison via pointer equality
    _string_pool: std.StringHashMap(void),

    pub const includes = .{ ParentNode, NonElementParentNode, DocumentOrShadowRoot };
    pub const Text = @import("text").Text;
    pub const Comment = @import("comment").Comment;
    pub const DocumentFragment = @import("document_fragment").DocumentFragment;
    pub const Attr = @import("attr").Attr;

    pub fn init(allocator: Allocator) !Document {
        // NOTE: Parent Node fields will be flattened by codegen
        return .{
            .base = undefined,
            .allocator = allocator,
            ._implementation = null,
            ._string_pool = std.StringHashMap(void).init(allocator),
            // TODO: Initialize Node parent fields (will be added by codegen)
        };
    }
    pub fn deinit(self: *Document) void {
        // Free all interned strings from pool
        var it = self._string_pool.keyIterator();
        while (it.next()) |key_ptr| {
            self.allocator.free(key_ptr.*);
        }
        self._string_pool.deinit();

        // Clean up cached implementation if it exists
        if (self._implementation) |*impl| {
            impl.deinit();
        }
        // NOTE: Parent Node cleanup will be handled by codegen
        // TODO: Call parent Node deinit (will be added by codegen)
    }


    // ========================================================================
    // Methods from ParentNode mixin
    // ========================================================================

    /// DOM §4.3.2 - ParentNode.children
    /// Returns the child elements.
    /// 
    /// The children getter steps are to return an HTMLCollection collection rooted
    /// at this matching only element children.
    /// (Included from ParentNode mixin)
    pub fn get_children(self: anytype) *HTMLCollection {
        _ = self;
        // TODO: Implement DOM §4.3.2 children getter
        // 1. Return HTMLCollection rooted at this
        // 2. Collection matches only element children (not text, comment, etc.)
        @panic("ParentNode.children() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.firstElementChild
    /// Returns the first child that is an element; otherwise null.
    /// 
    /// The firstElementChild getter steps are to return the first child that is
    /// an element; otherwise null.
    /// (Included from ParentNode mixin)
    pub fn get_firstElementChild(self: anytype) ?*Element {
        _ = self;
        // TODO: Implement DOM §4.3.2 firstElementChild getter
        // 1. Iterate through children (in tree order)
        // 2. Return first child that is an Element
        // 3. Return null if no element children
        @panic("ParentNode.firstElementChild() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.lastElementChild
    /// Returns the last child that is an element; otherwise null.
    /// 
    /// The lastElementChild getter steps are to return the last child that is
    /// an element; otherwise null.
    /// (Included from ParentNode mixin)
    pub fn get_lastElementChild(self: anytype) ?*Element {
        _ = self;
        // TODO: Implement DOM §4.3.2 lastElementChild getter
        // 1. Iterate through children (in reverse tree order)
        // 2. Return last child that is an Element
        // 3. Return null if no element children
        @panic("ParentNode.lastElementChild() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.childElementCount
    /// Returns the number of children that are elements.
    /// 
    /// The childElementCount getter steps are to return the number of children
    /// of this that are elements.
    /// (Included from ParentNode mixin)
    pub fn get_childElementCount(self: anytype) u32 {
        _ = self;
        // TODO: Implement DOM §4.3.2 childElementCount getter
        // 1. Count children that are Elements
        // 2. Return count as unsigned long (u32)
        @panic("ParentNode.childElementCount() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.prepend()
    /// Inserts nodes before the first child, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Pre-insert node into this before this's first child.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ParentNode mixin)
    pub fn call_prepend(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.2 prepend() algorithm
        // Step 1: Convert nodes into a node (see convertNodesIntoNode helper)
        // Step 2: Pre-insert node before first child (from mutation.zig)
        @panic("ParentNode.prepend() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.append()
    /// Inserts nodes after the last child, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Append node to this.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ParentNode mixin)
    pub fn call_append(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.2 append() algorithm
        // Step 1: Convert nodes into a node (see convertNodesIntoNode helper)
        // Step 2: Append node to this (from mutation.zig)
        @panic("ParentNode.append() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.replaceChildren()
    /// Replaces all children with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Ensure pre-insert validity of node into this before null.
    /// 3. Replace all with node within this.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ParentNode mixin)
    pub fn call_replaceChildren(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.2 replaceChildren() algorithm
        // Step 1: Convert nodes into a node (see convertNodesIntoNode helper)
        // Step 2: Ensure pre-insert validity (from mutation.zig)
        // Step 3: Replace all (from mutation.zig)
        @panic("ParentNode.replaceChildren() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.moveBefore()
    /// Moves, without first removing, movedNode into this after child.
    /// This method preserves state associated with movedNode.
    /// 
    /// Steps:
    /// 1. Let referenceChild be child.
    /// 2. If referenceChild is node, then set referenceChild to node's next sibling.
    /// 3. Move node into this before referenceChild.
    /// 
    /// Throws HierarchyRequestError if constraints violated, or state cannot be preserved.
    /// (Included from ParentNode mixin)
    pub fn call_moveBefore(self: anytype, node: anytype, child: anytype) !void {
        _ = self;
        _ = node;
        _ = child;
        // TODO: Implement DOM §4.3.2 moveBefore() algorithm
        // Step 1: Set referenceChild to child
        // Step 2: If referenceChild is node, adjust to node's next sibling
        // Step 3: Call move algorithm (from mutation.zig - when implemented)
        @panic("ParentNode.moveBefore() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.querySelector()
    /// Returns the first element that is a descendant of this that matches selectors.
    /// 
    /// The querySelector(selectors) method steps are to return the first result of
    /// running scope-match a selectors string selectors against this, if the result
    /// is not an empty list; otherwise null.
    /// 
    /// Uses Selectors mock (basic support only).
    /// (Included from ParentNode mixin)
    pub fn call_querySelector(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !?*Element {
        // Run scope-match a selectors string against this
        const matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Return first result if not empty; otherwise null
        if (matches.items.len > 0) {
            return matches.items[0];
        }

        return null;
    }
    /// DOM §4.3.2 - ParentNode.querySelectorAll()
    /// Returns all element descendants of this that match selectors.
    /// 
    /// The querySelectorAll(selectors) method steps are to return the static result
    /// of running scope-match a selectors string selectors against this.
    /// 
    /// Uses Selectors mock (basic support only).
    /// (Included from ParentNode mixin)
    pub fn call_querySelectorAll(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !*NodeList {
        // Run scope-match a selectors string against this
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // TODO: Convert ArrayList to NodeList (static snapshot)
        // For now, stub - need to implement NodeList creation from matches
        if (matches.items.len == 0) {
            @panic("ParentNode.querySelectorAll() - NodeList conversion not yet implemented");
        }
        @panic("ParentNode.querySelectorAll() - NodeList conversion not yet implemented");
    }
    // ========================================================================
    // Methods from NonElementParentNode mixin
    // ========================================================================

    /// DOM §4.3.1 - NonElementParentNode.getElementById()
    /// Returns the first element within this node's descendants whose ID is elementId.
    /// 
    /// The getElementById(elementId) method steps are:
    /// 1. If this is not a Document or DocumentFragment, return null
    /// 2. Return the first element, in tree order, within this's descendants,
    /// that has an ID equal to elementId; otherwise null
    /// 
    /// TODO: Implement tree traversal and ID matching
    /// (Included from NonElementParentNode mixin)
    pub fn call_getElementById(self: anytype, allocator: std.mem.Allocator, element_id: []const u8) !?*Element {
        _ = self;
        _ = allocator;
        _ = element_id;
        return error.NotImplemented;
    }
    // ========================================================================
    // Methods from DocumentOrShadowRoot mixin
    // ========================================================================

    /// Set the custom element registry
    /// (Included from DocumentOrShadowRoot mixin)
    pub fn setCustomElementRegistry(self: *@This(), registry: ?*anyopaque) void {
        self.custom_element_registry = registry;
    }
    // ========================================================================
    // Document methods
    // ========================================================================

    /// Intern a string in the document's string pool
    /// Returns a pointer to the interned string which can be compared via pointer equality
    /// If the string is already interned, returns the existing copy
    /// Caller does NOT own the returned slice - it's managed by the Document
    pub fn internString(self: *Document, str: []const u8) ![]const u8 {
        // Check if string is already interned
        if (self._string_pool.getKey(str)) |existing| {
            return existing;
        }

        // Not interned yet - allocate and store
        const owned = try self.allocator.dupe(u8, str);
        errdefer self.allocator.free(owned);

        try self._string_pool.put(owned, {});
        return owned;
    }
    /// implementation getter
    /// DOM §4.6 - Returns document's DOMImplementation object
    /// [SameObject] - Always returns the same instance
    pub fn get_implementation(self: *Document) !DOMImplementation {
        if (self._implementation) |impl| {
            return impl;
        }
        // Create and cache the implementation
        const impl = try DOMImplementation.init(self.allocator, self);
        self._implementation = impl;
        return impl;
    }
    /// createElement(localName)
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createelement
    pub fn call_createElement(self: *Document, local_name: []const u8) !*Element {
        // Intern the tag name for memory savings and fast comparison
        const interned_name = try self.internString(local_name);

        const element = try self.allocator.create(Element);
        element.* = try Element.init(self.allocator, interned_name);
        return element;
    }
    /// createTextNode(data)
    /// Spec: https://dom.spec.whatwg.org/#dom-document-createtextnode
    pub fn call_createTextNode(self: *Document, data: []const u8) !*Text {
        const text = try self.allocator.create(Text);
        text.* = try Text.init(self.allocator);
        // TODO: Set text.data = data when CharacterData has data field accessible
        _ = data;
        return text;
    }
    /// createComment(data)
    /// DOM §4.6.1 - The createComment(data) method steps are to return
    /// a new Comment node whose data is data and node document is this.
    pub fn call_createComment(self: *Document, data: []const u8) !*Comment {
        const comment = try self.allocator.create(Comment);
        comment.* = try Comment.init(self.allocator);
        // TODO: Set comment.data = data when CharacterData has data field accessible
        _ = data;
        return comment;
    }
    /// createProcessingInstruction(target, data)
    /// DOM §4.6.1 - Creates a ProcessingInstruction node
    /// Returns a new ProcessingInstruction node whose target is target, data is data,
    /// and node document is this.
    pub fn call_createProcessingInstruction(
        self: *Document,
        target: []const u8,
        data: []const u8,
    ) !*ProcessingInstruction {
        const pi = try self.allocator.create(ProcessingInstruction);
        pi.* = try ProcessingInstruction.init(self.allocator, target, data);
        return pi;
    }

    /// createCDATASection(data)
    /// DOM §4.6.1 - Creates a CDATASection node
    /// Returns a new CDATASection node whose data is data and node document is this.
    pub fn call_createCDATASection(self: *Document, data: []const u8) !*CDATASection {
        const cdata = try self.allocator.create(CDATASection);
        cdata.* = try CDATASection.init(self.allocator, data);
        return cdata;
    }
    /// createDocumentType(qualifiedName, publicId, systemId)
    /// DOM §4.6.1 - Creates a DocumentType node
    /// Returns a new DocumentType node whose name is qualifiedName, public ID is publicId,
    /// system ID is systemId, and node document is this.
    pub fn call_createDocumentType(
        self: *Document,
        qualified_name: []const u8,
        public_id: []const u8,
        system_id: []const u8,
    ) !*DocumentType {
        const doctype = try self.allocator.create(DocumentType);
        doctype.* = try DocumentType.init(self.allocator, qualified_name, public_id, system_id);
        return doctype;
    }
    /// createDocumentFragment()
    /// DOM §4.6.1 - The createDocumentFragment() method steps are to return
    /// a new DocumentFragment node whose node document is this.
    pub fn call_createDocumentFragment(self: *Document) !*DocumentFragment {
        const fragment = try self.allocator.create(DocumentFragment);
        fragment.* = try DocumentFragment.init(self.allocator);
        return fragment;
    }
    /// createElementNS(namespace, qualifiedName)
    /// DOM §4.6.1 - Creates an element in the given namespace
    /// TODO: Implement full namespace handling and qualified name parsing
    pub fn call_createElementNS(
        self: *Document,
        namespace: ?[]const u8,
        qualified_name: []const u8,
    ) !*Element {
        const element = try self.allocator.create(Element);
        element.* = try Element.init(self.allocator, qualified_name);
        // TODO: Set namespace_uri from namespace parameter
        _ = namespace;
        return element;
    }
    /// createAttribute(localName)
    /// DOM §4.6.1 - Creates an Attr node with the given local name
    pub fn call_createAttribute(self: *Document, local_name: []const u8) !*Attr {
        _ = self;
        _ = local_name;
        return error.NotImplemented;
    }
    /// createAttributeNS(namespace, qualifiedName)
    /// DOM §4.6.1 - Creates an Attr node in the given namespace
    pub fn call_createAttributeNS(
        self: *Document,
        namespace: ?[]const u8,
        qualified_name: []const u8,
    ) !*Attr {
        _ = self;
        _ = namespace;
        _ = qualified_name;
        return error.NotImplemented;
    }
    /// importNode(node, deep)
    /// DOM §4.6.1 - Returns a copy of node imported into this document.
    /// If deep is true, the copy also includes the node's descendants.
    /// TODO: Implement full node cloning algorithm
    pub fn call_importNode(self: *Document, node: *Node, deep: bool) !*Node {
        _ = self;
        _ = node;
        _ = deep;
        return error.NotImplemented;
    }
    /// adoptNode(node)
    /// DOM §4.6.1 - Moves node from another document to this document.
    /// Removes node from its current document and changes its owner document to this.
    /// TODO: Implement full adoption algorithm with parent removal
    pub fn call_adoptNode(self: *Document, node: *Node) !*Node {
        _ = self;
        _ = node;
        return error.NotImplemented;
    }
    /// insertBefore(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-insertbefore
    pub fn call_insertBefore(self: *Document, node: *Document, child: ?*Document) !*Document {
        // TODO: Use mutation.preInsert algorithm from src/dom/mutation.zig
        // For now, basic implementation
        _ = child;
        try self.child_nodes.append(node);
        node.parent_node = self;
        return node;
    }
    /// appendChild(node)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-appendchild
    pub fn call_appendChild(self: *Document, node: *Document) !*Document {
        // TODO: Use mutation.append algorithm from src/dom/mutation.zig
        try self.child_nodes.append(node);
        node.parent_node = self;
        return node;
    }
    /// replaceChild(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-replacechild
    pub fn call_replaceChild(self: *Document, node: *Document, child: *Document) !*Document {
        // TODO: Use mutation.replace algorithm from src/dom/mutation.zig
        // For now, basic implementation
        for (self.child_nodes.items, 0..) |existing, i| {
            if (existing == child) {
                self.child_nodes.items[i] = node;
                child.parent_node = null;
                node.parent_node = self;
                return child;
            }
        }
        return error.NotFoundError;
    }
    /// removeChild(child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-removechild
    pub fn call_removeChild(self: *Document, child: *Document) !*Document {
        // TODO: Use mutation.preRemove algorithm from src/dom/mutation.zig
        for (self.child_nodes.items, 0..) |node, i| {
            if (node == child) {
                _ = self.child_nodes.orderedRemove(i);
                child.parent_node = null;
                return child;
            }
        }
        return error.NotFoundError;
    }
    /// getRootNode(options)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-getrootnode
    pub fn call_getRootNode(self: *Document, options: ?GetRootNodeOptions) *Document {
        // TODO: Support shadow-including root when options.composed is true
        _ = options;
        // For now, return regular root (from tree.zig)
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        return current;
    }
    /// contains(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-contains
    pub fn call_contains(self: *const Document, other: ?*const Document) bool {
        if (other == null) return false;
        // Check if other is an inclusive descendant of this
        // TODO: Use tree.isInclusiveDescendant from src/dom/tree.zig
        const other_node = other.?;
        if (self == other_node) return true;

        var current = other_node.parent_node;
        while (current) |parent| {
            if (parent == self) return true;
            current = parent.parent_node;
        }
        return false;
    }
    /// compareDocumentPosition(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    pub fn call_compareDocumentPosition(self: *const Document, other: *const Document) u16 {
        // TODO: Implement full algorithm from spec
        // For now, return disconnected
        _ = self;
        _ = other;
        return DOCUMENT_POSITION_DISCONNECTED;
    }
    /// isEqualNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isequalnode
    pub fn call_isEqualNode(self: *const Document, other_node: ?*const Document) bool {
        if (other_node == null) return false;
        // TODO: Implement deep equality check per spec
        const other = other_node.?;
        if (self.node_type != other.node_type) return false;
        if (!std.mem.eql(u8, self.node_name, other.node_name)) return false;
        // TODO: Check children, attributes, etc.
        return true;
    }
    /// isSameNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-issamenode
    pub fn call_isSameNode(self: *const Document, other_node: ?*const Document) bool {
        // Legacy alias of === (pointer equality)
        if (other_node == null) return false;
        return self == other_node.?;
    }
    /// hasChildNodes()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-haschildnodes
    pub fn call_hasChildNodes(self: *const Document) bool {
        return self.child_nodes.len > 0;
    }
    /// cloneNode(deep)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-clonenode
    pub fn call_cloneNode(self: *Document, deep: bool) !*Document {
        // TODO: Implement full clone algorithm from DOM §4.2.4
        // Steps:
        // 1. Let document be node's node document
        // 2. Let copy be result of cloning a single node (node, document, null)
        // 3. Run cloning steps for node (pass node, copy, deep)
        // 4. If deep is true, clone all descendants recursively
        // 5. If node is shadow host and clonable, clone shadow root too
        // 6. Return copy

        // For now, shallow clone only
        const copy = try Document.init(self.allocator, self.node_type, self.node_name);

        // If deep, should recursively clone children
        if (deep) {
            // TODO: Clone all children recursively
            // for (self.child_nodes.items) |child| {
            //     const child_copy = try child.call_cloneNode(true);
            //     try copy.child_nodes.append(child_copy);
            //     child_copy.parent_node = &copy;
            // }
        }

        return copy;
    }
    /// normalize()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-normalize
    pub fn call_normalize(self: *Document) void {
        _ = self;
        // Normalize adjacent text nodes
    }
    /// Getters
    pub fn get_nodeType(self: *const Document) u16 {
        return self.node_type;
    }
    pub fn get_nodeName(self: *const Document) []const u8 {
        return self.node_name;
    }
    pub fn get_parentNode(self: *const Document) ?*Document {
        return self.parent_node;
    }
    pub fn get_parentElement(self: *const Document) ?*Element {
        // Returns parent if it's an Element, null otherwise
        const parent = self.parent_node orelse return null;
        if (parent.node_type == ELEMENT_NODE) {
            // TODO: Proper type casting when Element type is integrated
            return @ptrCast(parent);
        }
        return null;
    }
    pub fn get_childNodes(self: *const Document) *const infra.List(*Document) {
        // Returns a NodeList rooted at this matching only children
        // TODO: Return actual NodeList interface when implemented
        return &self.child_nodes;
    }
    pub fn get_firstChild(self: *const Document) ?*Document {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(0);
        }
        return null;
    }
    pub fn get_lastChild(self: *const Document) ?*Document {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(self.child_nodes.len - 1);
        }
        return null;
    }
    pub fn get_ownerDocument(self: *const Document) ?*Document {
        return self.owner_document;
    }
    pub fn get_previousSibling(self: *const Document) ?*Document {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i == 0) return null;
                return parent.child_nodes.items[i - 1];
            }
        }
        return null;
    }
    pub fn get_nextSibling(self: *const Document) ?*Document {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i + 1 >= parent.child_nodes.items.len) return null;
                return parent.child_nodes.items[i + 1];
            }
        }
        return null;
    }
    pub fn get_isConnected(self: *const Document) bool {
        // A node is connected if its root is a document
        // TODO: Use tree.root from src/dom/tree.zig
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        // Check if root is a document (node_type == DOCUMENT_NODE)
        return current.node_type == DOCUMENT_NODE;
    }
    pub fn get_baseURI(self: *const Document) []const u8 {
        // Returns node document's document base URL, serialized
        // TODO: Implement once Document has base URL support
        _ = self;
        return "";
    }
    pub fn get_nodeValue(self: *const Document) ?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // Returns value for Attr and CharacterData, null otherwise
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        return null;
    }
    pub fn set_nodeValue(self: *Document, value: ?[]const u8) void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // If null, treat as empty string
        // Set value for Attr, replace data for CharacterData
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        _ = value;
    }
    pub fn get_textContent(self: *const Document) ?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // Returns text content based on node type
        // TODO: Implement full algorithm:
        // - DocumentFragment, Element: concatenated text of descendants
        // - Attr, CharacterData: return their data
        // - Document, DocumentType: null
        _ = self;
        return null;
    }
    pub fn set_textContent(self: *Document, value: ?[]const u8) !void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // If null, treat as empty string
        // For DocumentFragment/Element: string replace all
        // TODO: Implement full algorithm using mutation.replaceAll
        _ = self;
        _ = value;
    }
    /// lookupPrefix(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupprefix
    pub fn call_lookupPrefix(self: *const Document, namespace_param: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return null;
    }
    /// lookupNamespaceURI(prefix)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
    pub fn call_lookupNamespaceURI(self: *const Document, prefix: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = prefix;
        return null;
    }
    /// isDefaultNamespace(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
    pub fn call_isDefaultNamespace(self: *const Document, namespace_param: ?[]const u8) bool {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return false;
    }
    /// Get the list of registered observers for this node
    pub fn getRegisteredObservers(self: *Document) *std.ArrayList(RegisteredObserver) {
        return &self.registered_observers;
    }
    /// Add a registered observer to this node's list
    pub fn addRegisteredObserver(self: *Document, registered: RegisteredObserver) !void {
        try self.registered_observers.append(registered);
    }
    /// Remove all registered observers for a specific MutationObserver
    pub fn removeRegisteredObserver(self: *Document, observer: *const @import("mutation_observer").MutationObserver) void {
        var i: usize = 0;
        while (i < self.registered_observers.items.len) {
            if (self.registered_observers.items[i].observer == observer) {
                _ = self.registered_observers.orderedRemove(i);
                // Don't increment i, we just shifted everything down
            } else {
                i += 1;
            }
        }
    }
    /// Remove all transient registered observers whose source matches the given registered observer
    pub fn removeTransientObservers(self: *Document, source: *const RegisteredObserver) !void {
        // TODO: Implement transient registered observers
        // For now, this is a no-op since we haven't implemented transient observers yet
        _ = self;
        _ = source;
    }
    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *Document) !*std.ArrayList(EventListener) {
        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    }
    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const Document) []const EventListener {
        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    }
    /// DOM §2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *Document, listener: EventListener) !void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            _ = signal;
            // TODO: Check if signal is aborted
            // if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture)
            {
                // TODO: Compare callbacks properly
                // For now, assume same callback if type and capture match
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        if (listener.signal) |_| {
            // TODO: Add abort steps to signal to remove listener
        }
    }
    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *Document,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {
        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    }
    /// DOM §2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *Document, listener: EventListener) void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture)
            {
                // TODO: Compare callbacks properly
                // For now, assume match if type and capture match
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    }
    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *Document,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {
        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    }
    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *Document, event: *Event) !bool {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this
        // TODO: Implement dispatch algorithm (see whatwg-cbk)
        _ = self;
        @panic("dispatchEvent - dispatch algorithm not yet implemented (see whatwg-cbk)");
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Document",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// ============================================================================
// Tests for string interning
// ============================================================================

test "Document - internString basic deduplication" {
    const allocator = std.testing.allocator;

    const doc = try allocator.create(Document);
    defer allocator.destroy(doc);
    doc.* = try Document.init(allocator);
    defer doc.deinit();

    // Intern same string twice
    const str1 = try doc.internString("div");
    const str2 = try doc.internString("div");

    // Should return same pointer (deduplicated)
    try std.testing.expect(str1.ptr == str2.ptr);
    try std.testing.expectEqualStrings("div", str1);
}

test "Document - internString different strings" {
    const allocator = std.testing.allocator;

    const doc = try allocator.create(Document);
    defer allocator.destroy(doc);
    doc.* = try Document.init(allocator);
    defer doc.deinit();

    const div = try doc.internString("div");
    const span = try doc.internString("span");

    // Different strings should have different pointers
    try std.testing.expect(div.ptr != span.ptr);
    try std.testing.expectEqualStrings("div", div);
    try std.testing.expectEqualStrings("span", span);
}

test "Document - createElement uses interned tag names" {
    const allocator = std.testing.allocator;

    const doc = try allocator.create(Document);
    defer allocator.destroy(doc);
    doc.* = try Document.init(allocator);
    defer doc.deinit();

    // Create multiple elements with same tag
    const div1 = try doc.call_createElement("div");
    defer {
        div1.deinit();
        allocator.destroy(div1);
    }

    const div2 = try doc.call_createElement("div");
    defer {
        div2.deinit();
        allocator.destroy(div2);
    }

    // Both elements should share the same interned tag name
    try std.testing.expect(div1.tag_name.ptr == div2.tag_name.ptr);
    try std.testing.expectEqualStrings("div", div1.tag_name);
}

test "Document - string interning memory cleanup" {
    const allocator = std.testing.allocator;

    // Create and destroy document with interned strings
    {
        const doc = try allocator.create(Document);
        defer allocator.destroy(doc);
        doc.* = try Document.init(allocator);

        // Intern several strings
        _ = try doc.internString("div");
        _ = try doc.internString("span");
        _ = try doc.internString("p");

        // deinit should free all interned strings
        doc.deinit();
    }

    // std.testing.allocator will fail if there are memory leaks
}
