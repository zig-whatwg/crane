// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! CharacterData interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-characterdata

const std = @import("std");
const webidl = @import("webidl");
pub const dom_types = @import("dom_types");
const Node = @import("node").Node;
const Allocator = std.mem.Allocator;
const infra = @import("infra");
/// Runtime type tag for CharacterData hierarchy.
/// Used for safe downcasting from CharacterDataBase to derived types.
pub const CharacterDataTypeTag = enum {
    CharacterData,
    CDATASection,
    Comment,
    Text,
    ProcessingInstruction,
};

/// Base struct for CharacterData hierarchy polymorphism.
/// All CharacterData-derived types have `base: CharacterDataBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const CharacterDataBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: CharacterDataTypeTag,

    allocator: Allocator,
    /// The mutable string data associated with this node
    data: []u8,

    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for CDATASection.
    /// Use this in CDATASection.init() to properly initialize the base field.
    pub fn initForCDATASection(allocator: Allocator) CharacterDataBase {
        return .{
            .type_tag = .CDATASection,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for Comment.
    /// Use this in Comment.init() to properly initialize the base field.
    pub fn initForComment(allocator: Allocator) CharacterDataBase {
        return .{
            .type_tag = .Comment,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for Text.
    /// Use this in Text.init() to properly initialize the base field.
    pub fn initForText(allocator: Allocator) CharacterDataBase {
        return .{
            .type_tag = .Text,
            .allocator = allocator,
        };
    }

    /// Create a base struct initialized for ProcessingInstruction.
    /// Use this in ProcessingInstruction.init() to properly initialize the base field.
    pub fn initForProcessingInstruction(allocator: Allocator) CharacterDataBase {
        return .{
            .type_tag = .ProcessingInstruction,
            .allocator = allocator,
        };
    }


    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *CharacterDataBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    /// 
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *CharacterDataBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(CharacterDataTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const CharacterDataBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(CharacterDataTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in CharacterData hierarchy:
    //   - CDATASection
    //   - Comment
    //   - Text
    //   - ProcessingInstruction
    //

};

/// DOM Spec: interface CharacterData : Node
const NodeBase = @import("node").NodeBase;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const GetRootNodeOptions = @import("node").GetRootNodeOptions;
const Document = @import("document").Document;
const Element = @import("element").Element;
const ELEMENT_NODE = @import("node").ELEMENT_NODE;
const DOCUMENT_NODE = @import("node").DOCUMENT_NODE;
const DOCUMENT_POSITION_DISCONNECTED = @import("node").DOCUMENT_POSITION_DISCONNECTED;
const ChildNode = @import("child_node").ChildNode;
const NonDocumentTypeChildNode = @import("non_document_type_child_node").NonDocumentTypeChildNode;
pub const CharacterData = struct {
    base: NodeBase,

    // ========================================================================
    // CharacterData fields
    // ========================================================================
    allocator: Allocator,
    /// The mutable string data associated with this node
    data: []u8,

    pub const includes = .{ ChildNode, NonDocumentTypeChildNode };

    pub fn init(allocator: Allocator) !CharacterData {
        // NOTE: Parent Node fields will be flattened by codegen
        return .{
            .base = NodeBase.initForCharacterData(allocator),
            .allocator = allocator,
            .data = try allocator.dupe(u8, ""),
            // TODO: Initialize Node parent fields (will be added by codegen)
        };
    }
    pub fn deinit(self: *CharacterData) void {
        self.allocator.free(self.data);
        // NOTE: Parent Node cleanup is handled by codegen
    }

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to NodeBase for type-generic code.
    pub fn toBase(self: *CharacterData) *NodeBase {
        return &self.base;
    }


    // ========================================================================
    // Methods from ChildNode mixin
    // ========================================================================

    /// DOM §4.3.4 - ChildNode.before()
    /// Inserts nodes just before this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If viablePreviousSibling is null, then set it to parent's first child; otherwise to viablePreviousSibling's next sibling.
    /// 6. Pre-insert node into parent before viablePreviousSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_before(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.4 before() algorithm
        // Step 1: Get parent
        // Step 2: If parent is null, return
        // Step 3: Find first preceding sibling not in nodes
        // Step 4: Convert nodes into a node (see ParentNode mixin helper)
        // Step 5: Determine insertion point
        // Step 6: Call pre-insert (from mutation.zig)
        @panic("ChildNode.before() not yet implemented");
    }
    /// DOM §4.3.4 - ChildNode.after()
    /// Inserts nodes just after this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. Pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_after(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.4 after() algorithm
        // Step 1: Get parent
        // Step 2: If parent is null, return
        // Step 3: Find first following sibling not in nodes
        // Step 4: Convert nodes into a node (see ParentNode mixin helper)
        // Step 5: Call pre-insert (from mutation.zig)
        @panic("ChildNode.after() not yet implemented");
    }
    /// DOM §4.3.4 - ChildNode.replaceWith()
    /// Replaces this node with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If this's parent is parent, replace this with node within parent.
    /// 6. Otherwise, pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_replaceWith(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.4 replaceWith() algorithm
        // Step 1: Get parent
        // Step 2: If parent is null, return
        // Step 3: Find first following sibling not in nodes
        // Step 4: Convert nodes into a node (see ParentNode mixin helper)
        // Step 5: If this's parent is still parent, call replace (from mutation.zig)
        // Step 6: Otherwise call pre-insert (from mutation.zig)
        @panic("ChildNode.replaceWith() not yet implemented");
    }
    /// DOM §4.3.4 - ChildNode.remove()
    /// Removes this node from its parent.
    /// 
    /// Steps:
    /// 1. If this's parent is null, then return.
    /// 2. Remove this.
    /// (Included from ChildNode mixin)
    pub fn call_remove(self: anytype) !void {
        _ = self;
        // TODO: Implement DOM §4.3.4 remove() algorithm
        // Step 1: If parent is null, return
        // Step 2: Call remove (from mutation.zig)
        @panic("ChildNode.remove() not yet implemented");
    }
    // ========================================================================
    // Methods from NonDocumentTypeChildNode mixin
    // ========================================================================

    /// DOM §4.3.3 - NonDocumentTypeChildNode.previousElementSibling
    /// Returns the first preceding sibling that is an element; otherwise null.
    /// 
    /// The previousElementSibling getter steps are to return the first preceding
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn previousElementSibling(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        var i: usize = parent.child_nodes.items.len;
        while (i > 0) {
            i -= 1;
            const sibling = parent.child_nodes.items[i];

            if (sibling == @as(*NodeType, @ptrCast(self))) {
                found_self = true;
                continue;
            }

            // Only look at siblings before us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    }
    /// DOM §4.3.3 - NonDocumentTypeChildNode.nextElementSibling
    /// Returns the first following sibling that is an element; otherwise null.
    /// 
    /// The nextElementSibling getter steps are to return the first following
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn nextElementSibling(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        for (parent.child_nodes.items) |sibling| {
            if (sibling == @as(*NodeType, @ptrCast(self))) {
                found_self = true;
                continue;
            }

            // Only look at siblings after us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    }
    // ========================================================================
    // CharacterData methods
    // ========================================================================

    /// DOM §4.11 - data getter
    /// Returns this's data.
    pub fn get_data(self: *const CharacterData) []const u8 {
        return self.data;
    }
    /// DOM §4.11 - data setter
    /// Replace data with node this, offset 0, count this's length, and data new value.
    pub fn set_data(self: *CharacterData, new_value: []const u8) !void {
        try self.replaceData(0, @intCast(self.data.len), new_value);
    }
    /// DOM §4.11 - length getter
    /// Returns this's length (number of code units).
    pub fn get_length(self: *const CharacterData) u32 {
        return @intCast(self.data.len);
    }
    /// DOM §4.11 - substringData(offset, count)
    /// Returns a substring of this's data.
    /// 
    /// Steps:
    /// 1. Let length be node's length.
    /// 2. If offset is greater than length, then throw an "IndexSizeError" DOMException.
    /// 3. If offset plus count is greater than length, return code units from offset to end.
    /// 4. Return code units from offset to offset+count.
    pub fn call_substringData(self: *const CharacterData, offset: u32, count: u32) ![]const u8 {
        const length: u32 = @intCast(self.data.len);

        // Step 2: Check bounds
        if (offset > length) {
            return error.IndexSizeError;
        }

        // Step 3: Handle overflow
        if (offset + count > length) {
            return self.data[offset..];
        }

        // Step 4: Return substring
        return self.data[offset .. offset + count];
    }
    /// DOM §4.11 - appendData(data)
    /// Appends data to this's data.
    /// 
    /// Steps: Replace data with node this, offset this's length, count 0, and data.
    pub fn call_appendData(self: *CharacterData, data: []const u8) !void {
        try self.replaceData(@intCast(self.data.len), 0, data);
    }
    /// DOM §4.11 - insertData(offset, data)
    /// Inserts data at the given offset.
    /// 
    /// Steps: Replace data with node this, offset, count 0, and data.
    pub fn call_insertData(self: *CharacterData, offset: u32, data: []const u8) !void {
        try self.replaceData(offset, 0, data);
    }
    /// DOM §4.11 - deleteData(offset, count)
    /// Deletes count code units starting at offset.
    /// 
    /// Steps: Replace data with node this, offset, count, and empty string.
    pub fn call_deleteData(self: *CharacterData, offset: u32, count: u32) !void {
        try self.replaceData(offset, count, "");
    }
    /// DOM §4.11 - replaceData(offset, count, data)
    /// Replaces count code units at offset with data.
    /// 
    /// Steps (simplified - full spec includes range and mutation handling):
    /// 1. Let length be node's length.
    /// 2. If offset is greater than length, throw "IndexSizeError".
    /// 3. If offset + count > length, set count to length - offset.
    /// 4-12. [Mutation records, ranges, and parent notification skipped for now]
    /// 5. Insert data into node's data after offset code units.
    /// 6-7. Remove count code units starting from offset + data's length.
    pub fn call_replaceData(self: *CharacterData, offset: u32, count: u32, data: []const u8) !void {
        try self.replaceData(offset, count, data);
    }
    /// Internal replace data implementation
    fn replaceData(self: *CharacterData, offset: u32, count_param: u32, data: []const u8) !void {
        const length: u32 = @intCast(self.data.len);
        var count = count_param;

        // Step 2: Check bounds
        if (offset > length) {
            return error.IndexSizeError;
        }

        // Step 3: Clamp count
        if (offset + count > length) {
            count = length - offset;
        }

        // TODO: Step 4 - Queue mutation record (requires mutation observers)

        // Steps 5-7: Build new data string
        const new_len = length - count + @as(u32, @intCast(data.len));
        const new_data = try self.allocator.alloc(u8, new_len);

        // Copy before offset
        @memcpy(new_data[0..offset], self.data[0..offset]);

        // Copy new data
        @memcpy(new_data[offset .. offset + data.len], data);

        // Copy after deleted region
        const after_start = offset + count;
        if (after_start < length) {
            @memcpy(new_data[offset + data.len ..], self.data[after_start..]);
        }

        // Replace old data
        self.allocator.free(self.data);
        self.data = new_data;

        // TODO: Steps 8-11 - Update ranges (requires Range implementation)
        // TODO: Step 12 - Run children changed steps for parent
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "CharacterData",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

