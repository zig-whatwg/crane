// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Text interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-text

const std = @import("std");
const webidl = @import("webidl");
pub const CharacterData = @import("character_data").CharacterData;
pub const dom_types = @import("dom_types");
pub const Element = @import("element").Element;

const Allocator = std.mem.Allocator;
/// DOM Spec: interface Text : CharacterData
/// Text extends CharacterData (fields/methods inherited)
/// Text must EXPLICITLY include parent mixins (codegen doesn't inherit them)
/// CharacterData includes: ChildNode, NonDocumentTypeChildNode
/// Text also includes: Slottable
const ChildNode = @import("child_node").ChildNode;
const NonDocumentTypeChildNode = @import("non_document_type_child_node").NonDocumentTypeChildNode;
const Slottable = @import("slottable").Slottable;
pub const Text = struct {
    // ========================================================================
    // Fields from Slottable mixin
    // ========================================================================
    /// Slottable name (from "slot" attribute)
    slottable_name: []const u8 = "",
    /// Currently assigned slot (null if not assigned)
    /// TODO: Implement when HTMLSlotElement is available
    assigned_slot: ?*anyopaque = null,
    /// Manual slot assignment (for manual slot assignment mode)
    /// TODO: Implement when HTMLSlotElement is available
    /// Should use weak reference per spec
    manual_slot_assignment: ?*anyopaque = null,

    // ========================================================================
    // Text fields
    // ========================================================================
    allocator: Allocator,

    pub const includes = .{ ChildNode, NonDocumentTypeChildNode, Slottable }; // From parent CharacterData + Slottable

    pub fn init(allocator: Allocator) !Text {
        return .{
            .allocator = allocator,
            // TODO: Initialize CharacterData parent fields (will be added by codegen)
        };
    }
    pub fn deinit(self: *Text) void {
        _ = self;
        // NOTE: Parent CharacterData cleanup will be handled by codegen
        // TODO: Call parent CharacterData deinit (will be added by codegen)
    }


    // ========================================================================
    // Methods from ChildNode mixin
    // ========================================================================

    /// DOM §4.3.4 - ChildNode.before()
    /// Inserts nodes just before this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If viablePreviousSibling is null, then set it to parent's first child; otherwise to viablePreviousSibling's next sibling.
    /// 6. Pre-insert node into parent before viablePreviousSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn before(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.4 before() algorithm
        // Step 1: Get parent
        // Step 2: If parent is null, return
        // Step 3: Find first preceding sibling not in nodes
        // Step 4: Convert nodes into a node (see ParentNode mixin helper)
        // Step 5: Determine insertion point
        // Step 6: Call pre-insert (from mutation.zig)
        @panic("ChildNode.before() not yet implemented");
    }
    /// DOM §4.3.4 - ChildNode.after()
    /// Inserts nodes just after this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. Pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn after(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.4 after() algorithm
        // Step 1: Get parent
        // Step 2: If parent is null, return
        // Step 3: Find first following sibling not in nodes
        // Step 4: Convert nodes into a node (see ParentNode mixin helper)
        // Step 5: Call pre-insert (from mutation.zig)
        @panic("ChildNode.after() not yet implemented");
    }
    /// DOM §4.3.4 - ChildNode.replaceWith()
    /// Replaces this node with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If this's parent is parent, replace this with node within parent.
    /// 6. Otherwise, pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn replaceWith(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        _ = self;
        _ = nodes;
        // TODO: Implement DOM §4.3.4 replaceWith() algorithm
        // Step 1: Get parent
        // Step 2: If parent is null, return
        // Step 3: Find first following sibling not in nodes
        // Step 4: Convert nodes into a node (see ParentNode mixin helper)
        // Step 5: If this's parent is still parent, call replace (from mutation.zig)
        // Step 6: Otherwise call pre-insert (from mutation.zig)
        @panic("ChildNode.replaceWith() not yet implemented");
    }
    /// DOM §4.3.4 - ChildNode.remove()
    /// Removes this node from its parent.
    /// 
    /// Steps:
    /// 1. If this's parent is null, then return.
    /// 2. Remove this.
    /// (Included from ChildNode mixin)
    pub fn remove(self: anytype) !void {
        _ = self;
        // TODO: Implement DOM §4.3.4 remove() algorithm
        // Step 1: If parent is null, return
        // Step 2: Call remove (from mutation.zig)
        @panic("ChildNode.remove() not yet implemented");
    }
    // ========================================================================
    // Methods from NonDocumentTypeChildNode mixin
    // ========================================================================

    /// DOM §4.3.3 - NonDocumentTypeChildNode.previousElementSibling
    /// Returns the first preceding sibling that is an element; otherwise null.
    /// 
    /// The previousElementSibling getter steps are to return the first preceding
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn previousElementSibling(self: anytype) ?*Element {
        _ = self;
        // TODO: Implement DOM §4.3.3 previousElementSibling getter
        // 1. Get this node's previous sibling
        // 2. While sibling exists:
        //    - If sibling is an Element, return it
        //    - Move to previous sibling
        // 3. Return null if no element sibling found
        @panic("NonDocumentTypeChildNode.previousElementSibling() not yet implemented");
    }
    /// DOM §4.3.3 - NonDocumentTypeChildNode.nextElementSibling
    /// Returns the first following sibling that is an element; otherwise null.
    /// 
    /// The nextElementSibling getter steps are to return the first following
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn nextElementSibling(self: anytype) ?*Element {
        _ = self;
        // TODO: Implement DOM §4.3.3 nextElementSibling getter
        // 1. Get this node's next sibling
        // 2. While sibling exists:
        //    - If sibling is an Element, return it
        //    - Move to next sibling
        // 3. Return null if no element sibling found
        @panic("NonDocumentTypeChildNode.nextElementSibling() not yet implemented");
    }
    // ========================================================================
    // Methods from Slottable mixin
    // ========================================================================

    /// DOM §4.3.7 - Slottable.assignedSlot
    /// 
    /// Returns the slot element this slottable is assigned to, if any.
    /// Returns null if not assigned or if the shadow root is closed.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-slottable-assignedslot
    /// (Included from Slottable mixin)
    pub fn get_assignedSlot(self: *const @This()) ?*anyopaque {
        // The assignedSlot getter steps are to return the result of
        // find a slot given this and true (open flag)

        // TODO: Implement findSlot algorithm from shadow_dom_algorithms
        // For now, return the assigned slot if it exists
        // The "open" parameter means we only return slots in open shadow roots

        _ = self;
        return null; // TODO: Implement when slot algorithms are available
    }

    // ========================================================================
    // Internal Methods
    // ========================================================================

    /// Get the slottable name
    pub fn getSlottableName(self: *const @This()) []const u8 {
        return self.slottable_name;
    }
    /// Set the slottable name
    /// (Included from Slottable mixin)
    pub fn setSlottableName(self: *@This(), name: []const u8) void {
        self.slottable_name = name;
    }
    /// Check if this slottable is assigned
    /// (Included from Slottable mixin)
    pub fn isAssigned(self: *const @This()) bool {
        return self.assigned_slot != null;
    }
    /// Set the assigned slot
    /// (Included from Slottable mixin)
    pub fn setAssignedSlot(self: *@This(), slot: ?*anyopaque) void {
        self.assigned_slot = slot;
    }
    /// Set the manual slot assignment
    /// (Included from Slottable mixin)
    pub fn setManualSlotAssignment(self: *@This(), slot: ?*anyopaque) void {
        self.manual_slot_assignment = slot;
    }
    // ========================================================================
    // Text methods
    // ========================================================================

    /// DOM §4.12 - splitText(offset)
    /// Splits this text node at the given offset and returns the remainder as a new Text node.
    /// 
    /// Steps:
    /// 1. Let length be node's length.
    /// 2. If offset is greater than length, throw "IndexSizeError".
    /// 3. Let count be length minus offset.
    /// 4. Let new data be the result of substringing data with node, offset, and count.
    /// 5. Let new node be a new Text node with same node document. Set new node's data to new data.
    /// 6. If parent is not null:
    /// - Insert new node into parent before node's next sibling
    /// - Update ranges (TODO)
    /// 7. Replace data with node, offset, count, and empty string.
    /// 8. Return new node.
    pub fn call_splitText(self: *Text, offset: u32) !*Text {
        const length = self.get_length();

        // Step 2: Check bounds
        if (offset > length) {
            return error.IndexSizeError;
        }

        // Step 3: Calculate count
        const count = length - offset;

        // Step 4: Get new data substring
        const new_data = try self.call_substringData(offset, count);

        // Step 5: Create new Text node
        const new_node = try self.allocator.create(Text);
        new_node.* = try Text.init(self.allocator);
        // Set the data by allocating a copy
        self.allocator.free(new_node.data);
        new_node.data = try self.allocator.dupe(u8, new_data);

        // Step 6: Parent handling (simplified - full spec requires tree mutation)
        // TODO: Insert new node into parent before node's next sibling
        // TODO: Update ranges

        // Step 7: Remove the split portion from this node
        try self.call_deleteData(offset, count);

        // Step 8: Return new node
        return new_node;
    }
    /// DOM §4.12 - wholeText getter
    /// Returns the concatenation of the data of all contiguous Text nodes.
    /// 
    /// Steps: Return the concatenation of the data of the contiguous Text nodes of this, in tree order.
    pub fn get_wholeText(self: *const Text) ![]const u8 {
        // Simplified implementation - just return this node's data
        // Full implementation would need to:
        // 1. Find all contiguous Text node siblings (previous and next)
        // 2. Concatenate their data in tree order
        //
        // For now, without full tree implementation, just return own data
        // TODO: Implement contiguous Text node traversal
        return self.get_data();
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Text",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

