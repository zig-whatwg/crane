// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Element interface per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-element
//! Section: 4.8 "Interface Element"
//!
//! Element is the base interface for all element nodes in the DOM.
//! It represents an HTML or XML element and provides attribute manipulation
//! and query capabilities.
//!
//! Status: **Foundation only** - Core implementation in next phase (whatwg-zio)

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

// Import Node from generated interface
const Node = @import("node").Node;

/// Attribute representation
///
/// Per spec §4.8: "Attributes have a namespace (null or a non-empty string),
/// namespace prefix (null or a non-empty string), local name (a non-empty string),
/// value (a string), and element (null or an element)."
///
/// For now, we use a simple struct. When Attr interface (whatwg-74l) is implemented,
/// this will be replaced with *Attr.
pub const Attribute = struct {
    /// Attribute namespace (null or non-empty string)
    namespace: ?[]const u8,

    /// Namespace prefix (null or non-empty string)
    prefix: ?[]const u8,

    /// Local name (non-empty string)
    localName: []const u8,

    /// Attribute value (string)
    value: []const u8,

    /// Allocator for memory management
    allocator: std.mem.Allocator,

    /// Get qualified name (prefix:localName or just localName)
    pub fn qualifiedName(self: *const Attribute) []const u8 {
        // Per spec: qualified name is local name if prefix is null;
        // otherwise prefix + ":" + localName
        // For now we return localName (TODO: allocate qualified name when needed)
        return self.localName;
    }

    pub fn deinit(self: *Attribute) void {
        self.allocator.free(self.localName);
        self.allocator.free(self.value);
        if (self.namespace) |ns| self.allocator.free(ns);
        if (self.prefix) |pfx| self.allocator.free(pfx);
    }
};
/// Element WebIDL interface
/// 
/// **Foundation implementation per WHATWG DOM Standard §4.8**
/// Status: **Core attributes complete** ✅
/// 
/// Phase 2.1.2 (whatwg-6so) - Attribute manipulation methods in progress
/// 
/// Complete IDL:
/// ```webidl
/// [Exposed=Window]
/// interface Element : Node {
/// readonly attribute DOMString? namespaceURI;
/// readonly attribute DOMString? prefix;
/// readonly attribute DOMString localName;
/// readonly attribute DOMString tagName;
/// 
/// [CEReactions] attribute DOMString id;
/// [CEReactions] attribute DOMString className;
/// [SameObject, PutForwards=value] readonly attribute DOMTokenList classList;
/// [CEReactions, Unscopable] attribute DOMString slot;
/// 
/// boolean hasAttributes();
/// [SameObject] readonly attribute NamedNodeMap attributes;
/// sequence<DOMString> getAttributeNames();
/// DOMString? getAttribute(DOMString qualifiedName);
/// DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
/// [CEReactions] undefined setAttribute(DOMString qualifiedName, DOMString value);
/// [CEReactions] undefined setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
/// [CEReactions] undefined removeAttribute(DOMString qualifiedName);
/// [CEReactions] undefined removeAttributeNS(DOMString? namespace, DOMString localName);
/// [CEReactions] boolean toggleAttribute(DOMString qualifiedName, optional boolean force);
/// boolean hasAttribute(DOMString qualifiedName);
/// boolean hasAttributeNS(DOMString? namespace, DOMString localName);
/// 
/// Attr? getAttributeNode(DOMString qualifiedName);
/// Attr? getAttributeNodeNS(DOMString? namespace, DOMString localName);
/// [CEReactions] Attr? setAttributeNode(Attr attr);
/// [CEReactions] Attr? setAttributeNodeNS(Attr attr);
/// [CEReactions] Attr removeAttributeNode(Attr attr);
/// 
/// ShadowRoot attachShadow(ShadowRootInit init);
/// readonly attribute ShadowRoot? shadowRoot;
/// 
/// Element? closest(DOMString selectors);
/// boolean matches(DOMString selectors);
/// boolean webkitMatchesSelector(DOMString selectors); // legacy alias of .matches
/// 
/// HTMLCollection getElementsByTagName(DOMString qualifiedName);
/// HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
/// HTMLCollection getElementsByClassName(DOMString classNames);
/// 
/// [CEReactions] Element? insertAdjacentElement(DOMString where, Element element); // legacy
/// undefined insertAdjacentText(DOMString where, DOMString data); // legacy
/// };
/// ```
pub const Element = struct {
    /// Allocator for memory management
    allocator: std.mem.Allocator,
    /// Local name (e.g., "div", "span", "p")
    /// Per spec: A non-empty string. Immutable after creation.
    localName: []const u8,
    /// Namespace (e.g., "http://www.w3.org/1999/xhtml", "http://www.w3.org/2000/svg")
    /// Per spec: Null or a non-empty string. Immutable after creation.
    namespace: ?[]const u8,
    /// Namespace prefix (e.g., "html", "svg")
    /// Per spec: Null or a non-empty string. Immutable after creation.
    namespacePrefix: ?[]const u8,
    /// Element ID (corresponds to "id" attribute)
    /// Per spec §4.8: The id attribute reflects "id"
    id: ?[]const u8,
    /// Class name (corresponds to "class" attribute)
    /// Per spec §4.8: The className attribute reflects "class"
    className: ?[]const u8,
    /// Attribute list
    /// Per spec §4.8: Elements have an associated attribute list (a list of attributes)
    attributes: infra.List(Attribute),

    /// Initialize a new Element node
    /// 
    /// Spec: Elements are created through Document.createElement() or similar
    /// methods. This direct constructor is for internal use and testing.
    /// 
    /// Per spec §4.8: Elements have namespace, namespacePrefix, localName,
    /// and these are initialized when an element is created.
    pub fn init(
        allocator: std.mem.Allocator,
        localName: []const u8,
        namespace: ?[]const u8,
        namespacePrefix: ?[]const u8,
    ) !Element {
        // Allocate copies of strings we need to own
        const localName_copy = try allocator.dupe(u8, localName);
        errdefer allocator.free(localName_copy);

        const namespace_copy = if (namespace) |ns|
            try allocator.dupe(u8, ns)
        else
            null;
        errdefer if (namespace_copy) |ns| allocator.free(ns);

        const prefix_copy = if (namespacePrefix) |prefix|
            try allocator.dupe(u8, prefix)
        else
            null;
        errdefer if (prefix_copy) |prefix| allocator.free(prefix);

        var element = Element{
            .allocator = allocator,
            .localName = localName_copy,
            .namespace = namespace_copy,
            .namespacePrefix = prefix_copy,
            .id = null,
            .className = null,
            .attributes = undefined,
        };

        // Initialize attributes list
        element.attributes = infra.List(Attribute).init(allocator);

        return element;
    }
    /// Clean up Element resources
    /// 
    /// Frees all owned memory including localName, namespace, namespacePrefix,
    /// id, className, and attributes.
    pub fn deinit(self: *Element) void {
        // Free owned strings
        self.allocator.free(self.localName);
        if (self.namespace) |ns| self.allocator.free(ns);
        if (self.namespacePrefix) |prefix| self.allocator.free(prefix);
        if (self.id) |id| self.allocator.free(id);
        if (self.className) |cn| self.allocator.free(cn);

        // Free attributes
        var i: usize = 0;
        while (i < self.attributes.size()) : (i += 1) {
            if (self.attributes.get(i)) |*attr| {
                var mut_attr = attr.*;
                mut_attr.deinit();
            }
        }
        self.attributes.deinit();
    }

    /// namespaceURI getter
    /// Spec: §4.8 - Returns the namespace
    /// IDL: readonly attribute DOMString? namespaceURI;
    /// 
    /// Note: DOMString is []const u16 per WebIDL, but we store UTF-8 internally
    /// for efficiency. When proper WebIDL conversions are implemented, this will
    /// convert UTF-8 to UTF-16.
    pub fn get_namespaceURI(self: *const Element) ?[]const u8 {
        return self.namespace;
    }
    /// prefix getter
    /// Spec: §4.8 - Returns the namespace prefix
    /// IDL: readonly attribute DOMString? prefix;
    pub fn get_prefix(self: *const Element) ?[]const u8 {
        return self.namespacePrefix;
    }
    /// localName getter
    /// Spec: §4.8 - Returns the local name
    /// IDL: readonly attribute DOMString localName;
    pub fn get_localName(self: *const Element) []const u8 {
        return self.localName;
    }
    /// tagName getter
    /// Spec: §4.8 - Returns the HTML-uppercased qualified name
    /// 
    /// Per spec: "The tagName getter steps are to return this's HTML-uppercased qualified name"
    /// 
    /// HTML-uppercased qualified name algorithm:
    /// 1. Let qualifiedName be this's qualified name
    /// 2. If this is in the HTML namespace and its node document is an HTML document,
    /// then set qualifiedName to qualifiedName in ASCII uppercase
    /// 3. Return qualifiedName
    /// 
    /// Qualified name: local name if namespace prefix is null; otherwise prefix:localName
    /// 
    /// Note: For now we don't have access to node document, so we can't check if it's HTML.
    /// We'll implement basic qualified name and upgrade later when Document is available.
    /// 
    /// IDL: readonly attribute DOMString tagName;
    pub fn get_tagName(self: *const Element) []const u8 {
        // TODO: Implement HTML-uppercasing when Document is available
        // TODO: Implement prefix:localName qualified name format
        // For now, just return localName
        return self.localName;
    }
    /// id getter
    /// Spec: §4.8 - The id attribute reflects "id"
    /// 
    /// Per spec: "IDL attributes that are defined to reflect a string name,
    /// must have these getter steps: Return the result of running get an
    /// attribute value given this and name."
    /// 
    /// get an attribute value returns empty string if attribute is null.
    /// 
    /// For now, we're storing id directly as a field. When attributes are
    /// implemented (whatwg-6so), this will query the attribute list.
    /// 
    /// IDL: [CEReactions] attribute DOMString id;
    pub fn get_id(self: *const Element) []const u8 {
        return self.id orelse "";
    }
    /// id setter
    /// Spec: §4.8 - The id attribute reflects "id"
    /// 
    /// Per spec: "IDL attributes that are defined to reflect a string name,
    /// must have these setter steps: Set an attribute value for this using
    /// name and the given value."
    /// 
    /// For now, we're storing id directly. When attributes are implemented,
    /// this will call set an attribute value.
    /// 
    /// IDL: [CEReactions] attribute DOMString id;
    pub fn set_id(self: *Element, value: []const u8) !void {
        // Free old value if it exists
        if (self.id) |old_id| {
            self.allocator.free(old_id);
        }

        // Store new value (empty string becomes null for efficiency)
        self.id = if (value.len > 0)
            try self.allocator.dupe(u8, value)
        else
            null;
    }
    /// className getter
    /// Spec: §4.8 - The className attribute reflects "class"
    /// 
    /// Per spec: "IDL attributes that are defined to reflect a string name,
    /// must have these getter steps: Return the result of running get an
    /// attribute value given this and name."
    /// 
    /// IDL: [CEReactions] attribute DOMString className;
    pub fn get_className(self: *const Element) []const u8 {
        return self.className orelse "";
    }
    /// className setter
    /// Spec: §4.8 - The className attribute reflects "class"
    /// 
    /// Per spec: "IDL attributes that are defined to reflect a string name,
    /// must have these setter steps: Set an attribute value for this using
    /// name and the given value."
    /// 
    /// IDL: [CEReactions] attribute DOMString className;
    pub fn set_className(self: *Element, value: []const u8) !void {
        // Free old value if it exists
        if (self.className) |old_class| {
            self.allocator.free(old_class);
        }

        // Store new value (empty string becomes null for efficiency)
        self.className = if (value.len > 0)
            try self.allocator.dupe(u8, value)
        else
            null;
    }
    /// Helper: Find attribute index by qualified name
    fn findAttributeByName(self: *const Element, qualified_name: []const u8) ?usize {
        var i: usize = 0;
        while (i < self.attributes.size()) : (i += 1) {
            if (self.attributes.get(i)) |attr| {
                if (std.mem.eql(u8, attr.qualifiedName(), qualified_name)) {
                    return i;
                }
            }
        }
        return null;
    }
    /// Helper: Find attribute index by namespace and local name
    fn findAttributeByNS(self: *const Element, namespace: ?[]const u8, localName: []const u8) ?usize {
        var i: usize = 0;
        while (i < self.attributes.size()) : (i += 1) {
            if (self.attributes.get(i)) |attr| {
                const attr_ns = attr.namespace;
                const ns_match = if (namespace == null and attr_ns == null)
                    true
                else if (namespace != null and attr_ns != null)
                    std.mem.eql(u8, namespace.?, attr_ns.?)
                else
                    false;

                if (ns_match and std.mem.eql(u8, attr.localName, localName)) {
                    return i;
                }
            }
        }
        return null;
    }
    /// hasAttribute(qualifiedName)
    /// 
    /// IDL: `boolean hasAttribute(DOMString qualifiedName);`
    /// 
    /// Spec §4.8: Returns true if element has an attribute whose qualified name
    /// is qualifiedName; otherwise false.
    pub fn call_hasAttribute(self: *const Element, qualified_name: webidl.DOMString) webidl.boolean {
        // TODO: Implement HTML lowercasing when Document is available
        return webidl.boolean{ .value = self.findAttributeByName(qualified_name) != null };
    }
    /// getAttribute(qualifiedName)
    /// 
    /// IDL: `DOMString? getAttribute(DOMString qualifiedName);`
    /// 
    /// Spec §4.8: Returns element's first attribute whose qualified name is
    /// qualifiedName, and null if there is no such attribute.
    pub fn call_getAttribute(self: *const Element, qualified_name: webidl.DOMString) ?webidl.DOMString {
        // TODO: Implement HTML lowercasing when Document is available
        if (self.findAttributeByName(qualified_name)) |idx| {
            if (self.attributes.get(idx)) |attr| {
                return attr.value;
            }
        }
        return null;
    }
    /// hasAttributeNS(namespace, localName)
    /// 
    /// IDL: `boolean hasAttributeNS(DOMString? namespace, DOMString localName);`
    /// 
    /// Spec §4.8: Returns true if element has an attribute whose namespace is
    /// namespace and local name is localName.
    pub fn call_hasAttributeNS(
        self: *const Element,
        namespace: ?webidl.DOMString,
        localName: webidl.DOMString,
    ) webidl.boolean {
        const ns = if (namespace) |n| (if (n.len == 0) null else n) else null;
        return webidl.boolean{ .value = self.findAttributeByNS(ns, localName) != null };
    }
    /// getAttributeNS(namespace, localName)
    /// 
    /// IDL: `DOMString? getAttributeNS(DOMString? namespace, DOMString localName);`
    /// 
    /// Spec §4.8: Returns element's attribute whose namespace is namespace and
    /// local name is localName, and null if there is no such attribute.
    pub fn call_getAttributeNS(
        self: *const Element,
        namespace: ?webidl.DOMString,
        localName: webidl.DOMString,
    ) ?webidl.DOMString {
        const ns = if (namespace) |n| (if (n.len == 0) null else n) else null;
        if (self.findAttributeByNS(ns, localName)) |idx| {
            if (self.attributes.get(idx)) |attr| {
                return attr.value;
            }
        }
        return null;
    }
    /// setAttribute(qualifiedName, value)
    /// 
    /// IDL: `[CEReactions] undefined setAttribute(DOMString qualifiedName, DOMString value);`
    /// 
    /// Spec §4.8: Sets the value of element's first attribute whose qualified name
    /// is qualifiedName to value.
    pub fn call_setAttribute(
        self: *Element,
        qualified_name: webidl.DOMString,
        value: webidl.DOMString,
    ) !void {
        // TODO: Validate qualifiedName (must not contain invalid characters)
        // TODO: Implement HTML lowercasing when Document is available

        // Find existing attribute
        if (self.findAttributeByName(qualified_name)) |idx| {
            if (self.attributes.get(idx)) |attr| {
                var mut_attr = attr;
                self.allocator.free(mut_attr.value);
                mut_attr.value = try self.allocator.dupe(u8, value);
                _ = try self.attributes.replace(idx, mut_attr);
                return;
            }
        }

        // Create new attribute
        const new_attr = Attribute{
            .namespace = null,
            .prefix = null,
            .localName = try self.allocator.dupe(u8, qualified_name),
            .value = try self.allocator.dupe(u8, value),
            .allocator = self.allocator,
        };
        try self.attributes.append(new_attr);
    }
    /// setAttributeNS(namespace, qualifiedName, value)
    /// 
    /// IDL: `[CEReactions] undefined setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);`
    /// 
    /// Spec §4.8: Sets the value of element's attribute whose namespace is namespace
    /// and local name is localName to value.
    pub fn call_setAttributeNS(
        self: *Element,
        namespace: ?webidl.DOMString,
        qualified_name: webidl.DOMString,
        value: webidl.DOMString,
    ) !void {
        const ns = if (namespace) |n| (if (n.len == 0) null else n) else null;
        const localName = qualified_name; // TODO: Parse qualified name properly
        const prefix: ?[]const u8 = null;

        // Find and update existing
        if (self.findAttributeByNS(ns, localName)) |idx| {
            if (self.attributes.get(idx)) |attr| {
                var mut_attr = attr;
                self.allocator.free(mut_attr.value);
                mut_attr.value = try self.allocator.dupe(u8, value);
                _ = try self.attributes.replace(idx, mut_attr);
                return;
            }
        }

        // Create new
        const new_attr = Attribute{
            .namespace = if (ns) |n| try self.allocator.dupe(u8, n) else null,
            .prefix = if (prefix) |p| try self.allocator.dupe(u8, p) else null,
            .localName = try self.allocator.dupe(u8, localName),
            .value = try self.allocator.dupe(u8, value),
            .allocator = self.allocator,
        };
        try self.attributes.append(new_attr);
    }
    /// removeAttribute(qualifiedName)
    /// 
    /// IDL: `[CEReactions] undefined removeAttribute(DOMString qualifiedName);`
    /// 
    /// Spec §4.8: Removes element's first attribute whose qualified name is qualifiedName.
    pub fn call_removeAttribute(self: *Element, qualified_name: webidl.DOMString) void {
        if (self.findAttributeByName(qualified_name)) |idx| {
            var removed = self.attributes.remove(idx) catch return;
            removed.deinit();
        }
    }
    /// removeAttributeNS(namespace, localName)
    /// 
    /// IDL: `[CEReactions] undefined removeAttributeNS(DOMString? namespace, DOMString localName);`
    /// 
    /// Spec §4.8: Removes element's attribute whose namespace is namespace and
    /// local name is localName.
    pub fn call_removeAttributeNS(
        self: *Element,
        namespace: ?webidl.DOMString,
        localName: webidl.DOMString,
    ) void {
        const ns = if (namespace) |n| (if (n.len == 0) null else n) else null;
        if (self.findAttributeByNS(ns, localName)) |idx| {
            var removed = self.attributes.remove(idx) catch return;
            removed.deinit();
        }
    }
    /// toggleAttribute(qualifiedName, force)
    /// 
    /// IDL: `[CEReactions] boolean toggleAttribute(DOMString qualifiedName, optional boolean force);`
    /// 
    /// Spec §4.8: If force is not given, "toggles" qualifiedName, removing it if
    /// present and adding it if not present. Returns true if qualifiedName is now
    /// present; otherwise false.
    pub fn call_toggleAttribute(
        self: *Element,
        qualified_name: webidl.DOMString,
        force: ?webidl.boolean,
    ) !webidl.boolean {
        if (self.findAttributeByName(qualified_name)) |idx| {
            // Exists - remove if force is null or false
            if (force == null or force.?.value == false) {
                var removed = try self.attributes.remove(idx);
                removed.deinit();
                return webidl.boolean{ .value = false };
            }
            return webidl.boolean{ .value = true };
        }

        // Doesn't exist - add if force is null or true
        if (force == null or force.?.value == true) {
            try self.attributes.append(.{
                .namespace = null,
                .prefix = null,
                .localName = try self.allocator.dupe(u8, qualified_name),
                .value = try self.allocator.dupe(u8, ""),
                .allocator = self.allocator,
            });
            return webidl.boolean{ .value = true };
        }

        return webidl.boolean{ .value = false };
    }
    /// getAttributeNames()
    /// 
    /// IDL: `sequence<DOMString> getAttributeNames();`
    /// 
    /// Spec §4.8: Returns the qualified names of all element's attributes.
    pub fn call_getAttributeNames(self: *const Element) ![]const webidl.DOMString {
        const count = self.attributes.size();
        var names = try self.allocator.alloc(webidl.DOMString, count);

        var i: usize = 0;
        while (i < count) : (i += 1) {
            if (self.attributes.get(i)) |attr| {
                names[i] = attr.qualifiedName();
            }
        }

        return names;
    }
};


// ============================================================================
// Tests
// ============================================================================

test "Element - create with local name only" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Verify local name
    const localName = element.get_localName();
    try std.testing.expectEqualStrings("div", localName);

    // Verify namespace is null
    try std.testing.expect(element.get_namespaceURI() == null);

    // Verify prefix is null
    try std.testing.expect(element.get_prefix() == null);
}

test "Element - create with namespace" {
    const allocator = std.testing.allocator;

    const html_ns = "http://www.w3.org/1999/xhtml";
    var element = try Element.init(allocator, "div", html_ns, null);
    defer element.deinit();

    // Verify namespace
    const ns = element.get_namespaceURI().?;
    try std.testing.expectEqualStrings(html_ns, ns);
}

test "Element - create with namespace and prefix" {
    const allocator = std.testing.allocator;

    const svg_ns = "http://www.w3.org/2000/svg";
    var element = try Element.init(allocator, "rect", svg_ns, "svg");
    defer element.deinit();

    // Verify all parts
    const localName = element.get_localName();
    try std.testing.expectEqualStrings("rect", localName);

    const ns = element.get_namespaceURI().?;
    try std.testing.expectEqualStrings(svg_ns, ns);

    const prefix = element.get_prefix().?;
    try std.testing.expectEqualStrings("svg", prefix);
}

test "Element - tagName returns local name" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "span", null, null);
    defer element.deinit();

    const tag_name = element.get_tagName();
    try std.testing.expectEqualStrings("span", tag_name);
}

test "Element - id getter returns empty string by default" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    const id = element.get_id();
    try std.testing.expectEqualStrings("", id);
}

test "Element - set and get id" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Set id
    try element.set_id("my-element");

    // Get id
    const id = element.get_id();
    try std.testing.expectEqualStrings("my-element", id);
}

test "Element - change id" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Set initial id
    try element.set_id("first");
    var id = element.get_id();
    try std.testing.expectEqualStrings("first", id);

    // Change id
    try element.set_id("second");
    id = element.get_id();
    try std.testing.expectEqualStrings("second", id);
}

test "Element - set id to empty string" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Set id
    try element.set_id("my-id");

    // Clear id by setting to empty string
    try element.set_id("");

    const id = element.get_id();
    try std.testing.expectEqualStrings("", id);
}

test "Element - className getter returns empty string by default" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    const className = element.get_className();
    try std.testing.expectEqualStrings("", className);
}

test "Element - set and get className" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Set class
    try element.set_className("container active");

    // Get class
    const className = element.get_className();
    try std.testing.expectEqualStrings("container active", className);
}

test "Element - change className" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Set initial class
    try element.set_className("first");
    var className = element.get_className();
    try std.testing.expectEqualStrings("first", className);

    // Change class
    try element.set_className("second third");
    className = element.get_className();
    try std.testing.expectEqualStrings("second third", className);
}

test "Element - set className to empty string" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Set class
    try element.set_className("my-class");

    // Clear class by setting to empty string
    try element.set_className("");

    const className = element.get_className();
    try std.testing.expectEqualStrings("", className);
}

test "Element - multiple attributes work together" {
    const allocator = std.testing.allocator;

    const html_ns = "http://www.w3.org/1999/xhtml";
    var element = try Element.init(allocator, "div", html_ns, null);
    defer element.deinit();

    // Set id and class
    try element.set_id("main-container");
    try element.set_className("container large");

    // Verify all attributes
    const localName = element.get_localName();
    try std.testing.expectEqualStrings("div", localName);

    const ns = element.get_namespaceURI().?;
    try std.testing.expectEqualStrings(html_ns, ns);

    const id = element.get_id();
    try std.testing.expectEqualStrings("main-container", id);

    const className = element.get_className();
    try std.testing.expectEqualStrings("container large", className);
}

test "Element - no memory leaks with allocator changes" {
    const allocator = std.testing.allocator;

    var element = try Element.init(allocator, "div", null, null);
    defer element.deinit();

    // Set and change id multiple times
    try element.set_id("id1");
    try element.set_id("id2");
    try element.set_id("id3");

    // Set and change className multiple times
    try element.set_className("class1");
    try element.set_className("class2");
    try element.set_className("class3");

    // std.testing.allocator will detect leaks
}
