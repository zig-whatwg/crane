// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const Node = @import("node").Node;
const NodeList = @import("node_list").NodeList;
const infra = @import("infra");
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง7.2 - MutationRecord interface
///
/// MutationRecord objects represent individual DOM mutations.
/// They are created by the MutationObserver API and contain information
/// about what changed in the tree.

pub const MutationRecord = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    mutation_type: []const u8,
    target: *Node,
    added_nodes: *NodeList,
    removed_nodes: *NodeList,
    previous_sibling: ?*Node,
    next_sibling: ?*Node,
    attribute_name: ?[]const u8,
    attribute_namespace: ?[]const u8,
    old_value: ?[]const u8,

    // ========================================================================
    // Constants
    // ========================================================================

    pub const TYPE_ATTRIBUTES: []const u8 = "attributes";
    pub const TYPE_CHARACTER_DATA: []const u8 = "characterData";
    pub const TYPE_CHILD_LIST: []const u8 = "childList";

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: Allocator,
        mutation_type: []const u8,
        target: *Node,
        added_nodes: *NodeList,
        removed_nodes: *NodeList,
        previous_sibling: ?*Node,
        next_sibling: ?*Node,
        attribute_name: ?[]const u8,
        attribute_namespace: ?[]const u8,
        old_value: ?[]const u8,
    ) !MutationRecord {

        return .{
            .allocator = allocator,
            .mutation_type = mutation_type,
            .target = target,
            .added_nodes = added_nodes,
            .removed_nodes = removed_nodes,
            .previous_sibling = previous_sibling,
            .next_sibling = next_sibling,
            .attribute_name = attribute_name,
            .attribute_namespace = attribute_namespace,
            .old_value = old_value,
        };
    
    }

    pub fn deinit(self: *MutationRecord) void {

        _ = self;
        // NodeLists and Nodes are owned elsewhere, we don't free them
        // Strings (mutation_type, attribute_name, etc.) may need freeing
        // depending on how they're allocated - TBD based on usage patterns
    
    }

    pub fn get_type(self: *const MutationRecord) []const u8 {

        return self.mutation_type;
    
    }

    pub fn get_target(self: *const MutationRecord) *Node {

        return self.target;
    
    }

    pub fn get_addedNodes(self: *const MutationRecord) *NodeList {

        return self.added_nodes;
    
    }

    pub fn get_removedNodes(self: *const MutationRecord) *NodeList {

        return self.removed_nodes;
    
    }

    pub fn get_previousSibling(self: *const MutationRecord) ?*Node {

        return self.previous_sibling;
    
    }

    pub fn get_nextSibling(self: *const MutationRecord) ?*Node {

        return self.next_sibling;
    
    }

    pub fn get_attributeName(self: *const MutationRecord) ?[]const u8 {

        return self.attribute_name;
    
    }

    pub fn get_attributeNamespace(self: *const MutationRecord) ?[]const u8 {

        return self.attribute_namespace;
    
    }

    pub fn get_oldValue(self: *const MutationRecord) ?[]const u8 {

        return self.old_value;
    
    }

};


