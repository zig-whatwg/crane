// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortSignal = @import("abort_signal").AbortSignal;
const Allocator = std.mem.Allocator;
const Attr = @import("attr").Attr;
const CharacterData = @import("character_data").CharacterData;
const ChildNode = @import("child_node").ChildNode;
pub const DOMTokenList = @import("d_o_m_token_list").DOMTokenList;
const Document = @import("document").Document;
const Event = @import("event").Event;
pub const EventListener = @import("event_target").EventListener;
const EventTarget = @import("event_target").EventTarget;
pub const GetRootNodeOptions = @import("get_root_node_options").GetRootNodeOptions;
const HTMLCollection = @import("html_collection").HTMLCollection;
const Node = @import("node").Node;
const NodeList = @import("node_list").NodeList;
const NonDocumentTypeChildNode = @import("non_document_type_child_node").NonDocumentTypeChildNode;
const ParentNode = @import("parent_node").ParentNode;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const ShadowRoot = @import("shadow_root").ShadowRoot;
const ShadowRootInit = @import("shadow_root_init").ShadowRootInit;
const Slottable = @import("slottable").Slottable;
const Text = @import("text").Text;
const TransientRegisteredObserver = @import("registered_observer").TransientRegisteredObserver;
const dom = @import("dom");
const dom_types = @import("dom_types");
const infra = @import("infra");
const std = @import("std");
const webidl = @import("webidl");


/// Custom element state per HTML spec
/// Spec: https://html.spec.whatwg.org/#custom-element-state
pub const CustomElementState = enum {
    undefined,
    failed,
    uncustomized,
    precustomized,
    custom,
};

/// Element WebIDL interface
/// DOM Spec: interface Element : Node

/// Compare two callbacks for equality (from EventTarget)
pub fn callbackEquals(a: ?webidl.JSValue, b: ?webidl.JSValue) bool {
    if (a == null and b == null) return true;
    if (a == null or b == null) return false;
    const a_val = a.?;
    const b_val = b.?;
    if (@as(std.meta.Tag(webidl.JSValue), a_val) != @as(std.meta.Tag(webidl.JSValue), b_val)) {
        return false;
    }
    return switch (a_val) {
        .undefined, .null => true,
        .boolean => |a_bool| a_bool == b_val.boolean,
        .number => |a_num| a_num == b_val.number,
        .string => |a_str| std.mem.eql(u8, a_str, b_val.string),
        .object => |a_obj| @intFromPtr(&a_obj) == @intFromPtr(&b_val.object),
        else => false,
    };
}

/// Element WebIDL interface
/// DOM Spec: interface Element : Node
pub const Element = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    /// DOM §2.7 - Each EventTarget has an associated event listener list
    /// (a list of zero or more event listeners). It is initially the empty list.
    /// 
    /// OPTIMIZATION: Lazy allocation - most EventTargets never have listeners attached.
    /// This saves ~40% memory on typical DOM trees where 90% of nodes have no listeners.
    /// Pattern borrowed from WebKit's NodeRareData and Chromium's NodeRareData.
    event_listener_list: ?*infra.List(EventListener),
    node_type: u16,
    node_name: []const u8,
    parent_node: ?*Node,
    child_nodes: infra.List(*Node),
    owner_document: ?*Document,
    /// DOM §7.1 - Registered observer list
    /// List of registered mutation observers watching this node
    registered_observers: infra.List(@import("registered_observer").RegisteredObserver),
    /// Cloning steps hook - optional function called during node cloning
    /// Signature: fn(node: *Node, copy: *Node, subtree: bool) !void
    /// Specifications (like HTML) can define cloning steps for specific node types
    cloning_steps_hook: ?*const fn (node: *Node, copy: *Node, subtree: bool) anyerror!void,
    /// [SameObject] cache for childNodes NodeList
    /// Per WebIDL [SameObject], the same NodeList object is returned each time
    /// This is a live view of the child_nodes list
    cached_child_nodes: ?*@import("node_list").NodeList,
    /// Slottable name (from "slot" attribute)
    slottable_name: []const u8,
    /// Currently assigned slot (null if not assigned)
    /// TODO: Implement when HTMLSlotElement is available
    assigned_slot: ?*anyopaque,
    /// Manual slot assignment (for manual slot assignment mode)
    /// TODO: Implement when HTMLSlotElement is available
    /// Should use weak reference per spec
    manual_slot_assignment: ?*anyopaque,
    allocator: Allocator,
    tag_name: []const u8,
    namespace_uri: ?[]const u8,
    prefix: ?[]const u8,
    local_name: []const u8,
    attributes: infra.List(Attr),
    /// Shadow root attached to this element (null if not a shadow host)
    shadow_root: ?*ShadowRoot,
    /// Custom element state per HTML spec
    /// Spec: https://html.spec.whatwg.org/#custom-element-state
    custom_element_state: CustomElementState,
    /// "is" value for customized built-in elements
    /// Spec: https://html.spec.whatwg.org/#concept-element-is-value
    is_value: ?[]const u8,
    /// Cached DOMTokenList for classList ([SameObject])
    cached_class_list: ?*@import("dom_token_list").DOMTokenList,
    /// Cached NamedNodeMap for attributes ([SameObject])
    /// Spec: https://dom.spec.whatwg.org/#ref-for-dom-element-attributes
    cached_attributes: ?*@import("named_node_map").NamedNodeMap,

    // ========================================================================
    // Constants
    // ========================================================================

    // Node type constants (inherited)
    pub const ELEMENT_NODE: u16 = Node.ELEMENT_NODE;
    pub const ATTRIBUTE_NODE: u16 = Node.ATTRIBUTE_NODE;
    pub const TEXT_NODE: u16 = Node.TEXT_NODE;
    pub const CDATA_SECTION_NODE: u16 = Node.CDATA_SECTION_NODE;
    pub const PROCESSING_INSTRUCTION_NODE: u16 = Node.PROCESSING_INSTRUCTION_NODE;
    pub const COMMENT_NODE: u16 = Node.COMMENT_NODE;
    pub const DOCUMENT_NODE: u16 = Node.DOCUMENT_NODE;
    pub const DOCUMENT_TYPE_NODE: u16 = Node.DOCUMENT_TYPE_NODE;
    pub const DOCUMENT_FRAGMENT_NODE: u16 = Node.DOCUMENT_FRAGMENT_NODE;

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "Element",
        .kind = .interface,
    };

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: Allocator, tag_name: []const u8) !Element {

        // NOTE: Parent Node fields will be flattened by codegen
        // NOTE: Mixin fields (Slottable) are also flattened by codegen
        return .{
            // Inherited from EventTarget (via Node)
            .event_listener_list = null,
            // Inherited from Node
            .node_type = 1, // ELEMENT_NODE
            .node_name = tag_name,
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
            .cloning_steps_hook = null,
            .cached_child_nodes = null,
            // Slottable mixin fields
            .slottable_name = "",
            .assigned_slot = null,
            .manual_slot_assignment = null,
            // Element own fields
            .allocator = allocator,
            .tag_name = tag_name,
            .namespace_uri = null,
            .prefix = null,
            .local_name = tag_name,
            .attributes = infra.List(Attr).init(allocator),
            .shadow_root = null,
            .custom_element_state = .undefined,
            .is_value = null,
            .cached_class_list = null,
            .cached_attributes = null,
        };
    
    }

    pub fn deinit(self: *Element) void {

        // Clean up Node fields (inherited)
        self.child_nodes.deinit();
        self.registered_observers.deinit();
        if (self.cached_child_nodes) |list| {
            list.deinit();
            self.allocator.destroy(list);
        }

        // Clean up Element fields
        self.attributes.deinit();

        // Free namespace_uri if allocated
        if (self.namespace_uri) |ns| {
            self.allocator.free(ns);
        }

        // Free prefix if allocated
        if (self.prefix) |p| {
            self.allocator.free(p);
        }

        // Free cached classList
        if (self.cached_class_list) |list| {
            list.deinit();
            self.allocator.destroy(list);
        }

        // Free cached attributes NamedNodeMap
        if (self.cached_attributes) |attrs| {
            attrs.deinit();
            self.allocator.destroy(attrs);
        }
    
    }

    /// Append an attribute - DOM §4.10.3
    /// Spec: https://dom.spec.whatwg.org/#concept-element-attributes-append
    /// 
    /// To append an attribute to element:
    /// 1. Append attribute to element's attribute list
    /// 2. Set attribute's element to element
    /// 3. Set attribute's node document to element's node document
    /// 4. Handle attribute changes for attribute with element, null, and attribute's value
    fn appendAttribute(self: *Element, attribute: *Attr) !void {

        // Step 1: Append to attribute list
        try self.attributes.append(attribute.*);

        // Get pointer to the appended attribute
        const appended_attr = &self.attributes.toSlice()[self.attributes.len - 1];

        // Step 2: Set attribute's element
        appended_attr.owner_element = self;

        // Step 3: Set attribute's node document
        // TODO: Set node_document when Attr has that field

        // Step 4: Handle attribute changes
        try Attr.handleAttributeChanges(appended_attr, self, null, appended_attr.value);
    
    }

    /// Remove an attribute - DOM §4.10.3
    /// Spec: https://dom.spec.whatwg.org/#concept-element-attributes-remove
    /// 
    /// To remove an attribute:
    /// 1. Let element be attribute's element
    /// 2. Remove attribute from element's attribute list
    /// 3. Set attribute's element to null
    /// 4. Handle attribute changes for attribute with element, attribute's value, and null
    fn removeAttributeInternal(self: *Element, attr_to_remove: *Attr) !void {

        // Step 1: element is self
        const old_value = attr_to_remove.value;

        // Step 2: Remove from attribute list
        for (self.attributes.toSlice(), 0..) |*attr, i| {
            if (attr == attr_to_remove) {
                _ = self.attributes.orderedRemove(i);
                break;
            }
        }

        // Step 3: Set attribute's element to null
        attr_to_remove.owner_element = null;

        // Step 4: Handle attribute changes
        // Note: Pass empty string for new_value since attribute is being removed
        try Attr.handleAttributeChanges(attr_to_remove, self, old_value, "");
    
    }

    /// Set an attribute value - DOM §4.10.4
    /// Spec: https://dom.spec.whatwg.org/#concept-element-attributes-set-value
    /// 
    /// To set an attribute value given element, localName, value, and optionally prefix and namespace:
    /// 1. Let attribute be result of getting attribute given namespace, localName, and element
    /// 2. If attribute is null, create attribute and append to element, then return
    /// 3. Change attribute to value
    fn setAttributeValue(
        self: *Element,
        local_name: []const u8,
        value: []const u8,
        prefix: ?[]const u8,
        namespace: ?[]const u8,
    ) !void {

        // Step 1: Get existing attribute
        const existing = self.getAttributeByNamespaceAndLocalName(namespace, local_name);

        if (existing) |attr| {
            // Step 3: Change attribute to value
            try Attr.changeAttribute(attr, value);
        } else {
            // Step 2: Create new attribute and append
            const new_attr = try Attr.init(
                self.allocator,
                namespace,
                prefix,
                local_name,
                value,
            );
            try self.appendAttribute(&new_attr);
        }
    
    }

    /// Remove an attribute by name - DOM §4.10.4
    /// Spec: https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
    /// 
    /// To remove an attribute by name given qualifiedName and element:
    /// 1. Let attr be result of getting attribute given qualifiedName and element
    /// 2. If attr is non-null, then remove attr
    /// 3. Return attr
    fn removeAttributeByName(self: *Element, qualified_name: []const u8) !void {

        if (self.getAttributeByName(qualified_name)) |attr| {
            try self.removeAttributeInternal(attr);
        }
    
    }

    /// Remove an attribute by namespace and local name - DOM §4.10.4
    /// Spec: https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
    /// 
    /// To remove an attribute by namespace and local name given namespace, localName, and element:
    /// 1. Let attr be result of getting attribute given namespace, localName, and element
    /// 2. If attr is non-null, then remove attr
    /// 3. Return attr
    fn removeAttributeByNamespaceAndLocalName(
        self: *Element,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) !void {

        if (self.getAttributeByNamespaceAndLocalName(namespace, local_name)) |attr| {
            try self.removeAttributeInternal(attr);
        }
    
    }

    /// Get an attribute by name - DOM §4.10.4
    /// Spec: https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
    /// 
    /// To get an attribute by name given a string qualifiedName and element:
    /// 1. If element is in HTML namespace and its node document is HTML document,
    /// then set qualifiedName to qualifiedName in ASCII lowercase
    /// 2. Return first attribute in element's attribute list whose qualified name
    /// is qualifiedName; otherwise null
    fn getAttributeByName(self: *const Element, qualified_name: []const u8) ?*Attr {

        // Step 1: ASCII lowercase if HTML element in HTML document
        var lowercased_buf: [256]u8 = undefined;
        const search_name = if (self.isHTMLElementInHTMLDocument()) blk: {
            // ASCII lowercase the qualified name
            if (qualified_name.len > lowercased_buf.len) {
                // Name too long for stack buffer, use heap
                // For now, just use original (this is edge case)
                break :blk qualified_name;
            }
            for (qualified_name, 0..) |c, i| {
                lowercased_buf[i] = std.ascii.toLower(c);
            }
            break :blk lowercased_buf[0..qualified_name.len];
        } else qualified_name;

        // Step 2: Find first attribute with matching qualified name
        for (@constCast(self).attributes.toSliceMut()) |*attr| {
            const attr_qualified_name = attr.get_name() catch continue;
            defer if (attr.prefix != null) self.allocator.free(attr_qualified_name); // Free if allocated

            if (std.mem.eql(u8, attr_qualified_name, search_name)) {
                return attr;
            }
        }
        return null;
    
    }

    /// Get an attribute by namespace and local name - DOM §4.10.4
    /// Spec: https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
    /// 
    /// To get an attribute by namespace and local name given null or string namespace,
    /// string localName, and element:
    /// 1. If namespace is empty string, set it to null
    /// 2. Return attribute in element's attribute list whose namespace is namespace
    /// and local name is localName, if any; otherwise null
    fn getAttributeByNamespaceAndLocalName(
        self: *const Element,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) ?*Attr {

        // Step 1: Empty string namespace becomes null
        const ns = if (namespace) |n| if (n.len == 0) null else n else null;

        // Step 2: Find attribute with matching namespace and local name
        for (@constCast(self).attributes.toSliceMut()) |*attr| {
            // Check namespace match
            const ns_match = if (ns == null and attr.namespace_uri == null)
                true
            else if (ns != null and attr.namespace_uri != null)
                std.mem.eql(u8, ns.?, attr.namespace_uri.?)
            else
                false;

            // Check local name match
            const name_match = std.mem.eql(u8, attr.local_name, local_name);

            if (ns_match and name_match) {
                return attr;
            }
        }
        return null;
    
    }

    /// Check if this element is an HTML element in an HTML document
    /// Used for ASCII lowercasing of attribute names
    fn isHTMLElementInHTMLDocument(self: *const Element) bool {

        // Check if element is in HTML namespace
        const html_ns = "http://www.w3.org/1999/xhtml";
        const in_html_namespace = if (self.namespace_uri) |ns|
            std.mem.eql(u8, ns, html_ns)
        else
            false;

        if (!in_html_namespace) return false;

        // Check if node document is an HTML document
        // For now, we'll assume documents are HTML unless explicitly XML
        // Full implementation would check document.type
        // TODO: Check owner_document.type when Document is fully implemented
        return true;
    
    }

    /// getAttribute(qualifiedName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-getattribute
    /// 
    /// The getAttribute(qualifiedName) method steps are:
    /// 1. Let attr be result of getting an attribute given qualifiedName and this
    /// 2. If attr is null, return null
    /// 3. Return attr's value
    pub fn call_getAttribute(self: *const Element, qualified_name: []const u8) ?[]const u8 {

        // Step 1: Get attribute by name
        const attr = self.getAttributeByName(qualified_name) orelse return null;

        // Step 3: Return attr's value
        return attr.value;
    
    }

    /// getAttributeNS(namespace, localName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-getattributens
    /// 
    /// The getAttributeNS(namespace, localName) method steps are:
    /// 1. Let attr be result of getting an attribute given namespace, localName, and this
    /// 2. If attr is null, return null
    /// 3. Return attr's value
    pub fn call_getAttributeNS(
        self: *const Element,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) ?[]const u8 {

        // Step 1: Get attribute by namespace and local name
        const attr = self.getAttributeByNamespaceAndLocalName(namespace, local_name) orelse return null;

        // Step 3: Return attr's value
        return attr.value;
    
    }

    /// setAttribute(qualifiedName, value)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-setattribute
    /// 
    /// The setAttribute(qualifiedName, value) method steps are:
    /// 1. If qualifiedName is not valid attribute local name, throw InvalidCharacterError
    /// 2. If this is in HTML namespace and node document is HTML document,
    /// set qualifiedName to qualifiedName in ASCII lowercase
    /// 3. Let attribute be first attribute in this's attribute list whose qualified name
    /// is qualifiedName, and null otherwise
    /// 4. If attribute is null, create attribute and append to this, then return
    /// 5. Change attribute to value
    pub fn call_setAttribute(self: *Element, qualified_name: []const u8, value: []const u8) !void {

        // Step 1: Validate qualified name (simplified - check not empty and valid chars)
        if (qualified_name.len == 0) {
            return error.InvalidCharacterError;
        }

        // Step 2: ASCII lowercase if HTML element in HTML document
        var lowercased_buf: [256]u8 = undefined;
        const normalized_name = if (self.isHTMLElementInHTMLDocument()) blk: {
            if (qualified_name.len > lowercased_buf.len) {
                break :blk qualified_name; // Edge case: name too long
            }
            for (qualified_name, 0..) |c, i| {
                lowercased_buf[i] = std.ascii.toLower(c);
            }
            break :blk lowercased_buf[0..qualified_name.len];
        } else qualified_name;

        // Step 3: Find existing attribute
        const existing = self.getAttributeByName(normalized_name);

        if (existing) |attr| {
            // Step 5: Change attribute to value
            try Attr.changeAttribute(attr, value);
        } else {
            // Step 4: Create new attribute and append
            // For setAttribute, we create with null namespace and prefix
            const new_attr = try Attr.init(
                self.allocator,
                null, // namespace
                null, // prefix
                normalized_name,
                value,
            );
            try self.appendAttribute(&new_attr);
        }
    
    }

    /// setAttributeNS(namespace, qualifiedName, value)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-setattributens
    /// 
    /// The setAttributeNS(namespace, qualifiedName, value) method steps are:
    /// 1. Let (namespace, prefix, localName) = result of validating and extracting
    /// namespace and qualifiedName given "element"
    /// 2. Set an attribute value for this using localName, value, and also prefix and namespace
    pub fn call_setAttributeNS(
        self: *Element,
        namespace: ?[]const u8,
        qualified_name: []const u8,
        value: []const u8,
    ) !void {

        // Step 1: Validate and extract namespace/qualifiedName
        // For now, simplified: split on ':' if present
        var prefix: ?[]const u8 = null;
        var local_name: []const u8 = qualified_name;

        if (std.mem.indexOfScalar(u8, qualified_name, ':')) |colon_idx| {
            prefix = qualified_name[0..colon_idx];
            local_name = qualified_name[colon_idx + 1 ..];
        }

        // Step 2: Set attribute value
        try self.setAttributeValue(local_name, value, prefix, namespace);
    
    }

    /// removeAttribute(qualifiedName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-removeattribute
    /// 
    /// The removeAttribute(qualifiedName) method steps are to remove an attribute
    /// given qualifiedName and this, and then return undefined.
    pub fn call_removeAttribute(self: *Element, qualified_name: []const u8) !void {

        try self.removeAttributeByName(qualified_name);
    
    }

    /// removeAttributeNS(namespace, localName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-removeattributens
    /// 
    /// The removeAttributeNS(namespace, localName) method steps are to remove an attribute
    /// given namespace, localName, and this, and then return undefined.
    pub fn call_removeAttributeNS(
        self: *Element,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) !void {

        try self.removeAttributeByNamespaceAndLocalName(namespace, local_name);
    
    }

    /// toggleAttribute(qualifiedName, force?)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-toggleattribute
    /// 
    /// The toggleAttribute(qualifiedName, force) method steps are:
    /// 1. If qualifiedName is not valid attribute local name, throw InvalidCharacterError
    /// 2. If this is in HTML namespace and node document is HTML, set qualifiedName to ASCII lowercase
    /// 3. Let attribute be first attribute whose qualified name is qualifiedName, else null
    /// 4. If attribute is null:
    /// a. If force not given or is true, create attribute with empty value, append, return true
    /// b. Return false
    /// 5. Otherwise, if force not given or is false, remove attribute, return false
    /// 6. Return true
    pub fn call_toggleAttribute(
        self: *Element,
        qualified_name: []const u8,
        force: ?bool,
    ) !bool {

        // Step 1: Validate qualified name
        if (qualified_name.len == 0) {
            return error.InvalidCharacterError;
        }

        // Step 2: ASCII lowercase if HTML element in HTML document
        var lowercased_buf: [256]u8 = undefined;
        const normalized_name = if (self.isHTMLElementInHTMLDocument()) blk: {
            if (qualified_name.len > lowercased_buf.len) {
                break :blk qualified_name; // Edge case: name too long
            }
            for (qualified_name, 0..) |c, i| {
                lowercased_buf[i] = std.ascii.toLower(c);
            }
            break :blk lowercased_buf[0..qualified_name.len];
        } else qualified_name;

        // Step 3: Find existing attribute
        const existing = self.getAttributeByName(normalized_name);

        // Step 4: If attribute is null
        if (existing == null) {
            // Step 4a: If force not given or is true, create and append
            if (force == null or force.? == true) {
                const new_attr = try Attr.init(
                    self.allocator,
                    null, // namespace
                    null, // prefix
                    normalized_name,
                    "", // empty value
                );
                try self.appendAttribute(&new_attr);
                return true;
            }
            // Step 4b: Return false
            return false;
        }

        // Step 5: Otherwise, if force not given or is false, remove attribute
        if (force == null or force.? == false) {
            try self.removeAttributeByName(normalized_name);
            return false;
        }

        // Step 6: Return true (attribute exists and force is true)
        return true;
    
    }

    /// hasAttribute(qualifiedName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-hasattribute
    /// 
    /// The hasAttribute(qualifiedName) method steps are:
    /// 1. If this is in HTML namespace and its node document is HTML document,
    /// then set qualifiedName to qualifiedName in ASCII lowercase
    /// 2. Return true if this has attribute whose qualified name is qualifiedName;
    /// otherwise false
    pub fn call_hasAttribute(self: *const Element, qualified_name: []const u8) bool {

        return self.getAttributeByName(qualified_name) != null;
    
    }

    /// hasAttributeNS(namespace, localName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-hasattributens
    /// 
    /// The hasAttributeNS(namespace, localName) method steps are:
    /// 1. If namespace is empty string, set it to null
    /// 2. Return true if this has attribute whose namespace is namespace and
    /// local name is localName; otherwise false
    pub fn call_hasAttributeNS(
        self: *const Element,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) bool {

        return self.getAttributeByNamespaceAndLocalName(namespace, local_name) != null;
    
    }

    /// getAttributeNames()
    /// Spec: https://dom.spec.whatwg.org/#dom-element-getattributenames
    /// 
    /// The getAttributeNames() method steps are to return the qualified names
    /// of the attributes in this's attribute list, in order; otherwise a new list.
    /// 
    /// These are not guaranteed to be unique.
    /// 
    /// Note: Caller owns returned memory and must free each string and the List
    pub fn call_getAttributeNames(self: *const Element) !infra.List([]const u8) {

        var names = infra.List([]const u8).init(self.allocator);
        errdefer {
            var i: usize = 0;
            while (i < names.len) : (i += 1) {
                // Only free if prefix exists (qualified name was allocated)
                // If no prefix, it's just local_name which is owned by Attr
            }
            names.deinit();
        }

        var i: usize = 0;
        while (i < self.attributes.len) : (i += 1) {
            const attr = self.attributes.getMut(i).?;
            const qualified_name = try attr.get_name();
            // Note: get_name() returns allocated string if prefix exists,
            // otherwise returns local_name directly
            // The caller is responsible for freeing if needed
            try names.append(qualified_name);
        }

        return names;
    
    }

    /// DOM §4.10.1 - Element.id
    /// The id getter steps are to return the value of this's id content attribute.
    /// The id setter steps are to set the value of this's id content attribute to the given value.
    pub fn get_id(self: *const Element) []const u8 {

        return self.call_getAttribute("id") orelse "";
    
    }

    pub fn set_id(self: *Element, value: []const u8) !void {

        try self.call_setAttribute("id", value);
    
    }

    /// DOM §4.10.1 - Element.className
    /// The className getter steps are to return the value of this's class content attribute.
    /// The className setter steps are to set the value of this's class content attribute to the given value.
    pub fn get_className(self: *const Element) []const u8 {

        return self.call_getAttribute("class") orelse "";
    
    }

    pub fn set_className(self: *Element, value: []const u8) !void {

        try self.call_setAttribute("class", value);
    
    }

    /// DOM §4.10.1 - Element.classList
    /// The classList getter steps are to return a DOMTokenList object whose associated element
    /// is this and whose associated attribute's local name is class.
    /// 
    /// Returns a DOMTokenList representing the class attribute.
    /// The DOMTokenList is [SameObject] - returns same instance on repeated calls.
    pub fn get_classList(self: *Element) !*DOMTokenList {

        // Return cached instance if available
        if (self.cached_class_list) |list| {
            return list;
        }

        const TokenList = @import("dom_token_list").DOMTokenList;

        // Create DOMTokenList associated with this element's "class" attribute
        const token_list = try self.allocator.create(TokenList);
        token_list.* = try TokenList.init(self.allocator, self, "class");

        // Parse current class attribute value into tokens
        const class_value = self.call_getAttribute("class") orelse "";
        if (class_value.len > 0) {
            var iter = std.mem.tokenizeScalar(u8, class_value, ' ');
            while (iter.next()) |token| {
                // Skip empty tokens
                if (token.len == 0) continue;

                const token_copy = try self.allocator.dupe(u8, token);
                try token_list.tokens.append(token_copy);
            }
        }

        // Cache the instance for [SameObject] semantics
        self.cached_class_list = token_list;

        return token_list;
    
    }

    /// DOM §4.9 - Element.attributes
    /// Returns the element's attribute list as a NamedNodeMap.
    /// The NamedNodeMap is [SameObject] - returns same instance on repeated calls.
    /// Spec: https://dom.spec.whatwg.org/#ref-for-dom-element-attributes
    pub fn get_attributes(self: *Element) !*@import("named_node_map").NamedNodeMap {

        // Return cached instance if available
        if (self.cached_attributes) |attrs| {
            return attrs;
        }

        const NamedNodeMap = @import("named_node_map").NamedNodeMap;

        // Create NamedNodeMap associated with this element
        const named_node_map = try self.allocator.create(NamedNodeMap);
        named_node_map.* = NamedNodeMap.init(self);

        // Cache the instance for [SameObject] semantics
        self.cached_attributes = named_node_map;

        return named_node_map;
    
    }

    /// DOM §4.10.1 - Element.slot
    /// The slot getter steps are to return the value of this's slot content attribute.
    /// The slot setter steps are to set the value of this's slot content attribute to the given value.
    pub fn get_slot(self: *const Element) []const u8 {

        return self.call_getAttribute("slot") orelse "";
    
    }

    pub fn set_slot(self: *Element, value: []const u8) !void {

        try self.call_setAttribute("slot", value);
    
    }

    /// Getters
    pub fn get_namespaceURI(self: *const Element) ?[]const u8 {

        return self.namespace_uri;
    
    }

    pub fn get_prefix(self: *const Element) ?[]const u8 {

        return self.prefix;
    
    }

    pub fn get_localName(self: *const Element) []const u8 {

        return self.local_name;
    
    }

    pub fn get_tagName(self: *const Element) []const u8 {

        return self.tag_name;
    
    }

    /// DOM §4.10.5 - Element.getElementsByTagName(qualifiedName)
    /// Returns an HTMLCollection of all descendant elements whose qualified name is qualifiedName.
    /// If qualifiedName is "*", returns all descendant elements.
    pub fn call_getElementsByTagName(self: *Element, qualified_name: []const u8) !*HTMLCollection {

        const collection = try self.allocator.create(HTMLCollection);
        collection.* = try HTMLCollection.init(self.allocator);

        // Collect matching descendants
        try self.collectByTagName(&self.base, qualified_name, collection);

        return collection;
    
    }

    fn collectByTagName(self: *const Element, node: *Node, qualified_name: []const u8, collection: *HTMLCollection) !void {

        for (node.child_nodes.toSlice()()) |child| {
            if (child.node_type == Node.ELEMENT_NODE) {
                const elem: *Element = @ptrCast(child);

                // Check if matches
                const matches = if (std.mem.eql(u8, qualified_name, "*"))
                    true
                else
                    std.mem.eql(u8, elem.node_name, qualified_name);

                if (matches) {
                    try collection.addElement(elem);
                }

                // Recurse
                try self.collectByTagName(child, qualified_name, collection);
            }
        }
    
    }

    /// DOM §4.10.5 - Element.getElementsByTagNameNS(namespace, localName)
    /// Returns an HTMLCollection of all descendant elements matching the namespace and local name.
    /// If namespace is "*", matches any namespace.
    /// If localName is "*", matches any local name.
    /// If both are "*", returns all descendant elements.
    pub fn call_getElementsByTagNameNS(
        self: *Element,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) !*HTMLCollection {

        const collection = try self.allocator.create(HTMLCollection);
        collection.* = try HTMLCollection.init(self.allocator);

        try self.collectByTagNameNS(&self.base, namespace, local_name, collection);

        return collection;
    
    }

    fn collectByTagNameNS(self: *const Element, node: *Node, namespace: ?[]const u8, local_name: []const u8, collection: *HTMLCollection) !void {

        for (node.child_nodes.toSlice()()) |child| {
            if (child.node_type == Node.ELEMENT_NODE) {
                const elem: *Element = @ptrCast(child);

                // Check namespace match
                const ns_matches = if (namespace) |ns|
                    std.mem.eql(u8, ns, "*") or (elem.namespace_uri != null and std.mem.eql(u8, elem.namespace_uri.?, ns))
                else
                    elem.namespace_uri == null;

                // Check local name match
                const name_matches = std.mem.eql(u8, local_name, "*") or std.mem.eql(u8, elem.local_name, local_name);

                if (ns_matches and name_matches) {
                    try collection.addElement(elem);
                }

                try self.collectByTagNameNS(child, namespace, local_name, collection);
            }
        }
    
    }

    /// DOM §4.10.5 - Element.getElementsByClassName(classNames)
    /// Returns an HTMLCollection of all descendant elements that have all the given class names.
    /// classNames is a space-separated list of class names.
    pub fn call_getElementsByClassName(self: *Element, class_names: []const u8) !*HTMLCollection {

        const collection = try self.allocator.create(HTMLCollection);
        collection.* = try HTMLCollection.init(self.allocator);

        try self.collectByClassName(&self.base, class_names, collection);

        return collection;
    
    }

    fn collectByClassName(self: *const Element, node: *Node, class_names: []const u8, collection: *HTMLCollection) !void {

        for (node.child_nodes.toSlice()()) |child| {
            if (child.node_type == Node.ELEMENT_NODE) {
                const elem: *Element = @ptrCast(child);

                // Check if element has all required classes
                const attributes = elem.get_attributes();
                if (attributes.call_getNamedItem("class")) |class_attr| {
                    var all_found = true;
                    var required_iter = std.mem.tokenizeScalar(u8, class_names, ' ');
                    while (required_iter.next()) |required_class| {
                        var found = false;
                        var elem_iter = std.mem.tokenizeScalar(u8, class_attr.value, ' ');
                        while (elem_iter.next()) |elem_class| {
                            if (std.mem.eql(u8, elem_class, required_class)) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            all_found = false;
                            break;
                        }
                    }

                    if (all_found) {
                        try collection.addElement(elem);
                    }
                }

                try self.collectByClassName(child, class_names, collection);
            }
        }
    
    }

    /// DOM §4.10.4 - Element.matches(selectors)
    /// Returns true if this element would be selected by the given CSS selectors; otherwise false.
    /// 
    /// Spec steps:
    /// 1. Let s be the result of parse a selector from selectors.
    /// 2. If s is failure, throw a "SyntaxError" DOMException.
    /// 3. If the result of match a selector against an element, using s, this,
    /// and :scope element this, returns success, then return true; otherwise, return false.
    pub fn call_matches(self: *const Element, allocator: Allocator, selectors: []const u8) !bool {

        // Use scopeMatchSelectorsString to parse and match
        // This will throw SyntaxError if parsing fails
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Check if self is in the matches list
        for (matches.toSlice()) |match| {
            if (match == self) {
                return true;
            }
        }

        return false;
    
    }

    /// DOM §4.10.4 - Element.closest(selectors)
    /// Returns the closest ancestor element (including this element) that matches the given CSS selectors.
    /// Returns null if no such element exists.
    /// 
    /// Spec steps:
    /// 1. Let s be the result of parse a selector from selectors.
    /// 2. If s is failure, throw a "SyntaxError" DOMException.
    /// 3. Let elements be this's inclusive ancestors that are elements, in reverse tree order.
    /// 4. For each element in elements, if the result of match a selector against an element,
    /// using s, element, and :scope element this, returns success, return element.
    /// 5. Return null.
    pub fn call_closest(self: *const Element, allocator: Allocator, selectors: []const u8) !?*Element {

        const NodeType = @import("node").Node;

        // Parse selectors (will throw SyntaxError if invalid)
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Step 3: Walk up the tree from this element
        // Check this element and its ancestors
        const self_node: *const NodeType = @ptrCast(self);
        var current: ?*const NodeType = self_node;

        while (current) |node| {
            // Only check elements
            if (node.node_type == NodeType.ELEMENT_NODE) {
                const elem: *const Element = @ptrCast(node);

                // Check if this element is in the matches
                for (matches.toSlice()) |match| {
                    if (match == elem) {
                        // Cast away const - closest returns mutable pointer
                        return @constCast(elem);
                    }
                }
            }

            // Move to parent
            current = node.parent_node;
        }

        // Step 5: No match found
        return null;
    
    }

    /// DOM §4.10.7 - insert adjacent algorithm
    /// To insert adjacent, given an element element, string where, and a node node, run the steps
    /// associated with the first ASCII case-insensitive match for where
    fn insertAdjacent(element: *Element, where: []const u8, node: *Node) !?*Node {

        const mutation = dom.mutation;

        // ASCII case-insensitive comparison helper
        const eqlIgnoreCase = std.ascii.eqlIgnoreCase;

        if (eqlIgnoreCase(where, "beforebegin")) {
            // If element's parent is null, return null
            const parent = element.parent_node orelse return null;

            // Return the result of pre-inserting node into element's parent before element
            return try mutation.preInsert(node, parent, element);
        } else if (eqlIgnoreCase(where, "afterbegin")) {
            // Return the result of pre-inserting node into element before element's first child
            const first_child = if (element.child_nodes.toSlice().len > 0)
                element.child_nodes.toSlice()[0]
            else
                null;
            return try mutation.preInsert(node, @ptrCast(element), first_child);
        } else if (eqlIgnoreCase(where, "beforeend")) {
            // Return the result of pre-inserting node into element before null
            return try mutation.preInsert(node, @ptrCast(element), null);
        } else if (eqlIgnoreCase(where, "afterend")) {
            // If element's parent is null, return null
            const parent = element.parent_node orelse return null;

            // Return the result of pre-inserting node into element's parent before element's next sibling
            const next_sibling = dom.tree_helpers.getNextSibling(element);
            return try mutation.preInsert(node, parent, next_sibling);
        } else {
            // Otherwise: Throw a "SyntaxError" DOMException
            return error.SyntaxError;
        }
    
    }

    /// DOM §4.10.7 - Element.insertAdjacentElement(where, element)
    /// The insertAdjacentElement(where, element) method steps are to return the result of
    /// running insert adjacent, given this, where, and element.
    pub fn call_insertAdjacentElement(self: *Element, where: []const u8, element: *Element) !?*Element {

        const result = try insertAdjacent(self, where, @ptrCast(element));
        return if (result) |node| @ptrCast(@alignCast(node)) else null;
    
    }

    /// DOM §4.10.7 - Element.insertAdjacentText(where, data)
    /// The insertAdjacentText(where, data) method steps are:
    /// 1. Let text be a new Text node whose data is data and node document is this's node document.
    /// 2. Run insert adjacent, given this, where, and text.
    /// This method returns nothing because it existed before we had a chance to design it.
    pub fn call_insertAdjacentText(self: *Element, where: []const u8, data: []const u8) !void {

        // Step 1: Let text be a new Text node whose data is data and node document is this's node document
        const text = try self.allocator.create(Text);
        errdefer self.allocator.destroy(text);
        text.* = try Text.init(self.allocator);
        // Set the text node's data
        self.allocator.free(text.data);
        text.data = try self.allocator.dupe(u8, data);

        // Step 2: Run insert adjacent, given this, where, and text
        _ = try insertAdjacent(self, where, @ptrCast(text));
    
    }

    /// DOM §4.10.2 - Element.attachShadow(init)
    /// 
    /// Creates a shadow root for this element and returns it.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-element-attachshadow
    pub fn call_attachShadow(self: *Element, shadow_init: ShadowRootInit) !*ShadowRoot {

        // Step 1: Let registry be this's node document's custom element registry
        const registry = shadow_init.customElementRegistry;

        // Step 2: If init["customElementRegistry"] is non-null:
        if (shadow_init.customElementRegistry) |_| {
            // Step 2.1: Set registry to init["customElementRegistry"]
            // Step 2.2: If registry's is scoped is false and registry is not this's node document's custom element registry, then throw NotSupportedError
            // Note: Full validation requires CustomElementRegistry implementation with is_scoped property
        }

        // Step 3: Run attach a shadow root with this, init["mode"], init["clonable"],
        // init["serializable"], init["delegatesFocus"], init["slotAssignment"], and registry
        const shadow_dom_algorithms = dom.shadow_dom_algorithms;
        try shadow_dom_algorithms.attachShadowRoot(
            self,
            shadow_init.mode,
            shadow_init.clonable,
            shadow_init.serializable,
            shadow_init.delegatesFocus,
            shadow_init.slotAssignment,
            registry,
        );

        // Step 4: Return this's shadow root
        return self.shadow_root.?;
    
    }

    /// DOM §4.10.2 - Element.shadowRoot getter
    /// 
    /// Returns element's shadow root, if any, and if shadow root's mode is "open"; otherwise null.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-element-shadowroot
    pub fn get_shadowRoot(self: *const Element) ?*ShadowRoot {

        // Step 1: Let shadow be this's shadow root
        const shadow = self.shadow_root orelse return null;

        // Step 2: If shadow's mode is "closed", then return null
        if (shadow.getMode() == .closed) {
            return null;
        }

        // Step 3: Return shadow
        return shadow;
    
    }

    /// DOM §4.3.4 - ChildNode.before()
    /// Inserts nodes just before this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If viablePreviousSibling is null, then set it to parent's first child; otherwise to viablePreviousSibling's next sibling.
    /// 6. Pre-insert node into parent before viablePreviousSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_before(self: Element, nodes: []const dom_types.NodeOrDOMString) !void {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self_parent to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self_parent));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null
        var viable_previous_sibling: ?*NodeType = null;

        // Walk backwards through siblings to find first one not in nodes
        var current = this_node.get_previousSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_previous_sibling = sibling;
                break;
            }

            current = sibling.get_previousSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNode.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If viablePreviousSibling is null, set it to parent's first child;
        // otherwise to viablePreviousSibling's next sibling
        const reference_child = if (viable_previous_sibling) |vps|
            vps.get_nextSibling()
        else
            parent.?.get_firstChild();

        // Step 6: Pre-insert node into parent before viablePreviousSibling
        _ = try mutation.preInsert(node, parent.?, reference_child);
    
    }

    /// DOM §4.3.4 - ChildNode.after()
    /// Inserts nodes just after this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. Pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_after(self: Element, nodes: []const dom_types.NodeOrDOMString) !void {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self_parent to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self_parent));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNode.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: Pre-insert node into parent before viableNextSibling
        _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
    
    }

    /// DOM §4.3.4 - ChildNode.replaceWith()
    /// Replaces this node with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If this's parent is parent, replace this with node within parent.
    /// 6. Otherwise, pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_replaceWith(self: Element, nodes: []const dom_types.NodeOrDOMString) !void {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self_parent to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self_parent));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNode.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If this's parent is parent, replace this with node within parent
        // Note: The parent could have changed during convertNodesIntoNode if one of the nodes
        // contained 'this' in its subtree
        if (this_node.parent_node == parent) {
            try mutation.replace(this_node, node, parent.?);
        } else {
            // Step 6: Otherwise, pre-insert node into parent before viableNextSibling
            _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
        }
    
    }

    /// DOM §4.3.4 - ChildNode.remove()
    /// Removes this node from its parent.
    /// 
    /// Steps:
    /// 1. If this's parent is null, then return.
    /// 2. Remove this.
    pub fn call_remove(self: Element) !void {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self_parent to Node pointer
        const node = @as(*NodeType, @ptrCast(self_parent));

        // Step 1: If this's parent is null, then return
        if (node.parent_node == null) {
            return;
        }

        // Step 2: Remove this
        try mutation.remove(node, false);
    
    }

    /// DOM §4.3.3 - NonDocumentTypeChildNode.previousElementSibling
    /// Returns the first preceding sibling that is an element; otherwise null.
    /// 
    /// The previousElementSibling getter steps are to return the first preceding
    /// sibling that is an element; otherwise null.
    pub fn previousElementSibling(self: Element) ?*Element {
        const self_parent = self;

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self_parent.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        var i: usize = parent.child_nodes.items.len;
        while (i > 0) {
            i -= 1;
            const sibling = parent.child_nodes.items[i];

            if (sibling == @as(*NodeType, @ptrCast(self_parent))) {
                found_self = true;
                continue;
            }

            // Only look at siblings before us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    
    }

    /// DOM §4.3.3 - NonDocumentTypeChildNode.nextElementSibling
    /// Returns the first following sibling that is an element; otherwise null.
    /// 
    /// The nextElementSibling getter steps are to return the first following
    /// sibling that is an element; otherwise null.
    pub fn nextElementSibling(self: Element) ?*Element {
        const self_parent = self;

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self_parent.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        for (parent.child_nodes.items) |sibling| {
            if (sibling == @as(*NodeType, @ptrCast(self_parent))) {
                found_self = true;
                continue;
            }

            // Only look at siblings after us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    
    }

    /// DOM §4.3.2 - ParentNode.children
    /// Returns the child elements.
    /// 
    /// The children getter steps are to return an HTMLCollection collection rooted
    /// at this matching only element children.
    /// 
    /// NOTE: This is a simplified implementation that returns a static snapshot.
    /// A full implementation would return a live HTMLCollection that updates
    /// automatically when the DOM changes.
    pub fn get_children(self: Element) !*HTMLCollection {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const allocator = self_parent.allocator;

        // Create HTMLCollection
        const collection = try allocator.create(HTMLCollection);
        collection.* = try HTMLCollection.init(allocator);

        // Filter child_nodes for elements only (ELEMENT_NODE = 1)
        for (self_parent.child_nodes.toSlice()) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                const element: *Element = @ptrCast(child);
                try collection.addElement(element);
            }
        }

        return collection;
    
    }

    /// DOM §4.3.2 - ParentNode.firstElementChild
    /// Returns the first child that is an element; otherwise null.
    /// 
    /// The firstElementChild getter steps are to return the first child that is
    /// an element; otherwise null.
    pub fn get_firstElementChild(self: Element) ?*Element {
        const self_parent = self;

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in tree order
        for (self_parent.child_nodes.toSlice()) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    
    }

    /// DOM §4.3.2 - ParentNode.lastElementChild
    /// Returns the last child that is an element; otherwise null.
    /// 
    /// The lastElementChild getter steps are to return the last child that is
    /// an element; otherwise null.
    pub fn get_lastElementChild(self: Element) ?*Element {
        const self_parent = self;

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in reverse tree order
        var i: usize = self_parent.child_nodes.toSlice().len;
        while (i > 0) {
            i -= 1;
            const child = self_parent.child_nodes.toSlice()[i];
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    
    }

    /// DOM §4.3.2 - ParentNode.childElementCount
    /// Returns the number of children that are elements.
    /// 
    /// The childElementCount getter steps are to return the number of children
    /// of this that are elements.
    pub fn get_childElementCount(self: Element) u32 {
        const self_parent = self;

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Count children that are Elements
        var count: u32 = 0;
        for (self_parent.child_nodes.toSlice()) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                count += 1;
            }
        }

        return count;
    
    }

    /// DOM §4.3.2 - ParentNode.prepend()
    /// Inserts nodes before the first child, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Pre-insert node into this before this's first child.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_prepend(self: Element, nodes: []const dom_types.NodeOrDOMString) !void {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self_parent to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self_parent));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Pre-insert node into this before this's first child
        const first_child = this_node.get_firstChild();
        _ = try mutation.preInsert(node, this_node, first_child);
    
    }

    /// DOM §4.3.2 - ParentNode.append()
    /// Inserts nodes after the last child, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Append node to this.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_append(self: Element, nodes: []const dom_types.NodeOrDOMString) !void {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self_parent to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self_parent));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Append node to this
        _ = try mutation.append(node, this_node);
    
    }

    /// DOM §4.3.2 - ParentNode.replaceChildren()
    /// Replaces all children with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Ensure pre-insert validity of node into this before null.
    /// 3. Replace all with node within this.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_replaceChildren(self: Element, nodes: []const dom_types.NodeOrDOMString) !void {
        const self_parent = self;

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self_parent to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self_parent));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Ensure pre-insert validity of node into this before null
        try mutation.ensurePreInsertValidity(node, this_node, null);

        // Step 3: Replace all with node within this
        try mutation.replaceAll(node, this_node);
    
    }

    /// DOM §4.3.2 - ParentNode.moveBefore()
    /// Moves, without first removing, movedNode into this after child.
    /// This method preserves state associated with movedNode.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-parentnode-movebefore
    /// 
    /// Steps:
    /// 1. Let referenceChild be child.
    /// 2. If referenceChild is node, then set referenceChild to node's next sibling.
    /// 3. Move node into this before referenceChild.
    /// 
    /// Throws HierarchyRequestError if constraints violated, or state cannot be preserved.
    pub fn call_moveBefore(self: Element, node: anytype, child: anytype) !void {
        const self_parent = self;

        const mutation = @import("dom").mutation;

        // Get Node pointers from the anytype parameters
        const parent_node = @as(*@import("node").Node, @ptrCast(self_parent));
        const moved_node = @as(*@import("node").Node, @ptrCast(node));
        const child_node = if (child) |c| @as(?*@import("node").Node, @ptrCast(c)) else null;

        // Step 1: Let referenceChild be child
        var reference_child = child_node;

        // Step 2: If referenceChild is node, then set referenceChild to node's next sibling
        if (reference_child == moved_node) {
            reference_child = moved_node.next_sibling;
        }

        // Step 3: Move node into this before referenceChild
        try mutation.move(moved_node, parent_node, reference_child);
    
    }

    /// DOM §4.3.2 - ParentNode.querySelector()
    /// Returns the first element that is a descendant of this that matches selectors.
    /// 
    /// The querySelector(selectors) method steps are to return the first result of
    /// running scope-match a selectors string selectors against this, if the result
    /// is not an empty list; otherwise null.
    /// 
    /// Uses Selectors mock (basic support only).
    pub fn call_querySelector(self: Element, allocator: std.mem.Allocator, selectors: []const u8) !?*Element {
        const self_parent = self;

        // Run scope-match a selectors string against this
        const matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self_parent);
        defer matches.deinit();

        // Return first result if not empty; otherwise null
        if (matches.toSlice().len > 0) {
            return matches.toSlice()[0];
        }

        return null;
    
    }

    /// DOM §4.3.2 - ParentNode.querySelectorAll()
    /// Returns all element descendants of this that match selectors.
    /// 
    /// The querySelectorAll(selectors) method steps are to return the static result
    /// of running scope-match a selectors string selectors against this.
    /// 
    /// Uses Selectors mock (basic support only).
    pub fn call_querySelectorAll(self: Element, allocator: std.mem.Allocator, selectors: []const u8) !*NodeList {
        const self_parent = self;

        // Run scope-match a selectors string against this
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self_parent);
        defer matches.deinit();

        // Create NodeList and populate with matches (static snapshot)
        var node_list = try allocator.create(NodeList);
        node_list.* = try NodeList.init(allocator);

        // Add all matched elements to the NodeList
        for (matches.toSlice()) |element| {
            // Cast Element to Node
            const node = @as(*@import("node").Node, @ptrCast(element));
            try node_list.addNode(node);
        }

        return node_list;
    
    }

    /// DOM §4.3.7 - Slottable.assignedSlot
    /// 
    /// Returns the slot element this slottable is assigned to, if any.
    /// Returns null if not assigned or if the shadow root is closed.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-slottable-assignedslot
    pub fn get_assignedSlot(self: *const Element) ?*anyopaque {
        const self_parent: *const @This() = @ptrCast(self);

        // The assignedSlot getter steps are to return the result of
        // find a slot given this and true (open flag)

        // TODO: Implement findSlot algorithm from shadow_dom_algorithms
        // For now, return the assigned slot if it exists
        // The "open" parameter means we only return slots in open shadow roots

        _ = self_parent;
        return null; // TODO: Implement when slot algorithms are available
    
    }

    /// Get the slottable name
    pub fn getSlottableName(self: *const Element) []const u8 {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.slottable_name;
    
    }

    /// Set the slottable name
    pub fn setSlottableName(self: *Element, name: []const u8) void {
        const self_parent: *@This() = @ptrCast(self);

        self_parent.slottable_name = name;
    
    }

    /// Check if this slottable is assigned
    pub fn isAssigned(self: *const Element) bool {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.assigned_slot != null;
    
    }

    /// Get the assigned slot
    pub fn getAssignedSlotInternal(self: *const Element) ?*anyopaque {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.assigned_slot;
    
    }

    /// Set the assigned slot
    pub fn setAssignedSlot(self: *Element, slot: ?*anyopaque) void {
        const self_parent: *@This() = @ptrCast(self);

        self_parent.assigned_slot = slot;
    
    }

    /// Get the manual slot assignment
    pub fn getManualSlotAssignment(self: *const Element) ?*anyopaque {
        const self_parent: *const @This() = @ptrCast(self);

        return self_parent.manual_slot_assignment;
    
    }

    /// Set the manual slot assignment
    pub fn setManualSlotAssignment(self: *Element, slot: ?*anyopaque) void {
        const self_parent: *@This() = @ptrCast(self);

        self_parent.manual_slot_assignment = slot;
    
    }

    /// insertBefore(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-insertbefore
    pub fn call_insertBefore(self: *Element, node: *Node, child: ?*Node) !*Node {
        const self_parent: *Node = @ptrCast(self);

        // Call mutation.preInsert algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preInsert(node, self_parent, child) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
            error.OutOfMemory => error.OutOfMemory,
            error.IndexOutOfBounds => error.IndexOutOfBounds,
        };
    
    }

    /// appendChild(node)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-appendchild
    pub fn call_appendChild(self: *Element, node: *Node) !*Node {
        const self_parent: *Node = @ptrCast(self);

        // Call mutation.append algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.append(node, self_parent) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
            error.OutOfMemory => error.OutOfMemory,
            error.IndexOutOfBounds => error.IndexOutOfBounds,
        };
    
    }

    /// replaceChild(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-replacechild
    pub fn call_replaceChild(self: *Element, node: *Node, child: *Node) !*Node {
        const self_parent: *Node = @ptrCast(self);

        // Call mutation.replace algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.replace(child, node, self_parent) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
            error.OutOfMemory => error.OutOfMemory,
            error.IndexOutOfBounds => error.IndexOutOfBounds,
        };
    
    }

    /// removeChild(child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-removechild
    pub fn call_removeChild(self: *Element, child: *Node) !*Node {
        const self_parent: *Node = @ptrCast(self);

        // Call mutation.preRemove algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preRemove(child, self_parent) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
            error.OutOfMemory => error.OutOfMemory,
            error.IndexOutOfBounds => error.IndexOutOfBounds,
        };
    
    }

    /// getRootNode(options)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-getrootnode
    /// 
    /// The getRootNode(options) method steps are to return this's shadow-including root
    /// if options["composed"] is true; otherwise this's root.
    pub fn call_getRootNode(self: *Element, options: ?GetRootNodeOptions) *Node {
        const self_parent: *Node = @ptrCast(self);

        const tree = @import("dom").tree;

        // Check if we need shadow-including root
        const composed = if (options) |opts| opts.composed else false;

        if (composed) {
            // Return shadow-including root (DOM §4.2.2.4)
            // Algorithm:
            // 1. Let root be node's root
            // 2. If root is a shadow root, return root's host's shadow-including root
            // 3. Return root
            var root = tree.root(self_parent);

            // Check if root is a ShadowRoot by checking type_tag
            while (root.base.type_tag == .ShadowRoot) {
                // Cast to ShadowRoot to access host
                const shadow_root: *ShadowRoot = @ptrCast(@alignCast(root));

                // Get the host element (which is a Node)
                const host_element = shadow_root.host_element;
                const host_node: *Node = @ptrCast(@alignCast(&host_element.base));

                // Get host's root (might be another shadow root)
                root = tree.root(host_node);
            }

            return root;
        } else {
            // Return regular root
            return tree.root(self_parent);
        }
    
    }

    /// contains(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-contains
    pub fn call_contains(self: *const Element, other: ?*const Node) bool {
        const self_parent: *const Node = @ptrCast(self);

        if (other == null) return false;
        // Check if other is an inclusive descendant of this
        const tree = @import("dom").tree;
        const other_node = other.?;
        return tree.isInclusiveDescendant(other_node, self_parent);
    
    }

    /// compareDocumentPosition(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    pub fn call_compareDocumentPosition(self: *const Element, other: *const Node) u16 {
        const self_parent: *const Node = @ptrCast(self);

        const tree = @import("dom").tree;

        // Step 1: If this is other, then return zero
        if (self_parent == other) {
            return 0;
        }

        // Step 2: Let node1 be other and node2 be this
        const node1 = other;
        const node2 = self_parent;

        // Step 3: Let attr1 and attr2 be null
        // Step 4-5: Handle attributes (not implemented yet - attributes don't participate in tree)
        // For now, we skip attribute handling as Attr nodes are handled separately

        // Step 6: If node1 or node2 is null, or node1's root is not node2's root
        // Check if nodes are in the same tree by comparing roots
        const root1 = tree.root(@constCast(node1));
        const root2 = tree.root(@constCast(node2));

        if (root1 != root2) {
            // Return disconnected + implementation specific + preceding/following
            // Use pointer comparison for consistent ordering
            const ptr1 = @intFromPtr(node1);
            const ptr2 = @intFromPtr(node2);
            const ordering = if (ptr1 < ptr2) Node.DOCUMENT_POSITION_PRECEDING else Node.DOCUMENT_POSITION_FOLLOWING;
            return Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | ordering;
        }

        // Step 7: If node1 is an ancestor of node2
        if (tree.isAncestor(node1, node2)) {
            return Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 8: If node1 is a descendant of node2
        if (tree.isDescendant(node1, node2)) {
            return Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING;
        }

        // Step 9: If node1 is preceding node2
        if (tree.isPreceding(node1, node2)) {
            return Node.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 10: Return DOCUMENT_POSITION_FOLLOWING
        return Node.DOCUMENT_POSITION_FOLLOWING;
    
    }

    /// isEqualNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isequalnode
    pub fn call_isEqualNode(self: *const Element, other_node: ?*const Node) bool {
        const self_parent: *const Node = @ptrCast(self);

        // Step 1: Return true if otherNode is non-null and this equals otherNode
        if (other_node == null) return false;
        return Node.nodeEquals(self_parent, other_node.?);
    
    }

    /// Node A equals node B - DOM Spec algorithm
    /// A node A equals a node B if all of the following conditions are true:
    /// - A and B implement the same interfaces
    /// - Node-specific properties are equal
    /// - If A is an element, each attribute in its list equals an attribute in B's list
    /// - A and B have the same number of children
    /// - Each child of A equals the child of B at the identical index
    pub fn nodeEquals(a: *const Node, b: *const Node) bool {

        // Step 1: A and B implement the same interfaces (check node_type)
        if (a.node_type != b.node_type) return false;

        // Step 2: Check node-type-specific properties
        switch (a.node_type) {
            DOCUMENT_TYPE_NODE => {
                // DocumentType: check name, public ID, and system ID
                const DocumentType = @import("document_type").DocumentType;
                const doctype_a: *const DocumentType = @ptrCast(@alignCast(a));
                const doctype_b: *const DocumentType = @ptrCast(@alignCast(b));

                // Check name
                if (!std.mem.eql(u8, doctype_a.name, doctype_b.name)) return false;

                // Check public ID
                if (!std.mem.eql(u8, doctype_a.public_id, doctype_b.public_id)) return false;

                // Check system ID
                if (!std.mem.eql(u8, doctype_a.system_id, doctype_b.system_id)) return false;
            },
            ELEMENT_NODE => {
                // Element: check namespace, namespace prefix, local name, and attribute list size
                const elem_a: *const Element = @ptrCast(@alignCast(a));
                const elem_b: *const Element = @ptrCast(@alignCast(b));

                // Check namespace
                if (elem_a.namespace_uri == null and elem_b.namespace_uri != null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri == null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri != null) {
                    if (!std.mem.eql(u8, elem_a.namespace_uri.?, elem_b.namespace_uri.?)) return false;
                }

                // Check local name (tag_name)
                if (!std.mem.eql(u8, elem_a.tag_name, elem_b.tag_name)) return false;

                // Check attribute list size
                if (elem_a.attributes.len != elem_b.attributes.len) return false;

                // Step 3: Each attribute in A's list has an equal attribute in B's list
                for (elem_a.attributes.toSlice()) |attr_a| {
                    var found = false;
                    for (elem_b.attributes.toSlice()) |attr_b| {
                        if (Node.attributeEquals(&attr_a, &attr_b)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) return false;
                }
            },
            ATTRIBUTE_NODE => {
                // Attr: check namespace, local name, and value
                // Note: Attr nodes don't participate in tree, but we check for completeness
                const attr_a: *const Attr = @ptrCast(@alignCast(a));
                const attr_b: *const Attr = @ptrCast(@alignCast(b));
                return Node.attributeEquals(attr_a, attr_b);
            },
            PROCESSING_INSTRUCTION_NODE => {
                // ProcessingInstruction: check target and data
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi_a: *const PI = @ptrCast(@alignCast(a));
                const pi_b: *const PI = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, pi_a.target, pi_b.target)) return false;
                if (!std.mem.eql(u8, pi_a.data, pi_b.data)) return false;
            },
            TEXT_NODE, COMMENT_NODE, CDATA_SECTION_NODE => {
                // Text, Comment, CDATASection: check data
                const cd_a: *const CharacterData = @ptrCast(@alignCast(a));
                const cd_b: *const CharacterData = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, cd_a.data, cd_b.data)) return false;
            },
            else => {
                // For other node types, basic node_name check is sufficient
                if (!std.mem.eql(u8, a.node_name, b.node_name)) return false;
            },
        }

        // Step 4: A and B have the same number of children
        if (a.child_nodes.len != b.child_nodes.len) return false;

        // Step 5: Each child of A equals the child of B at the identical index
        for (a.child_nodes.toSlice(), 0..) |child_a, i| {
            const child_b = b.child_nodes.toSlice()[i];
            if (!Node.nodeEquals(child_a, child_b)) return false;
        }

        return true;
    
    }

    /// Attribute equality check
    /// An attribute A equals an attribute B if:
    /// - namespace is equal
    /// - local name is equal
    /// - value is equal
    pub fn attributeEquals(a: *const @import("attr").Attr, b: *const @import("attr").Attr) bool {

        // Check namespace
        if (a.namespace_uri == null and b.namespace_uri != null) return false;
        if (a.namespace_uri != null and b.namespace_uri == null) return false;
        if (a.namespace_uri != null and b.namespace_uri != null) {
            if (!std.mem.eql(u8, a.namespace_uri.?, b.namespace_uri.?)) return false;
        }

        // Check local name
        if (!std.mem.eql(u8, a.local_name, b.local_name)) return false;

        // Check value
        if (!std.mem.eql(u8, a.value, b.value)) return false;

        return true;
    
    }

    /// isSameNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-issamenode
    pub fn call_isSameNode(self: *const Element, other_node: ?*const Node) bool {
        const self_parent: *const Node = @ptrCast(self);

        // Legacy alias of === (pointer equality)
        if (other_node == null) return false;
        return self_parent == other_node.?;
    
    }

    /// hasChildNodes()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-haschildnodes
    pub fn call_hasChildNodes(self: *const Element) bool {
        const self_parent: *const Node = @ptrCast(self);

        return self_parent.child_nodes.len > 0;
    
    }

    /// cloneNode(deep)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-clonenode
    pub fn call_cloneNode(self: *Element, deep: bool) !*Node {
        const self_parent: *Node = @ptrCast(self);

        // Step 1: If this is a shadow root, throw NotSupportedError
        if (self_parent.node_type == Node.DOCUMENT_FRAGMENT_NODE) {
            // Check if this is specifically a ShadowRoot
            // ShadowRoot inherits from DocumentFragment and has a non-null host
            const DocumentFragment = @import("document_fragment").DocumentFragment;
            const frag: *const DocumentFragment = @ptrCast(@alignCast(self_parent));
            if (frag.host != null) {
                // This is a ShadowRoot (host is non-null)
                return error.NotSupportedError;
            }
        }

        // Step 2: Return the result of cloning this node with subtree set to deep
        return try Node.cloneNodeInternal(self_parent, self_parent.owner_document, deep, null, null);
    
    }

    /// Clone a node - DOM Spec algorithm
    /// Given a node `node` and optional document, subtree flag, parent, and fallbackRegistry
    pub fn cloneNodeInternal(
        node: *Node,
        document_param: ?*Document,
        subtree: bool,
        parent: ?*Node,
        fallback_registry: ?*anyopaque, // CustomElementRegistry - not implemented yet
    ) !*Node {

        // Step 1: Let document be document_param or node's owner_document
        const document = document_param orelse node.owner_document;

        // Assert: node is not a document or node is document
        // (We don't have full Document implementation yet, skip this assert)

        // Step 2: Let copy be the result of cloning a single node
        var copy = try Node.cloneSingleNode(node, document, fallback_registry);

        // Step 3: Run any cloning steps defined for node
        // Specifications may define cloning steps for specific node types
        if (node.cloning_steps_hook) |hook| {
            try hook(node, copy, subtree);
        }

        // Step 4: If parent is non-null, append copy to parent
        if (parent) |p| {
            try p.child_nodes.append(copy);
            copy.parent_node = p;
        }

        // Step 5: If subtree is true, clone all children recursively
        if (subtree) {
            for (node.child_nodes.toSlice()) |child| {
                _ = try Node.cloneNodeInternal(child, document, subtree, copy, fallback_registry);
            }
        }

        // Step 6: If node is an element, node is shadow host, and shadow root is clonable, clone shadow
        if (node.node_type == Node.ELEMENT_NODE) {
            const elem: *const Element = @ptrCast(@alignCast(node));
            if (elem.shadow_root) |shadow| {
                // Check if shadow root is clonable
                if (shadow.clonable_flag) {
                    // Clone the shadow root per spec
                    const copy_elem: *Element = @ptrCast(@alignCast(copy));

                    // Assert: copy is not a shadow host (should be true since we just created it)
                    std.debug.assert(copy_elem.shadow_root == null);

                    // Step 6.2-6.4: Determine shadow root registry and attach shadow root
                    //
                    // Per spec (DOM §4.2.7):
                    // - If node's shadow root's custom element registry is non-null, use it
                    // - Otherwise, if fallbackRegistry is non-null, use fallbackRegistry
                    // - Otherwise, set registry to null
                    //
                    // NOTE: Custom element registry is part of the HTML spec, not DOM spec.
                    // Full implementation requires:
                    // - ShadowRoot.custom_element_registry field (currently not present)
                    // - CustomElementRegistry type and implementation
                    // - Registry scoping logic
                    //
                    // For now, we pass null for the registry. When custom elements are
                    // implemented, fallback_registry will be used here to determine the
                    // registry for the cloned shadow root.

                    // Attach shadow root to copy
                    var copy_shadow = try ShadowRoot.init(
                        copy.allocator,
                        copy_elem,
                        shadow.shadow_mode,
                        shadow.delegates_focus_flag,
                        shadow.slot_assignment_mode,
                        shadow.clonable_flag,
                        shadow.serializable_flag,
                        shadow.available_to_element_internals,
                        false, // declarative will be set next
                    );

                    // Step 6.5: Set copy's shadow root's declarative to node's shadow root's declarative
                    copy_shadow.declarative_flag = shadow.declarative_flag;

                    copy_elem.shadow_root = &copy_shadow;

                    // Step 6.6: Clone shadow root children
                    const shadow_node = shadow.asNode();
                    for (shadow_node.child_nodes.toSlice()) |child| {
                        const copy_shadow_node = copy_shadow.asNode();
                        _ = try Node.cloneNodeInternal(child, document, subtree, copy_shadow_node, null);
                    }
                }
            }
        }

        // Step 7: Return copy
        return copy;
    
    }

    /// Clone a single node - DOM Spec algorithm
    /// Creates a new node with the same properties but no children
    pub fn cloneSingleNode(
        node: *Node,
        document: ?*Document,
        fallback_registry: ?*anyopaque,
    ) !*Node {

        _ = fallback_registry; // Not used yet - for custom elements

        // Step 2-3: Handle different node types
        switch (node.node_type) {
            Node.ELEMENT_NODE => {
                // Clone element with attributes
                const elem: *Element = @ptrCast(@alignCast(node));

                // Create new element
                var copy_elem = try Element.init(elem.allocator, elem.tag_name);
                copy_elem.namespace_uri = elem.namespace_uri;

                // Clone attributes
                for (elem.attributes.toSlice()) |attr| {
                    const copy_attr = Attr{
                        // EventTarget fields
                        .event_listener_list = null,
                        // Node fields
                        .allocator = elem.allocator,
                        .node_type = 2, // ATTRIBUTE_NODE
                        .node_name = attr.local_name,
                        .parent_node = null,
                        .child_nodes = infra.List(*Node).init(elem.allocator),
                        .owner_document = null,
                        .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(elem.allocator),
                        .cloning_steps_hook = null,
                        .cached_child_nodes = null,
                        // Attr fields
                        .namespace_uri = attr.namespace_uri,
                        .prefix = attr.prefix,
                        .local_name = attr.local_name,
                        .value = attr.value,
                        .owner_element = &copy_elem,
                    };
                    try copy_elem.attributes.append(copy_attr);
                }

                const copy_node = @as(*Node, @ptrCast(&copy_elem));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Clone CharacterData (Text, Comment, CDATASection)
                const cd: *CharacterData = @ptrCast(@alignCast(node));

                var copy_cd = try CharacterData.init(cd.allocator);
                copy_cd.data = try cd.allocator.dupe(u8, cd.data);

                const copy_node = @as(*Node, @ptrCast(&copy_cd));
                copy_node.node_type = node.node_type;
                copy_node.node_name = node.node_name;
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.PROCESSING_INSTRUCTION_NODE => {
                // Clone ProcessingInstruction
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi: *PI = @ptrCast(@alignCast(node));

                var copy_pi = try PI.init(pi.allocator, pi.target, pi.data);

                const copy_node = @as(*Node, @ptrCast(&copy_pi));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.ATTRIBUTE_NODE => {
                // Clone Attr
                const attr: *Attr = @ptrCast(@alignCast(node));

                var copy_attr = try Attr.init(
                    attr.allocator,
                    attr.namespace_uri,
                    attr.prefix,
                    attr.local_name,
                    attr.value,
                );

                const copy_node = @as(*Node, @ptrCast(&copy_attr));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.DOCUMENT_TYPE_NODE => {
                // Clone DocumentType (simplified - full implementation needs public ID, system ID)
                const copy = try node.allocator.create(Node);
                copy.* = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_FRAGMENT_NODE => {
                // Clone DocumentFragment
                const copy = try node.allocator.create(Node);
                copy.* = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_NODE => {
                // Cloning Document is complex and not fully supported yet
                // For now, just create a basic copy
                const copy = try node.allocator.create(Node);
                copy.* = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            else => {
                // Default: create basic node copy
                const copy = try node.allocator.create(Node);
                copy.* = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
        }
    
    }

    /// normalize()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-normalize
    /// 
    /// Removes empty exclusive Text nodes and concatenates the data of remaining
    /// contiguous exclusive Text nodes into the first of their nodes.
    /// 
    /// The normalize() method steps are to run these steps for each descendant
    /// exclusive Text node `node` of this:
    /// 1. Let length be node's length
    /// 2. If length is zero, remove node and continue
    /// 3. Let data be concatenation of data of node's contiguous exclusive Text nodes (excluding itself)
    /// 4. Replace data with node, offset length, count 0, and data
    /// 5. Let currentNode be node's next sibling
    /// 6. While currentNode is exclusive Text node: update ranges and advance
    /// 7. Remove node's contiguous exclusive Text nodes (excluding itself)
    pub fn call_normalize(self: *Element) !void {
        const self_parent: *Node = @ptrCast(self);

        // Get all descendant exclusive Text nodes
        var text_nodes = infra.List(*Node).init(self_parent.allocator);
        defer text_nodes.deinit();

        try collectDescendantExclusiveTextNodes(self_parent, &text_nodes);

        // Process each exclusive Text node
        for (0..text_nodes.len) |i| {
            const node = text_nodes.get(i) orelse continue;
            // Step 1: Let length be node's length
            const cd: *CharacterData = @ptrCast(@alignCast(node));
            var length: usize = cd.data.len;

            // Step 2: If length is zero, remove node and continue
            if (length == 0) {
                // Remove the node from its parent
                if (node.parent_node) |_| {
                    const mutation = @import("dom").mutation;
                    _ = try mutation.remove(node, false);
                }
                continue;
            }

            // Step 3: Let data be concatenation of contiguous exclusive Text nodes (excluding itself)
            var contiguous_data = infra.List(u8).init(self_parent.allocator);
            defer contiguous_data.deinit();

            // Find next sibling exclusive Text nodes
            var next_sibling = node.get_nextSibling();
            while (next_sibling) |sibling| {
                if (isExclusiveTextNode(sibling)) {
                    const sibling_cd: *CharacterData = @ptrCast(@alignCast(sibling));
                    try contiguous_data.appendSlice(sibling_cd.data);
                    next_sibling = sibling.get_nextSibling();
                } else {
                    break;
                }
            }

            // Step 4: Replace data with node, offset length, count 0, and data
            // This appends the concatenated data to the current node's data
            if (contiguous_data.toSlice().len > 0) {
                try cd.call_replaceData(@intCast(length), 0, contiguous_data.toSlice());
            }

            // Step 5: Let currentNode be node's next sibling
            var current_node = node.get_nextSibling();

            // Step 6: While currentNode is an exclusive Text node
            while (current_node) |curr| {
                if (!isExclusiveTextNode(curr)) break;

                const curr_cd: *CharacterData = @ptrCast(@alignCast(curr));

                // Step 6.1-6.4: Update live ranges
                // Get owner document for range tracking
                if (node.owner_document) |doc| {
                    updateRangesForNormalize(doc, node, curr, @intCast(length));
                }

                // Step 6.5: Add currentNode's length to length
                length += curr_cd.data.len;

                // Step 6.6: Set currentNode to its next sibling
                const next = curr.get_nextSibling();
                current_node = next;
            }

            // Step 7: Remove node's contiguous exclusive Text nodes (excluding itself)
            // Go back through and remove all the adjacent text nodes we just merged
            var remove_node = node.get_nextSibling();
            while (remove_node) |rn| {
                if (!isExclusiveTextNode(rn)) break;

                const next_remove = rn.get_nextSibling();
                if (rn.parent_node) |_| {
                    const mutation = @import("dom").mutation;
                    _ = try mutation.remove(rn, false);
                }
                remove_node = next_remove;
            }
        }
    
    }

    /// Helper: Check if a node is an exclusive Text node
    /// An exclusive Text node is a Text node that is NOT a CDATASection node
    fn isExclusiveTextNode(node: *Node) bool {

        // Exclusive Text node = TEXT_NODE but not CDATA_SECTION_NODE
        return node.node_type == Node.TEXT_NODE;
    
    }

    /// Helper: Collect all descendant exclusive Text nodes in tree order
    fn collectDescendantExclusiveTextNodes(node: *Node, list: *infra.List(*Node)) !void {

        // Check if this node is an exclusive Text node
        if (isExclusiveTextNode(node)) {
            try list.append(node);
        }

        // Recursively collect from children
        for (0..node.child_nodes.len) |i| {
            const child = node.child_nodes.get(i) orelse continue;
            try collectDescendantExclusiveTextNodes(child, list);
        }
    
    }

    /// Helper: Update ranges during normalize operation
    /// Spec: DOM §4.2.5 normalize() step 6.1-6.4
    fn updateRangesForNormalize(doc: *Document, node: *Node, current_node: *Node, length: usize) void {

        // This requires access to document's live ranges list
        // The range tracking infrastructure is in src/dom/range_tracking.zig
        // For now, we'll add a helper function there

        // Get document's ranges (if the infrastructure exists)
        // Per spec step 6.1-6.4:
        // 1. For each live range whose start node is currentNode,
        //    add length to its start offset and set its start node to node
        // 2. For each live range whose end node is currentNode,
        //    add length to its end offset and set its end node to node
        // 3. For each live range whose start node is currentNode's parent
        //    and start offset is currentNode's index, set its start node to node
        //    and its start offset to length
        // 4. For each live range whose end node is currentNode's parent
        //    and end offset is currentNode's index, set its end node to node
        //    and its end offset to length

        _ = doc;
        _ = node;
        _ = current_node;
        _ = length;

        // TODO: Implement range updates once Range tracking is fully integrated
        // For now, this is a placeholder. Range tracking will be added when
        // Phase 5 (Range Operations) is implemented.
    
    }

    /// Getters
    pub fn get_nodeType(self: *const Element) u16 {
        const self_parent: *const Node = @ptrCast(self);

        return self_parent.node_type;
    
    }

    pub fn get_nodeName(self: *const Element) []const u8 {
        const self_parent: *const Node = @ptrCast(self);

        return self_parent.node_name;
    
    }

    pub fn get_parentNode(self: *const Element) ?*Node {
        const self_parent: *const Node = @ptrCast(self);

        return self_parent.parent_node;
    
    }

    pub fn get_parentElement(self: *const Element) ?*Element {
        const self_parent: *const Node = @ptrCast(self);

        // Returns parent if it's an Element, null otherwise
        const parent = self_parent.parent_node orelse return null;
        if (parent.node_type == ELEMENT_NODE) {
            // Cast to Element - safe because we checked node_type
            return @ptrCast(@alignCast(parent));
        }
        return null;
    
    }

    pub fn get_childNodes(self: *Element) !*@import("node_list").NodeList {
        const self_parent: *Node = @ptrCast(self);

        // [SameObject] - Return the same NodeList object each time
        // The NodeList is a live view of this node's children

        if (self_parent.cached_child_nodes) |list| {
            return list;
        }

        // Create new NodeList on first access
        const list = try self_parent.allocator.create(NodeList);
        list.* = try NodeList.init(self_parent.allocator);

        // Populate with current children (live view will track changes)
        for (self_parent.child_nodes.toSlice()) |child| {
            try list.addNode(child);
        }

        self_parent.cached_child_nodes = list;
        return list;
    
    }

    pub fn get_firstChild(self: *const Element) ?*Node {
        const self_parent: *const Node = @ptrCast(self);

        if (self_parent.child_nodes.len > 0) {
            return self_parent.child_nodes.get(0);
        }
        return null;
    
    }

    pub fn get_lastChild(self: *const Element) ?*Node {
        const self_parent: *const Node = @ptrCast(self);

        if (self_parent.child_nodes.len > 0) {
            return self_parent.child_nodes.get(self_parent.child_nodes.len - 1);
        }
        return null;
    
    }

    pub fn get_ownerDocument(self: *const Element) ?*Document {
        const self_parent: *const Node = @ptrCast(self);

        return self_parent.owner_document;
    
    }

    pub fn get_previousSibling(self: *const Element) ?*Node {
        const self_parent: *const Node = @ptrCast(self);

        const parent = self_parent.parent_node orelse return null;
        for (parent.child_nodes.toSlice(), 0..) |child, i| {
            if (child == self_parent) {
                if (i == 0) return null;
                return parent.child_nodes.toSlice()[i - 1];
            }
        }
        return null;
    
    }

    pub fn get_nextSibling(self: *const Element) ?*Node {
        const self_parent: *const Node = @ptrCast(self);

        const parent = self_parent.parent_node orelse return null;
        for (parent.child_nodes.toSlice(), 0..) |child, i| {
            if (child == self_parent) {
                if (i + 1 >= parent.child_nodes.toSlice().len) return null;
                return parent.child_nodes.toSlice()[i + 1];
            }
        }
        return null;
    
    }

    pub fn get_isConnected(self: *const Element) bool {
        const self_parent: *const Node = @ptrCast(self);

        // A node is connected if its root is a document
        const tree = @import("dom").tree;
        // tree.root requires mutable pointer but doesn't actually mutate
        // Cast to mutable for the algorithm (safe for read-only root traversal)
        const mutable_self = @constCast(self_parent);
        const root_node = tree.root(mutable_self);
        // Check if root is a document (node_type == DOCUMENT_NODE)
        return root_node.node_type == DOCUMENT_NODE;
    
    }

    /// DOM §4.4 - Node.baseURI getter
    /// Returns this's node document's document base URL, serialized.
    /// 
    /// The baseURI getter steps are to return this's node document's
    /// document base URL, serialized.
    pub fn get_baseURI(self: *const Element) []const u8 {
        const self_parent: *const Node = @ptrCast(self);

        // Get owner document
        const doc = self_parent.owner_document orelse {
            // If no owner document, return empty string (should not happen in normal DOM)
            return "about:blank";
        };

        // Return document's base URI
        return doc.base_uri;
    
    }

    pub fn get_nodeValue(self: *const Element) ?[]const u8 {
        const self_parent: *const Node = @ptrCast(self);

        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // The nodeValue getter steps are to return the following, switching on the interface:
        // - Attr: this's value
        // - CharacterData: this's data
        // - Otherwise: null

        switch (self_parent.node_type) {
            ATTRIBUTE_NODE => {
                // Attr node
                const attr: *const Attr = @ptrCast(@alignCast(self_parent));
                return attr.value;
            },
            TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE => {
                // CharacterData nodes (Text, Comment, ProcessingInstruction, CDATASection)
                const char_data: *const CharacterData = @ptrCast(@alignCast(self_parent));
                return char_data.data;
            },
            else => {
                // All other node types return null
                return null;
            },
        }
    
    }

    pub fn set_nodeValue(self: *Element, value: ?[]const u8) !void {
        const self_parent: *Node = @ptrCast(self);

        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // The nodeValue setter steps are to, if given value is null, act as if it was empty string
        // Then:
        // - Attr: Set an existing attribute value with this and the given value
        // - CharacterData: Replace data with node this, offset 0, count this's length, data given value
        // - Otherwise: Do nothing

        const str_value = value orelse "";

        switch (self_parent.node_type) {
            ATTRIBUTE_NODE => {
                // Attr node - set an existing attribute value
                const attr: *Attr = @ptrCast(@alignCast(self_parent));
                // Use "set an existing attribute value" algorithm from Attr
                try Attr.setExistingAttributeValue(attr, str_value);
            },
            TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE => {
                // CharacterData nodes - replace data
                const char_data: *CharacterData = @ptrCast(@alignCast(self_parent));
                // Replace data: offset 0, count = length, data = str_value
                try char_data.call_replaceData(0, @intCast(char_data.data.len), str_value);
            },
            else => {
                // All other node types do nothing
            },
        }
    
    }

    pub fn get_textContent(self: *const Element) !?[]const u8 {
        const self_parent: *const Node = @ptrCast(self);

        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // Return the result of running get text content with this
        return Node.getTextContent(self_parent, self_parent.allocator);
    
    }

    pub fn set_textContent(self: *Element, value: ?[]const u8) !void {
        const self_parent: *Node = @ptrCast(self);

        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // If the given value is null, act as if it was the empty string instead
        const str_value = value orelse "";
        try Node.setTextContent(self_parent, str_value);
    
    }

    /// Get text content - DOM Spec algorithm
    /// Returns text content based on node type
    /// For Element and DocumentFragment, the returned string is allocated and must be freed by caller
    /// For other types, returns a reference to existing data (no allocation)
    pub fn getTextContent(node: *const Node, allocator: std.mem.Allocator) !?[]const u8 {

        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // Return descendant text content (allocated)
                return Node.getDescendantTextContent(node, allocator);
            },
            Node.ATTRIBUTE_NODE => {
                // Return node's value (no allocation - returns reference)
                const attr: *const Attr = @ptrCast(@alignCast(node));
                return attr.value;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE, Node.PROCESSING_INSTRUCTION_NODE => {
                // Return node's data (no allocation - returns reference)
                const cd: *const CharacterData = @ptrCast(@alignCast(node));
                return cd.data;
            },
            else => {
                // Document, DocumentType: return null
                return null;
            },
        }
    
    }

    /// Get descendant text content - concatenate all Text node descendants
    /// Spec: https://dom.spec.whatwg.org/#concept-descendant-text-content
    /// Returns the concatenation of data from all Text node descendants in tree order.
    /// Caller owns the returned memory and must free it.
    pub fn getDescendantTextContent(node: *const Node, allocator: std.mem.Allocator) ![]const u8 {

        var result = infra.List(u8).init(allocator);
        errdefer result.deinit();

        try collectDescendantText(node, &result);

        return result.toOwnedSlice();
    
    }

    /// Helper function to recursively collect text from descendants
    fn collectDescendantText(node: *const Node, result: *infra.List(u8)) !void {

        // If this is a Text node, collect its data
        if (node.node_type == Node.TEXT_NODE) {
            const cd: *const CharacterData = @ptrCast(@alignCast(node));
            try result.appendSlice(cd.data);
        }

        // Recursively process all children
        for (0..node.child_nodes.len) |i| {
            if (node.child_nodes.get(i)) |child| {
                try collectDescendantText(child, result);
            }
        }
    
    }

    /// Set text content - DOM Spec algorithm
    /// Sets text content based on node type
    pub fn setTextContent(node: *Node, value: []const u8) !void {

        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // String replace all with value within node
                try Node.stringReplaceAll(node, value);
            },
            Node.ATTRIBUTE_NODE => {
                // Set an existing attribute value
                const attr: *Attr = @ptrCast(@alignCast(node));
                // Use "set an existing attribute value" algorithm from Attr
                try Attr.setExistingAttributeValue(attr, value);
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Replace data with node, offset 0, count node's length, and data value
                const cd: *CharacterData = @ptrCast(@alignCast(node));
                const length = @as(u32, @intCast(cd.data.len));
                try cd.replaceData(0, length, value);
            },
            else => {
                // Document, DocumentType, etc: do nothing
            },
        }
    
    }

    /// String replace all - DOM Spec algorithm
    /// Replace all children with a single text node containing string
    pub fn stringReplaceAll(parent: *Node, string: []const u8) !void {

        // Step 1: Let node be null
        var node_opt: ?*Node = null;

        // Step 2: If string is not the empty string, create a new Text node
        if (string.len > 0) {
            var text_node = try Text.init(parent.allocator);

            const cd: *CharacterData = @ptrCast(@alignCast(&text_node));
            cd.data = try parent.allocator.dupe(u8, string);

            const new_node: *Node = @ptrCast(&text_node);
            new_node.owner_document = parent.owner_document;
            node_opt = new_node;
        }

        // Step 3: Replace all with node within parent
        const mutation = @import("dom").mutation;
        try mutation.replaceAll(node_opt, parent);
    
    }

    /// lookupPrefix(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupprefix
    pub fn call_lookupPrefix(self: *const Element, namespace_param: ?[]const u8) ?[]const u8 {
        const self_parent: *const Node = @ptrCast(self);

        // Spec step 1: If namespace is null or empty, return null
        const namespace = namespace_param orelse return null;
        if (namespace.len == 0) return null;

        // Spec step 2: Switch on node type
        switch (self_parent.node_type) {
            ELEMENT_NODE => {
                // Return result of locating a namespace prefix
                return self.locateNamespacePrefix(namespace);
            },
            DOCUMENT_NODE => {
                // If document element is null, return null
                const doc: *const Document = @ptrCast(@alignCast(self_parent));
                const doc_elem = doc.documentElement() orelse return null;
                return doc_elem.base.locateNamespacePrefix(namespace);
            },
            DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE => {
                return null;
            },
            else => {
                // For other node types, use parent element if exists
                const parent = self_parent.parent_element orelse return null;
                return parent.base.locateNamespacePrefix(namespace);
            },
        }
    
    }

    /// lookupNamespaceURI(prefix)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
    pub fn call_lookupNamespaceURI(self: *const Element, prefix_param: ?[]const u8) ?[]const u8 {

        // Spec step 1: If prefix is empty string, set to null
        const prefix = if (prefix_param) |p| if (p.len == 0) null else p else null;

        // Spec step 2: Return result of locating a namespace
        return self.locateNamespace(prefix);
    
    }

    /// isDefaultNamespace(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
    pub fn call_isDefaultNamespace(self: *const Element, namespace_param: ?[]const u8) bool {

        // Spec step 1: If namespace is empty string, set to null
        const namespace = if (namespace_param) |ns| if (ns.len == 0) null else ns else null;

        // Spec step 2: Let defaultNamespace be result of locating namespace using null prefix
        const default_namespace = self.locateNamespace(null);

        // Spec step 3: Return true if defaultNamespace equals namespace
        if (default_namespace == null and namespace == null) return true;
        if (default_namespace == null or namespace == null) return false;
        return std.mem.eql(u8, default_namespace.?, namespace.?);
    
    }

    /// Locate a namespace prefix for element (internal algorithm)
    /// Spec: https://dom.spec.whatwg.org/#locate-a-namespace-prefix
    fn locateNamespacePrefix(self: *const Element, namespace: []const u8) ?[]const u8 {
        const self_parent: *const Node = @ptrCast(self);

        if (self_parent.node_type != ELEMENT_NODE) return null;

        const elem: *const Element = @ptrCast(@alignCast(self_parent));

        // Step 1: If element's namespace is namespace and prefix is non-null, return prefix
        if (elem.namespace_uri) |ns| {
            if (std.mem.eql(u8, ns, namespace)) {
                if (elem.prefix) |p| return p;
            }
        }

        // Step 2: If element has attribute with prefix "xmlns" and value namespace, return local name
        for (elem.attributes.toSlice()) |attr| {
            if (attr.prefix) |attr_prefix| {
                if (std.mem.eql(u8, attr_prefix, "xmlns") and std.mem.eql(u8, attr.value, namespace)) {
                    return attr.local_name;
                }
            }
        }

        // Step 3: If parent element exists, recurse
        if (self_parent.parent_element) |parent| {
            return parent.base.locateNamespacePrefix(namespace);
        }

        // Step 4: Return null
        return null;
    
    }

    /// Locate a namespace for node (internal algorithm)
    /// Spec: https://dom.spec.whatwg.org/#locate-a-namespace
    fn locateNamespace(self: *const Element, prefix: ?[]const u8) ?[]const u8 {
        const self_parent: *const Node = @ptrCast(self);

        switch (self_parent.node_type) {
            ELEMENT_NODE => {
                const elem: *const Element = @ptrCast(@alignCast(self_parent));

                // Step 1: If prefix is "xml", return XML namespace
                if (prefix) |p| {
                    if (std.mem.eql(u8, p, "xml")) {
                        return "http://www.w3.org/XML/1998/namespace";
                    }
                    // Step 2: If prefix is "xmlns", return XMLNS namespace
                    if (std.mem.eql(u8, p, "xmlns")) {
                        return "http://www.w3.org/2000/xmlns/";
                    }
                }

                // Step 3: If namespace is non-null and prefix matches, return namespace
                if (elem.namespace_uri) |ns| {
                    if ((prefix == null and elem.prefix == null) or
                        (prefix != null and elem.prefix != null and std.mem.eql(u8, prefix.?, elem.prefix.?)))
                    {
                        return ns;
                    }
                }

                // Step 4: Check for xmlns attributes
                // If it has an attribute whose namespace is XMLNS namespace, prefix is "xmlns",
                // and local name is prefix, return its value if not empty string, else null.
                // Or if prefix is null and it has an attribute whose namespace is XMLNS namespace,
                // prefix is null, and local name is "xmlns", return its value if not empty, else null.
                for (elem.attributes.toSlice()) |attr| {
                    const xmlns_ns = "http://www.w3.org/2000/xmlns/";

                    if (attr.namespace_uri) |attr_ns| {
                        if (std.mem.eql(u8, attr_ns, xmlns_ns)) {
                            // Check if this matches our prefix
                            if (prefix) |p| {
                                // Looking for xmlns:prefix attribute
                                if (attr.prefix) |attr_prefix| {
                                    if (std.mem.eql(u8, attr_prefix, "xmlns") and std.mem.eql(u8, attr.local_name, p)) {
                                        return if (attr.value.len > 0) attr.value else null;
                                    }
                                }
                            } else {
                                // Looking for xmlns attribute (default namespace)
                                if (attr.prefix == null and std.mem.eql(u8, attr.local_name, "xmlns")) {
                                    return if (attr.value.len > 0) attr.value else null;
                                }
                            }
                        }
                    }
                }

                // Step 5: If parent element is null, return null
                const parent = self_parent.parent_element orelse return null;

                // Step 6: Return result of locating namespace on parent
                return parent.base.locateNamespace(prefix);
            },
            DOCUMENT_NODE => {
                // Step 1: If document element is null, return null
                const doc: *const Document = @ptrCast(@alignCast(self_parent));
                const doc_elem = doc.documentElement() orelse return null;

                // Step 2: Return result of locating namespace on document element
                return doc_elem.base.locateNamespace(prefix);
            },
            DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE => {
                return null;
            },
            ATTRIBUTE_NODE => {
                // Step 1: If element is null, return null
                const AttributeType = @import("attr").Attr;
                const attr: *const AttributeType = @ptrCast(@alignCast(self_parent));
                const element = attr.owner_element orelse return null;

                // Step 2: Return result of locating namespace on element
                return element.base.locateNamespace(prefix);
            },
            else => {
                // Step 1: If parent element is null, return null
                const parent = self_parent.parent_element orelse return null;

                // Step 2: Return result of locating namespace on parent
                return parent.base.locateNamespace(prefix);
            },
        }
    
    }

    /// Get the list of registered observers for this node
    pub fn getRegisteredObservers(self: *Element) *infra.List(RegisteredObserver) {
        const self_parent: *Node = @ptrCast(self);

        return &self_parent.registered_observers;
    
    }

    /// Add a registered observer to this node's list
    pub fn addRegisteredObserver(self: *Element, registered: RegisteredObserver) !void {
        const self_parent: *Node = @ptrCast(self);

        try self_parent.registered_observers.append(registered);
    
    }

    /// Remove all registered observers for a specific MutationObserver
    pub fn removeRegisteredObserver(self: *Element, observer: *const @import("mutation_observer").MutationObserver) void {
        const self_parent: *Node = @ptrCast(self);

        var i: usize = 0;
        while (i < self_parent.registered_observers.toSlice().len) {
            if (self_parent.registered_observers.toSlice()[i].observer == observer) {
                _ = self_parent.registered_observers.orderedRemove(i);
                // Don't increment i, we just shifted everything down
            } else {
                i += 1;
            }
        }
    
    }

    /// Remove all transient registered observers whose source matches the given registered observer
    /// 
    /// Spec: Used during MutationObserver.observe() to clean up old transient observers
    /// when re-observing a node with updated options.
    pub fn removeTransientObservers(self: *Element, source: *const RegisteredObserver) void {
        const self_parent: *Node = @ptrCast(self);

        // Note: In our current implementation, we don't have a way to distinguish
        // transient observers from regular ones in the registered_observers list.
        // This would require either:
        // 1. A separate transient_observers list, OR
        // 2. Wrapping RegisteredObserver in a tagged union
        //
        // For now, this is a no-op. Transient observers are not yet fully implemented.
        // When they are, they should be stored separately or tagged so we can identify
        // and remove them here.
        _ = self_parent;
        _ = source;
    
    }

    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *Element) !*infra.List(EventListener) {
        const self_parent: *EventTarget = @ptrCast(self);

        if (self_parent.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self_parent.allocator.create(infra.List(EventListener));
        list.* = infra.List(EventListener).init(self_parent.allocator);
        self_parent.event_listener_list = list;
        return list;
    
    }

    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const Element) []const EventListener {
        const self_parent: *const EventTarget = @ptrCast(self);

        if (self_parent.event_listener_list) |list| {
            return list.toSlice();
        }
        return &[_]EventListener{};
    
    }

    /// DOM §2.7 - flatten options
    /// To flatten options, run these steps:
    /// 1. If options is a boolean, then return options.
    /// 2. Return options["capture"].
    fn flattenOptions(options: anytype) bool {

        const OptionsType = @TypeOf(options);

        // Step 1: If options is a boolean, return it
        if (OptionsType == bool) {
            return options;
        }

        // Step 2: If it's EventListenerOptions or AddEventListenerOptions, return capture field
        if (@hasField(OptionsType, "capture")) {
            return options.capture;
        }

        // Default: return false
        return false;
    
    }

    /// DOM §2.7 - flatten more options
    /// Returns: capture, passive, once, signal
    fn flattenMoreOptions(options: anytype) struct { capture: bool, passive: ?bool, once: bool, signal: ?*AbortSignal } {

        const OptionsType = @TypeOf(options);

        // If options is a boolean, only capture is set to that value
        if (OptionsType == bool) {
            return .{
                .capture = options,
                .passive = null,
                .once = false,
                .signal = null,
            };
        }

        // If options is AddEventListenerOptions dictionary, extract all fields
        if (@hasField(OptionsType, "capture")) {
            return .{
                .capture = if (@hasField(OptionsType, "capture")) options.capture else false,
                .passive = if (@hasField(OptionsType, "passive")) options.passive else null,
                .once = if (@hasField(OptionsType, "once")) options.once else false,
                .signal = if (@hasField(OptionsType, "signal")) options.signal else null,
            };
        }

        // Default: return all defaults
        return .{
            .capture = false,
            .passive = null,
            .once = false,
            .signal = null,
        };
    
    }

    /// DOM §2.7 - default passive value
    /// The default passive value, given an event type type and an EventTarget eventTarget
    fn defaultPassiveValue(event_type: []const u8, event_target: *EventTarget) bool {

        _ = event_target;
        // Step 1: Return true if type is touchstart, touchmove, wheel, or mousewheel
        // AND eventTarget is Window or specific node conditions
        // For now, simplified: return true for touch/wheel events
        if (std.mem.eql(u8, event_type, "touchstart") or
            std.mem.eql(u8, event_type, "touchmove") or
            std.mem.eql(u8, event_type, "wheel") or
            std.mem.eql(u8, event_type, "mousewheel"))
        {
            // TODO: Check eventTarget conditions per spec
            return true;
        }
        // Step 2: Return false
        return false;
    
    }

    /// DOM §2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *Element, listener: EventListener) !void {
        const self_parent: *EventTarget = @ptrCast(self);

        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self_parent);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        var already_exists = false;
        var i: usize = 0;
        while (i < list.len) : (i += 1) {
            const existing = list.get(i).?;
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                already_exists = true;
                break;
            }
        }

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        // Spec: "If listener's signal is not null, then add the following abort steps to it:
        // Remove an event listener with eventTarget and listener."
        // https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
        if (listener.signal) |signal| {
            const AbortSignalType = @import("abort_signal").AbortSignal;
            const removal_context = AbortSignalType.EventListenerRemovalContext{
                .target = self_parent,
                .listener_type = updated_listener.type,
                .listener_callback = updated_listener.callback,
                .listener_capture = updated_listener.capture,
            };
            try signal.addEventListenerRemoval(removal_context);
        }
    
    }

    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *Element,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {

        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    
    }

    /// DOM §2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *Element, listener: EventListener) void {
        const self_parent: *EventTarget = @ptrCast(self);

        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self_parent.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        const slice = list.toSliceMut();
        while (i < list.len) {
            const existing = &slice[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                existing.removed = true;
                _ = list.remove(i) catch unreachable; // infra.List.remove returns !T, but we know index is valid
                return;
            }
            i += 1;
        }
    
    }

    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *Element,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {

        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    
    }

    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *Element, event: *Event) !bool {
        const self_parent: *EventTarget = @ptrCast(self);

        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this using full dispatch algorithm
        const event_dispatch = @import("dom").event_dispatch;
        return event_dispatch.dispatch(event, self_parent, false, null) catch |err| {
            // Handle dispatch errors
            return err;
        };
    
    }

};


