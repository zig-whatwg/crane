// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Element interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-element

const std = @import("std");
const webidl = @import("webidl");
pub const dom = @import("dom");

pub const NodeList = @import("node_list").NodeList;
pub const dom_types = @import("dom_types");
/// Element WebIDL interface
/// DOM Spec: interface Element : Node
const NodeBase = @import("node").NodeBase;
const EventListener = @import("event_target").EventListener;
const Event = @import("event").Event;
const flattenOptions = @import("event_target").flattenOptions;
const flattenMoreOptions = @import("event_target").flattenMoreOptions;
const defaultPassiveValue = @import("event_target").defaultPassiveValue;
const callbackEquals = @import("event_target").callbackEquals;
const Node = @import("node").Node;
const Allocator = std.mem.Allocator;
const infra = @import("infra");
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const GetRootNodeOptions = @import("node").GetRootNodeOptions;
const Document = @import("document").Document;
const ELEMENT_NODE = @import("node").ELEMENT_NODE;
const DOCUMENT_NODE = @import("node").DOCUMENT_NODE;
const DOCUMENT_POSITION_DISCONNECTED = @import("node").DOCUMENT_POSITION_DISCONNECTED;
const ChildNode = @import("child_node").ChildNode;
const NonDocumentTypeChildNode = @import("non_document_type_child_node").NonDocumentTypeChildNode;
const ParentNode = @import("parent_node").ParentNode;
const Slottable = @import("slottable").Slottable;
pub const Element = struct {
    base: NodeBase,

    // ========================================================================
    // Fields from Slottable mixin
    // ========================================================================
    /// Slottable name (from "slot" attribute)
    slottable_name: []const u8 = "",
    /// Currently assigned slot (null if not assigned)
    /// TODO: Implement when HTMLSlotElement is available
    assigned_slot: ?*anyopaque = null,
    /// Manual slot assignment (for manual slot assignment mode)
    /// TODO: Implement when HTMLSlotElement is available
    /// Should use weak reference per spec
    manual_slot_assignment: ?*anyopaque = null,

    // ========================================================================
    // Element fields
    // ========================================================================
    allocator: Allocator,
    tag_name: []const u8,
    namespace_uri: ?[]const u8,
    attributes: infra.List(Attr),
    /// Shadow root attached to this element (null if not a shadow host)
    shadow_root: ?*ShadowRoot,

    pub const includes = .{ ChildNode, NonDocumentTypeChildNode, ParentNode, Slottable };
    pub const Attr = @import("attr").Attr;
    pub const ShadowRoot = @import("shadow_root").ShadowRoot;
    pub const ShadowRootInit = @import("shadow_root_init").ShadowRootInit;
    pub const DOMTokenList = @import("dom_token_list").DOMTokenList;
    pub const HTMLCollection = @import("html_collection").HTMLCollection;
    pub const Text = @import("text").Text;

    pub fn init(allocator: Allocator, tag_name: []const u8) !Element {
        // NOTE: Parent Node fields will be flattened by codegen
        return .{
            .base = NodeBase.initForElement(allocator),
            .allocator = allocator,
            .tag_name = tag_name,
            .namespace_uri = null,
            .attributes = infra.List(Attr).init(allocator),
            .shadow_root = null,
        };
    }
    pub fn deinit(self: *Element) void {
        // NOTE: Parent Node cleanup is handled by codegen
        self.attributes.deinit();

        // Free namespace_uri if allocated
        if (self.namespace_uri) |ns| {
            self.allocator.free(ns);
        }
    
        
        // Clean up base fields
        if (self.base.event_listener_list) |list| {
            list.deinit(self.allocator);
            self.allocator.destroy(list);
        }
        self.base.child_nodes.deinit();
        self.base.registered_observers.deinit();
}

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to NodeBase for type-generic code.
    pub fn toBase(self: *Element) *NodeBase {
        return &self.base;
    }


    // ========================================================================
    // Methods from ChildNode mixin
    // ========================================================================

    /// DOM §4.3.4 - ChildNode.before()
    /// Inserts nodes just before this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If viablePreviousSibling is null, then set it to parent's first child; otherwise to viablePreviousSibling's next sibling.
    /// 6. Pre-insert node into parent before viablePreviousSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_before(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null
        var viable_previous_sibling: ?*NodeType = null;

        // Walk backwards through siblings to find first one not in nodes
        var current = this_node.get_previousSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_previous_sibling = sibling;
                break;
            }

            current = sibling.get_previousSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try Element.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If viablePreviousSibling is null, set it to parent's first child;
        // otherwise to viablePreviousSibling's next sibling
        const reference_child = if (viable_previous_sibling) |vps|
            vps.get_nextSibling()
        else
            parent.?.get_firstChild();

        // Step 6: Pre-insert node into parent before viablePreviousSibling
        _ = try mutation.preInsert(node, parent.?, reference_child);
    }
    /// DOM §4.3.4 - ChildNode.after()
    /// Inserts nodes just after this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. Pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_after(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try Element.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: Pre-insert node into parent before viableNextSibling
        _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
    }
    /// DOM §4.3.4 - ChildNode.replaceWith()
    /// Replaces this node with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If this's parent is parent, replace this with node within parent.
    /// 6. Otherwise, pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_replaceWith(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try Element.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If this's parent is parent, replace this with node within parent
        // Note: The parent could have changed during convertNodesIntoNode if one of the nodes
        // contained 'this' in its subtree
        if (this_node.parent_node == parent) {
            try mutation.replace(this_node, node, parent.?);
        } else {
            // Step 6: Otherwise, pre-insert node into parent before viableNextSibling
            _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
        }
    }
    /// DOM §4.3.4 - ChildNode.remove()
    /// Removes this node from its parent.
    /// 
    /// Steps:
    /// 1. If this's parent is null, then return.
    /// 2. Remove this.
    /// (Included from ChildNode mixin)
    pub fn call_remove(self: anytype) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const node = @as(*NodeType, @ptrCast(self));

        // Step 1: If this's parent is null, then return
        if (node.parent_node == null) {
            return;
        }

        // Step 2: Remove this
        try mutation.remove(node, false);
    }
    // ========================================================================
    // Methods from NonDocumentTypeChildNode mixin
    // ========================================================================

    /// DOM §4.3.3 - NonDocumentTypeChildNode.previousElementSibling
    /// Returns the first preceding sibling that is an element; otherwise null.
    /// 
    /// The previousElementSibling getter steps are to return the first preceding
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn previousElementSibling(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        var i: usize = parent.child_nodes.items.len;
        while (i > 0) {
            i -= 1;
            const sibling = parent.child_nodes.items[i];

            if (sibling == @as(*NodeType, @ptrCast(self))) {
                found_self = true;
                continue;
            }

            // Only look at siblings before us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    }
    /// DOM §4.3.3 - NonDocumentTypeChildNode.nextElementSibling
    /// Returns the first following sibling that is an element; otherwise null.
    /// 
    /// The nextElementSibling getter steps are to return the first following
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn nextElementSibling(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        for (parent.child_nodes.items) |sibling| {
            if (sibling == @as(*NodeType, @ptrCast(self))) {
                found_self = true;
                continue;
            }

            // Only look at siblings after us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    }
    // ========================================================================
    // Methods from ParentNode mixin
    // ========================================================================

    /// DOM §4.3.2 - ParentNode.children
    /// Returns the child elements.
    /// 
    /// The children getter steps are to return an HTMLCollection collection rooted
    /// at this matching only element children.
    /// 
    /// NOTE: This is a simplified implementation that returns a static snapshot.
    /// A full implementation would return a live HTMLCollection that updates
    /// automatically when the DOM changes.
    /// (Included from ParentNode mixin)
    pub fn get_children(self: anytype) !*HTMLCollection {
        const NodeType = @import("node").Node;
        const allocator = self.allocator;

        // Create HTMLCollection
        const collection = try allocator.create(HTMLCollection);
        collection.* = try HTMLCollection.init(allocator);

        // Filter child_nodes for elements only (ELEMENT_NODE = 1)
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                const element: *Element = @ptrCast(child);
                try collection.addElement(element);
            }
        }

        return collection;
    }
    /// DOM §4.3.2 - ParentNode.firstElementChild
    /// Returns the first child that is an element; otherwise null.
    /// 
    /// The firstElementChild getter steps are to return the first child that is
    /// an element; otherwise null.
    /// (Included from ParentNode mixin)
    pub fn get_firstElementChild(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in tree order
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    }
    /// DOM §4.3.2 - ParentNode.lastElementChild
    /// Returns the last child that is an element; otherwise null.
    /// 
    /// The lastElementChild getter steps are to return the last child that is
    /// an element; otherwise null.
    /// (Included from ParentNode mixin)
    pub fn get_lastElementChild(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in reverse tree order
        var i: usize = self.child_nodes.items.len;
        while (i > 0) {
            i -= 1;
            const child = self.child_nodes.items[i];
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    }
    /// DOM §4.3.2 - ParentNode.childElementCount
    /// Returns the number of children that are elements.
    /// 
    /// The childElementCount getter steps are to return the number of children
    /// of this that are elements.
    /// (Included from ParentNode mixin)
    pub fn get_childElementCount(self: anytype) u32 {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Count children that are Elements
        var count: u32 = 0;
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                count += 1;
            }
        }

        return count;
    }
    /// DOM §4.3.2 - ParentNode.prepend()
    /// Inserts nodes before the first child, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Pre-insert node into this before this's first child.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ParentNode mixin)
    pub fn call_prepend(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Pre-insert node into this before this's first child
        const first_child = this_node.get_firstChild();
        _ = try mutation.preInsert(node, this_node, first_child);
    }
    /// DOM §4.3.2 - ParentNode.append()
    /// Inserts nodes after the last child, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Append node to this.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ParentNode mixin)
    pub fn call_append(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Append node to this
        _ = try mutation.append(node, this_node);
    }
    /// DOM §4.3.2 - ParentNode.replaceChildren()
    /// Replaces all children with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Ensure pre-insert validity of node into this before null.
    /// 3. Replace all with node within this.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ParentNode mixin)
    pub fn call_replaceChildren(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Ensure pre-insert validity of node into this before null
        try mutation.ensurePreInsertValidity(node, this_node, null);

        // Step 3: Replace all with node within this
        try mutation.replaceAll(node, this_node);
    }
    /// DOM §4.3.2 - ParentNode.moveBefore()
    /// Moves, without first removing, movedNode into this after child.
    /// This method preserves state associated with movedNode.
    /// 
    /// Steps:
    /// 1. Let referenceChild be child.
    /// 2. If referenceChild is node, then set referenceChild to node's next sibling.
    /// 3. Move node into this before referenceChild.
    /// 
    /// Throws HierarchyRequestError if constraints violated, or state cannot be preserved.
    /// (Included from ParentNode mixin)
    pub fn call_moveBefore(self: anytype, node: anytype, child: anytype) !void {
        _ = self;
        _ = node;
        _ = child;
        // TODO: Implement DOM §4.3.2 moveBefore() algorithm
        // Step 1: Set referenceChild to child
        // Step 2: If referenceChild is node, adjust to node's next sibling
        // Step 3: Call move algorithm (from mutation.zig - when implemented)
        @panic("ParentNode.moveBefore() not yet implemented");
    }
    /// DOM §4.3.2 - ParentNode.querySelector()
    /// Returns the first element that is a descendant of this that matches selectors.
    /// 
    /// The querySelector(selectors) method steps are to return the first result of
    /// running scope-match a selectors string selectors against this, if the result
    /// is not an empty list; otherwise null.
    /// 
    /// Uses Selectors mock (basic support only).
    /// (Included from ParentNode mixin)
    pub fn call_querySelector(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !?*Element {
        // Run scope-match a selectors string against this
        const matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Return first result if not empty; otherwise null
        if (matches.items.len > 0) {
            return matches.items[0];
        }

        return null;
    }
    /// DOM §4.3.2 - ParentNode.querySelectorAll()
    /// Returns all element descendants of this that match selectors.
    /// 
    /// The querySelectorAll(selectors) method steps are to return the static result
    /// of running scope-match a selectors string selectors against this.
    /// 
    /// Uses Selectors mock (basic support only).
    /// (Included from ParentNode mixin)
    pub fn call_querySelectorAll(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !*NodeList {
        // Run scope-match a selectors string against this
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Create NodeList and populate with matches (static snapshot)
        var node_list = try allocator.create(NodeList);
        node_list.* = try NodeList.init(allocator);

        // Add all matched elements to the NodeList
        for (matches.items) |element| {
            // Cast Element to Node
            const node = @as(*@import("node").Node, @ptrCast(element));
            try node_list.addNode(node);
        }

        return node_list;
    }
    // ========================================================================
    // Methods from Slottable mixin
    // ========================================================================

    /// DOM §4.3.7 - Slottable.assignedSlot
    /// 
    /// Returns the slot element this slottable is assigned to, if any.
    /// Returns null if not assigned or if the shadow root is closed.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-slottable-assignedslot
    /// (Included from Slottable mixin)
    pub fn get_assignedSlot(self: *const @This()) ?*anyopaque {
        // The assignedSlot getter steps are to return the result of
        // find a slot given this and true (open flag)

        // TODO: Implement findSlot algorithm from shadow_dom_algorithms
        // For now, return the assigned slot if it exists
        // The "open" parameter means we only return slots in open shadow roots

        _ = self;
        return null; // TODO: Implement when slot algorithms are available
    }

    // ========================================================================
    // Internal Methods
    // ========================================================================

    /// Get the slottable name
    pub fn getSlottableName(self: *const @This()) []const u8 {
        return self.slottable_name;
    }
    /// Set the slottable name
    /// (Included from Slottable mixin)
    pub fn setSlottableName(self: *@This(), name: []const u8) void {
        self.slottable_name = name;
    }
    /// Check if this slottable is assigned
    /// (Included from Slottable mixin)
    pub fn isAssigned(self: *const @This()) bool {
        return self.assigned_slot != null;
    }
    /// Set the assigned slot
    /// (Included from Slottable mixin)
    pub fn setAssignedSlot(self: *@This(), slot: ?*anyopaque) void {
        self.assigned_slot = slot;
    }
    /// Set the manual slot assignment
    /// (Included from Slottable mixin)
    pub fn setManualSlotAssignment(self: *@This(), slot: ?*anyopaque) void {
        self.manual_slot_assignment = slot;
    }
    // ========================================================================
    // Element methods
    // ========================================================================

    /// getAttribute(qualifiedName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-getattribute
    pub fn call_getAttribute(self: *const Element, qualified_name: []const u8) ?[]const u8 {
        for (self.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, qualified_name)) {
                return attr.value;
            }
        }
        return null;
    }
    /// setAttribute(qualifiedName, value)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-setattribute
    pub fn call_setAttribute(self: *Element, qualified_name: []const u8, value: []const u8) !void {
        for (self.attributes.items) |*attr| {
            if (std.mem.eql(u8, attr.name, qualified_name)) {
                attr.value = value;
                return;
            }
        }
        try self.attributes.append(Attr{
            .name = qualified_name,
            .value = value,
        });
    }
    /// removeAttribute(qualifiedName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-removeattribute
    pub fn call_removeAttribute(self: *Element, qualified_name: []const u8) void {
        for (self.attributes.items, 0..) |attr, i| {
            if (std.mem.eql(u8, attr.name, qualified_name)) {
                _ = self.attributes.orderedRemove(i);
                return;
            }
        }
    }
    /// hasAttribute(qualifiedName)
    /// Spec: https://dom.spec.whatwg.org/#dom-element-hasattribute
    pub fn call_hasAttribute(self: *const Element, qualified_name: []const u8) bool {
        for (self.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, qualified_name)) {
                return true;
            }
        }
        return false;
    }
    /// DOM §4.10.1 - Element.id
    /// The id getter steps are to return the value of this's id content attribute.
    /// The id setter steps are to set the value of this's id content attribute to the given value.
    pub fn get_id(self: *const Element) []const u8 {
        return self.call_getAttribute("id") orelse "";
    }
    pub fn set_id(self: *Element, value: []const u8) !void {
        try self.call_setAttribute("id", value);
    }
    /// DOM §4.10.1 - Element.className
    /// The className getter steps are to return the value of this's class content attribute.
    /// The className setter steps are to set the value of this's class content attribute to the given value.
    pub fn get_className(self: *const Element) []const u8 {
        return self.call_getAttribute("class") orelse "";
    }
    pub fn set_className(self: *Element, value: []const u8) !void {
        try self.call_setAttribute("class", value);
    }
    /// DOM §4.10.1 - Element.classList
    /// The classList getter steps are to return a DOMTokenList object whose associated element
    /// is this and whose associated attribute's local name is class.
    /// 
    /// Returns a DOMTokenList representing the class attribute.
    /// The DOMTokenList is [SameObject] - should return same instance on repeated calls.
    /// TODO: Implement [SameObject] caching
    pub fn get_classList(self: *const Element) !*DOMTokenList {
        const TokenList = @import("dom_token_list").DOMTokenList;

        // Create DOMTokenList associated with this element's "class" attribute
        const token_list = try self.allocator.create(TokenList);
        token_list.* = try TokenList.init(self.allocator, @constCast(self), "class");

        // Parse current class attribute value into tokens
        const class_value = self.call_getAttribute("class") orelse "";
        if (class_value.len > 0) {
            var iter = std.mem.tokenizeScalar(u8, class_value, ' ');
            while (iter.next()) |token| {
                // Skip empty tokens
                if (token.len == 0) continue;

                const token_copy = try self.allocator.dupe(u8, token);
                try token_list.tokens.append(token_copy);
            }
        }

        return token_list;
    }
    /// DOM §4.10.1 - Element.slot
    /// The slot getter steps are to return the value of this's slot content attribute.
    /// The slot setter steps are to set the value of this's slot content attribute to the given value.
    pub fn get_slot(self: *const Element) []const u8 {
        return self.call_getAttribute("slot") orelse "";
    }
    pub fn set_slot(self: *Element, value: []const u8) !void {
        try self.call_setAttribute("slot", value);
    }
    /// Getters
    pub fn get_tagName(self: *const Element) []const u8 {
        return self.tag_name;
    }
    pub fn get_namespaceURI(self: *const Element) ?[]const u8 {
        return self.namespace_uri;
    }
    /// DOM §4.10.5 - Element.getElementsByTagName(qualifiedName)
    /// Returns an HTMLCollection of all descendant elements whose qualified name is qualifiedName.
    /// If qualifiedName is "*", returns all descendant elements.
    /// TODO: Implement when HTMLCollection is available
    pub fn call_getElementsByTagName(self: *const Element, qualified_name: []const u8) !*HTMLCollection {
        _ = self;
        _ = qualified_name;
        return error.NotImplemented;
    }
    /// DOM §4.10.5 - Element.getElementsByTagNameNS(namespace, localName)
    /// Returns an HTMLCollection of all descendant elements matching the namespace and local name.
    /// If namespace is "*", matches any namespace.
    /// If localName is "*", matches any local name.
    /// If both are "*", returns all descendant elements.
    /// TODO: Implement when HTMLCollection is available
    pub fn call_getElementsByTagNameNS(
        self: *const Element,
        namespace: ?[]const u8,
        local_name: []const u8,
    ) !*HTMLCollection {
        _ = self;
        _ = namespace;
        _ = local_name;
        return error.NotImplemented;
    }
    /// DOM §4.10.5 - Element.getElementsByClassName(classNames)
    /// Returns an HTMLCollection of all descendant elements that have all the given class names.
    /// classNames is a space-separated list of class names.
    /// TODO: Implement when HTMLCollection is available
    pub fn call_getElementsByClassName(self: *const Element, class_names: []const u8) !*HTMLCollection {
        _ = self;
        _ = class_names;
        return error.NotImplemented;
    }
    /// DOM §4.10.4 - Element.matches(selectors)
    /// Returns true if this element would be selected by the given CSS selectors; otherwise false.
    /// 
    /// Spec steps:
    /// 1. Let s be the result of parse a selector from selectors.
    /// 2. If s is failure, throw a "SyntaxError" DOMException.
    /// 3. If the result of match a selector against an element, using s, this,
    /// and :scope element this, returns success, then return true; otherwise, return false.
    pub fn call_matches(self: *const Element, allocator: Allocator, selectors: []const u8) !bool {
        // Use scopeMatchSelectorsString to parse and match
        // This will throw SyntaxError if parsing fails
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Check if self is in the matches list
        for (matches.items) |match| {
            if (match == self) {
                return true;
            }
        }

        return false;
    }
    /// DOM §4.10.4 - Element.closest(selectors)
    /// Returns the closest ancestor element (including this element) that matches the given CSS selectors.
    /// Returns null if no such element exists.
    /// 
    /// Spec steps:
    /// 1. Let s be the result of parse a selector from selectors.
    /// 2. If s is failure, throw a "SyntaxError" DOMException.
    /// 3. Let elements be this's inclusive ancestors that are elements, in reverse tree order.
    /// 4. For each element in elements, if the result of match a selector against an element,
    /// using s, element, and :scope element this, returns success, return element.
    /// 5. Return null.
    pub fn call_closest(self: *const Element, allocator: Allocator, selectors: []const u8) !?*Element {
        const NodeType = @import("node").Node;

        // Parse selectors (will throw SyntaxError if invalid)
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Step 3: Walk up the tree from this element
        // Check this element and its ancestors
        const self_node: *const NodeType = @ptrCast(self);
        var current: ?*const NodeType = self_node;

        while (current) |node| {
            // Only check elements
            if (node.node_type == NodeType.ELEMENT_NODE) {
                const elem: *const Element = @ptrCast(node);

                // Check if this element is in the matches
                for (matches.items) |match| {
                    if (match == elem) {
                        // Cast away const - closest returns mutable pointer
                        return @constCast(elem);
                    }
                }
            }

            // Move to parent
            current = node.parent_node;
        }

        // Step 5: No match found
        return null;
    }
    /// DOM §4.10.7 - insert adjacent algorithm
    /// To insert adjacent, given an element element, string where, and a node node, run the steps
    /// associated with the first ASCII case-insensitive match for where
    fn insertAdjacent(element: *Element, where: []const u8, node: *Node) !?*Node {
        const mutation = dom.mutation;

        // ASCII case-insensitive comparison helper
        const eqlIgnoreCase = std.ascii.eqlIgnoreCase;

        if (eqlIgnoreCase(where, "beforebegin")) {
            // If element's parent is null, return null
            const parent = element.parent_node orelse return null;

            // Return the result of pre-inserting node into element's parent before element
            return try mutation.preInsert(node, parent, element);
        } else if (eqlIgnoreCase(where, "afterbegin")) {
            // Return the result of pre-inserting node into element before element's first child
            const first_child = if (element.child_nodes.items.len > 0)
                element.child_nodes.items[0]
            else
                null;
            return try mutation.preInsert(node, @ptrCast(element), first_child);
        } else if (eqlIgnoreCase(where, "beforeend")) {
            // Return the result of pre-inserting node into element before null
            return try mutation.preInsert(node, @ptrCast(element), null);
        } else if (eqlIgnoreCase(where, "afterend")) {
            // If element's parent is null, return null
            const parent = element.parent_node orelse return null;

            // Return the result of pre-inserting node into element's parent before element's next sibling
            const next_sibling = dom.tree_helpers.getNextSibling(element);
            return try mutation.preInsert(node, parent, next_sibling);
        } else {
            // Otherwise: Throw a "SyntaxError" DOMException
            return error.SyntaxError;
        }
    }
    /// DOM §4.10.7 - Element.insertAdjacentElement(where, element)
    /// The insertAdjacentElement(where, element) method steps are to return the result of
    /// running insert adjacent, given this, where, and element.
    pub fn call_insertAdjacentElement(self: *Element, where: []const u8, element: *Element) !?*Element {
        const result = try insertAdjacent(self, where, @ptrCast(element));
        return if (result) |node| @ptrCast(@alignCast(node)) else null;
    }
    /// DOM §4.10.7 - Element.insertAdjacentText(where, data)
    /// The insertAdjacentText(where, data) method steps are:
    /// 1. Let text be a new Text node whose data is data and node document is this's node document.
    /// 2. Run insert adjacent, given this, where, and text.
    /// This method returns nothing because it existed before we had a chance to design it.
    pub fn call_insertAdjacentText(self: *Element, where: []const u8, data: []const u8) !void {
        // Step 1: Let text be a new Text node whose data is data and node document is this's node document
        const text = try self.allocator.create(Text);
        errdefer self.allocator.destroy(text);
        text.* = try Text.init(self.allocator);
        // TODO: Set text.data = data when CharacterData has data field accessible
        _ = data;

        // Step 2: Run insert adjacent, given this, where, and text
        _ = try insertAdjacent(self, where, @ptrCast(text));
    }
    /// DOM §4.10.2 - Element.attachShadow(init)
    /// 
    /// Creates a shadow root for this element and returns it.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-element-attachshadow
    pub fn call_attachShadow(self: *Element, shadow_init: ShadowRootInit) !*ShadowRoot {
        // Step 1: Let registry be this's node document's custom element registry
        // TODO: Implement when CustomElementRegistry is available
        const registry = shadow_init.customElementRegistry;

        // Step 2: If init["customElementRegistry"] is non-null:
        if (shadow_init.customElementRegistry) |_| {
            // Step 2.1: Set registry to init["customElementRegistry"]
            // Step 2.2: If registry's is scoped is false and registry is not this's node document's custom element registry, then throw NotSupportedError
            // TODO: Implement when CustomElementRegistry is available
        }

        // Step 3: Run attach a shadow root with this, init["mode"], init["clonable"],
        // init["serializable"], init["delegatesFocus"], init["slotAssignment"], and registry
        const shadow_dom_algorithms = dom.shadow_dom_algorithms;
        try shadow_dom_algorithms.attachShadowRoot(
            self,
            shadow_init.mode,
            shadow_init.clonable,
            shadow_init.serializable,
            shadow_init.delegatesFocus,
            shadow_init.slotAssignment,
            registry,
        );

        // Step 4: Return this's shadow root
        return self.shadow_root.?;
    }
    /// DOM §4.10.2 - Element.shadowRoot getter
    /// 
    /// Returns element's shadow root, if any, and if shadow root's mode is "open"; otherwise null.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-element-shadowroot
    pub fn get_shadowRoot(self: *const Element) ?*ShadowRoot {
        // Step 1: Let shadow be this's shadow root
        const shadow = self.shadow_root orelse return null;

        // Step 2: If shadow's mode is "closed", then return null
        if (shadow.getMode() == .closed) {
            return null;
        }

        // Step 3: Return shadow
        return shadow;
    }
    /// insertBefore(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-insertbefore
    pub fn call_insertBefore(self: *Element, node: *Element, child: ?*Element) !*Element {
        // Call mutation.preInsert algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preInsert(node, self, child) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// appendChild(node)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-appendchild
    pub fn call_appendChild(self: *Element, node: *Element) !*Element {
        // Call mutation.append algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.append(node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// replaceChild(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-replacechild
    pub fn call_replaceChild(self: *Element, node: *Element, child: *Element) !*Element {
        // Call mutation.replace algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.replace(child, node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// removeChild(child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-removechild
    pub fn call_removeChild(self: *Element, child: *Element) !*Element {
        // Call mutation.preRemove algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preRemove(child, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// getRootNode(options)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-getrootnode
    pub fn call_getRootNode(self: *Element, options: ?GetRootNodeOptions) *Element {
        // TODO: Support shadow-including root when options.composed is true
        _ = options;
        // For now, return regular root (from tree.zig)
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        return current;
    }
    /// contains(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-contains
    pub fn call_contains(self: *const Element, other: ?*const Element) bool {
        if (other == null) return false;
        // Check if other is an inclusive descendant of this
        // TODO: Use tree.isInclusiveDescendant from src/dom/tree.zig
        const other_node = other.?;
        if (self == other_node) return true;

        var current = other_node.parent_node;
        while (current) |parent| {
            if (parent == self) return true;
            current = parent.parent_node;
        }
        return false;
    }
    /// compareDocumentPosition(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    pub fn call_compareDocumentPosition(self: *const Element, other: *const Element) u16 {
        const tree = @import("dom").tree;

        // Step 1: If this is other, then return zero
        if (self == other) {
            return 0;
        }

        // Step 2: Let node1 be other and node2 be this
        const node1 = other;
        const node2 = self;

        // Step 3: Let attr1 and attr2 be null
        // Step 4-5: Handle attributes (not implemented yet - attributes don't participate in tree)
        // For now, we skip attribute handling as Attr nodes are handled separately

        // Step 6: If node1 or node2 is null, or node1's root is not node2's root
        // Check if nodes are in the same tree by comparing roots
        const root1 = tree.root(@constCast(node1));
        const root2 = tree.root(@constCast(node2));

        if (root1 != root2) {
            // Return disconnected + implementation specific + preceding/following
            // Use pointer comparison for consistent ordering
            const ptr1 = @intFromPtr(node1);
            const ptr2 = @intFromPtr(node2);
            const ordering = if (ptr1 < ptr2) Element.DOCUMENT_POSITION_PRECEDING else Element.DOCUMENT_POSITION_FOLLOWING;
            return Element.DOCUMENT_POSITION_DISCONNECTED | Element.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | ordering;
        }

        // Step 7: If node1 is an ancestor of node2
        if (tree.isAncestor(node1, node2)) {
            return Element.DOCUMENT_POSITION_CONTAINS | Element.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 8: If node1 is a descendant of node2
        if (tree.isDescendant(node1, node2)) {
            return Element.DOCUMENT_POSITION_CONTAINED_BY | Element.DOCUMENT_POSITION_FOLLOWING;
        }

        // Step 9: If node1 is preceding node2
        if (tree.isPreceding(node1, node2)) {
            return Element.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 10: Return DOCUMENT_POSITION_FOLLOWING
        return Element.DOCUMENT_POSITION_FOLLOWING;
    }
    /// isEqualNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isequalnode
    pub fn call_isEqualNode(self: *const Element, other_node: ?*const Element) bool {
        // Step 1: Return true if otherNode is non-null and this equals otherNode
        if (other_node == null) return false;
        return Element.nodeEquals(self, other_node.?);
    }
    /// isSameNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-issamenode
    pub fn call_isSameNode(self: *const Element, other_node: ?*const Element) bool {
        // Legacy alias of === (pointer equality)
        if (other_node == null) return false;
        return self == other_node.?;
    }
    /// hasChildNodes()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-haschildnodes
    pub fn call_hasChildNodes(self: *const Element) bool {
        return self.child_nodes.len > 0;
    }
    /// cloneNode(deep)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-clonenode
    pub fn call_cloneNode(self: *Element, deep: bool) !*Element {
        // Step 1: If this is a shadow root, throw NotSupportedError
        if (self.node_type == Element.DOCUMENT_FRAGMENT_NODE) {
            // TODO: Check if this is specifically a ShadowRoot and throw error
            // For now, allow cloning of DocumentFragment
        }

        // Step 2: Return the result of cloning this node with subtree set to deep
        return try Element.cloneNodeInternal(self, self.owner_document, deep, null, null);
    }
    /// normalize()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-normalize
    pub fn call_normalize(self: *Element) void {
        _ = self;
        // Normalize adjacent text nodes
    }
    /// Getters
    pub fn get_nodeType(self: *const Element) u16 {
        return self.node_type;
    }
    pub fn get_nodeName(self: *const Element) []const u8 {
        return self.node_name;
    }
    pub fn get_parentNode(self: *const Element) ?*Element {
        return self.parent_node;
    }
    pub fn get_parentElement(self: *const Element) ?*Element {
        // Returns parent if it's an Element, null otherwise
        const parent = self.parent_node orelse return null;
        if (parent.node_type == ELEMENT_NODE) {
            // TODO: Proper type casting when Element type is integrated
            return @ptrCast(parent);
        }
        return null;
    }
    pub fn get_childNodes(self: *const Element) *const infra.List(*Element) {
        // Returns a NodeList rooted at this matching only children
        // TODO: Return actual NodeList interface when implemented
        return &self.child_nodes;
    }
    pub fn get_firstChild(self: *const Element) ?*Element {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(0);
        }
        return null;
    }
    pub fn get_lastChild(self: *const Element) ?*Element {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(self.child_nodes.len - 1);
        }
        return null;
    }
    pub fn get_ownerDocument(self: *const Element) ?*Document {
        return self.owner_document;
    }
    pub fn get_previousSibling(self: *const Element) ?*Element {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i == 0) return null;
                return parent.child_nodes.items[i - 1];
            }
        }
        return null;
    }
    pub fn get_nextSibling(self: *const Element) ?*Element {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i + 1 >= parent.child_nodes.items.len) return null;
                return parent.child_nodes.items[i + 1];
            }
        }
        return null;
    }
    pub fn get_isConnected(self: *const Element) bool {
        // A node is connected if its root is a document
        // TODO: Use tree.root from src/dom/tree.zig
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        // Check if root is a document (node_type == DOCUMENT_NODE)
        return current.node_type == DOCUMENT_NODE;
    }
    /// DOM §4.4 - Node.baseURI getter
    /// Returns this's node document's document base URL, serialized.
    /// 
    /// The baseURI getter steps are to return this's node document's
    /// document base URL, serialized.
    pub fn get_baseURI(self: *const Element) []const u8 {
        // Get owner document
        const doc = self.owner_document orelse {
            // If no owner document, return empty string (should not happen in normal DOM)
            return "about:blank";
        };

        // Return document's base URI
        return doc.base_uri;
    }
    pub fn get_nodeValue(self: *const Element) ?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // Returns value for Attr and CharacterData, null otherwise
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        return null;
    }
    pub fn set_nodeValue(self: *Element, value: ?[]const u8) void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // If null, treat as empty string
        // Set value for Attr, replace data for CharacterData
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        _ = value;
    }
    pub fn get_textContent(self: *const Element) !?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // Return the result of running get text content with this
        return Element.getTextContent(self, self.allocator);
    }
    pub fn set_textContent(self: *Element, value: ?[]const u8) !void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // If the given value is null, act as if it was the empty string instead
        const str_value = value orelse "";
        try Element.setTextContent(self, str_value);
    }
    /// lookupPrefix(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupprefix
    pub fn call_lookupPrefix(self: *const Element, namespace_param: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return null;
    }
    /// lookupNamespaceURI(prefix)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
    pub fn call_lookupNamespaceURI(self: *const Element, prefix: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = prefix;
        return null;
    }
    /// isDefaultNamespace(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
    pub fn call_isDefaultNamespace(self: *const Element, namespace_param: ?[]const u8) bool {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return false;
    }
    /// Get the list of registered observers for this node
    pub fn getRegisteredObservers(self: *Element) *std.ArrayList(RegisteredObserver) {
        return &self.registered_observers;
    }
    /// Add a registered observer to this node's list
    pub fn addRegisteredObserver(self: *Element, registered: RegisteredObserver) !void {
        try self.registered_observers.append(registered);
    }
    /// Remove all registered observers for a specific MutationObserver
    pub fn removeRegisteredObserver(self: *Element, observer: *const @import("mutation_observer").MutationObserver) void {
        var i: usize = 0;
        while (i < self.registered_observers.items.len) {
            if (self.registered_observers.items[i].observer == observer) {
                _ = self.registered_observers.orderedRemove(i);
                // Don't increment i, we just shifted everything down
            } else {
                i += 1;
            }
        }
    }
    /// Remove all transient registered observers whose source matches the given registered observer
    pub fn removeTransientObservers(self: *Element, source: *const RegisteredObserver) !void {
        // TODO: Implement transient registered observers
        // For now, this is a no-op since we haven't implemented transient observers yet
        _ = self;
        _ = source;
    }
    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *Element) !*std.ArrayList(EventListener) {
        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    }
    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const Element) []const EventListener {
        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    }
    /// DOM §2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *Element, listener: EventListener) !void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        if (listener.signal) |_| {
            // TODO: Add abort steps to signal to remove listener
        }
    }
    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *Element,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {
        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    }
    /// DOM §2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *Element, listener: EventListener) void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    }
    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *Element,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {
        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    }
    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *Element, event: *Event) !bool {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this
        // TODO: Implement dispatch algorithm (see whatwg-cbk)
        _ = self;
        @panic("dispatchEvent - dispatch algorithm not yet implemented (see whatwg-cbk)");
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Element",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

