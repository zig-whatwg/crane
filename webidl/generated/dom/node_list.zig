// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! NodeList interface per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-nodelist
//! Section: 4.3 "Interface NodeList"
//!
//! NodeList is a collection of nodes. It provides indexed access to nodes
//! and supports iteration.

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");
const Node = @import("node").Node;
/// NodeList WebIDL interface
///
/// Complete implementation per WHATWG DOM Standard ยง4.3
/// Status: 100% complete
///
/// Implemented:
/// - length attribute (returns number of nodes)
/// - item(index) method (returns node at index or null)
/// - iterable<Node> support (via Zig iteration patterns)
///
/// Complete IDL:
/// ```webidl
/// [Exposed=Window]
/// interface NodeList {
/// getter Node? item(unsigned long index);
/// readonly attribute unsigned long length;
/// iterable<Node>;
/// };
/// ```
///
/// Note: NodeList objects are "live" when returned from Node.childNodes,
/// meaning they automatically reflect changes to the DOM tree.
pub const NodeList = struct {
    allocator: std.mem.Allocator,
    /// The underlying list of nodes
    /// For live NodeLists (from Node.childNodes), this references the parent's children list
    /// For static NodeLists, this is an owned copy
    nodes: *const infra.List(*Node),
    /// Whether this NodeList is live (reflects DOM changes) or static (snapshot)
    isLive: bool,

    pub const Iterator = struct {
        list: *const infra.List(*Node),
        index: usize,

        pub fn next(self: *Iterator) ?*Node {
            if (self.index >= self.list.size()) return null;
            const node = self.list.get(self.index);
            self.index += 1;
            return node;
        }
    };

    pub fn deinit(self: *NodeList) void {
        // Only free if we own the list (static NodeList)
        if (!self.isLive) {
            const owned_list = @constCast(self.nodes);
            owned_list.deinit();
            self.allocator.destroy(owned_list);
        }
    }

    pub fn init(allocator: std.mem.Allocator, nodes: *const infra.List(*Node), isLive: bool) !NodeList {
        return try NodeList.initFields(allocator, &.{
            .allocator = allocator,
            .nodes = nodes,
            .isLive = isLive,
        });
    }
    fn initFields(_: std.mem.Allocator, fields: *const struct {
        allocator: std.mem.Allocator,
        nodes: *const infra.List(*Node),
        isLive: bool,
    }) !NodeList {
        return .{
            .allocator = fields.allocator,
            .nodes = fields.nodes,
            .isLive = fields.isLive,
        };
    }
    /// Constructor for live NodeList (references parent's children)
    ///
    /// This creates a "live" NodeList that automatically reflects changes
    /// to the parent node's children.
    pub fn initLive(
        allocator: std.mem.Allocator,
        parent_children: *const infra.List(*Node),
    ) !NodeList {
        return NodeList{
            .allocator = allocator,
            .nodes = parent_children,
            .isLive = true,
        };
    }
    /// Constructor for static NodeList (owns a copy of nodes)
    ///
    /// This creates a "static" NodeList that is a snapshot and does not
    /// reflect subsequent DOM changes.
    pub fn initStatic(
        allocator: std.mem.Allocator,
        nodes_to_copy: []const *Node,
    ) !NodeList {
        const owned_list = try allocator.create(infra.List(*Node));
        owned_list.* = infra.List(*Node).init(allocator);

        for (nodes_to_copy) |node| {
            try owned_list.append(node);
        }

        return NodeList{
            .allocator = allocator,
            .nodes = owned_list,
            .isLive = false,
        };
    }
    /// length getter
    ///
    /// IDL: readonly attribute unsigned long length;
    ///
    /// Spec (ยง4.3):
    /// Returns the number of nodes represented by the collection.
    pub fn get_length(self: *const NodeList) webidl.UnsignedLong {
        return @intCast(self.nodes.size());
    }
    /// item(index)
    ///
    /// IDL: getter Node? item(unsigned long index);
    ///
    /// Spec algorithm (ยง4.3):
    /// Returns the index^th node in the collection.
    /// If there is no index^th node, returns null.
    ///
    /// The nodes are sorted in tree order.
    pub fn call_item(self: *const NodeList, index: webidl.UnsignedLong) ?*Node {
        return self.nodes.get(index);
    }
    /// Returns an iterator for the NodeList
    pub fn iterator(self: *const NodeList) Iterator {
        return Iterator{
            .list = self.nodes,
            .index = 0,
        };
    }
};

// ========== Tests ==========

const testing = std.testing;

test "NodeList - static list creation" {
    const allocator = testing.allocator;

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    var node2 = try Node.init(allocator, 1, "node2");
    defer node2.deinit();

    const nodes = [_]*Node{ &node1, &node2 };
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    try testing.expectEqual(@as(webidl.UnsignedLong, 2), list.get_length());
}

test "NodeList - item returns node at index" {
    const allocator = testing.allocator;

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    var node2 = try Node.init(allocator, 1, "node2");
    defer node2.deinit();

    const nodes = [_]*Node{ &node1, &node2 };
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    try testing.expectEqual(&node1, list.call_item(0).?);
    try testing.expectEqual(&node2, list.call_item(1).?);
}

test "NodeList - item returns null for out of bounds" {
    const allocator = testing.allocator;

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    const nodes = [_]*Node{&node1};
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    try testing.expectEqual(@as(?*Node, null), list.call_item(1));
    try testing.expectEqual(@as(?*Node, null), list.call_item(999));
}

test "NodeList - empty list" {
    const allocator = testing.allocator;

    const nodes = [_]*Node{};
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    try testing.expectEqual(@as(webidl.UnsignedLong, 0), list.get_length());
    try testing.expectEqual(@as(?*Node, null), list.call_item(0));
}

test "NodeList - iterator" {
    const allocator = testing.allocator;

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    var node2 = try Node.init(allocator, 1, "node2");
    defer node2.deinit();

    var node3 = try Node.init(allocator, 1, "node3");
    defer node3.deinit();

    const nodes = [_]*Node{ &node1, &node2, &node3 };
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    var iter = list.iterator();
    try testing.expectEqual(&node1, iter.next().?);
    try testing.expectEqual(&node2, iter.next().?);
    try testing.expectEqual(&node3, iter.next().?);
    try testing.expectEqual(@as(?*Node, null), iter.next());
}

test "NodeList - live list reflects changes" {
    const allocator = testing.allocator;

    var parent = try Node.init(allocator, 1, "parent");
    defer parent.deinit();

    var child1 = try Node.init(allocator, 1, "child1");
    defer child1.deinit();

    // Create live NodeList from parent's children
    var list = try NodeList.initLive(allocator, &parent.children);
    defer list.deinit();

    // Initially empty
    try testing.expectEqual(@as(webidl.UnsignedLong, 0), list.get_length());

    // Add child - list should reflect change
    _ = try parent.call_appendChild(&child1);
    try testing.expectEqual(@as(webidl.UnsignedLong, 1), list.get_length());
    try testing.expectEqual(&child1, list.call_item(0).?);

    // Remove child - list should reflect change
    _ = try parent.call_removeChild(&child1);
    try testing.expectEqual(@as(webidl.UnsignedLong, 0), list.get_length());
}

test "NodeList - static list does not reflect changes" {
    const allocator = testing.allocator;

    var parent = try Node.init(allocator, 1, "parent");
    defer parent.deinit();

    var child1 = try Node.init(allocator, 1, "child1");
    defer child1.deinit();

    _ = try parent.call_appendChild(&child1);

    // Create static snapshot
    const nodes = [_]*Node{&child1};
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    try testing.expectEqual(@as(webidl.UnsignedLong, 1), list.get_length());

    // Remove child from parent - static list should NOT reflect change
    _ = try parent.call_removeChild(&child1);
    try testing.expectEqual(@as(webidl.UnsignedLong, 1), list.get_length());
    try testing.expectEqual(&child1, list.call_item(0).?);
}

test "NodeList - iterable<Node> pattern - multiple iterations" {
    const allocator = testing.allocator;

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    var node2 = try Node.init(allocator, 1, "node2");
    defer node2.deinit();

    var node3 = try Node.init(allocator, 1, "node3");
    defer node3.deinit();

    const nodes = [_]*Node{ &node1, &node2, &node3 };
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    // First iteration
    var iter1 = list.iterator();
    var count1: usize = 0;
    while (iter1.next()) |_| {
        count1 += 1;
    }
    try testing.expectEqual(@as(usize, 3), count1);

    // Second iteration (iterator can be created multiple times)
    var iter2 = list.iterator();
    var count2: usize = 0;
    while (iter2.next()) |_| {
        count2 += 1;
    }
    try testing.expectEqual(@as(usize, 3), count2);
}

test "NodeList - iterable<Node> pattern - empty list" {
    const allocator = testing.allocator;

    const nodes = [_]*Node{};
    var list = try NodeList.initStatic(allocator, &nodes);
    defer list.deinit();

    var iter = list.iterator();
    try testing.expectEqual(@as(?*Node, null), iter.next());
}
