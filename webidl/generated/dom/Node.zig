// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Node interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-node

const std = @import("std");
const webidl = @import("webidl");

pub const EventTarget = @import("event_target").EventTarget;
pub const TransientRegisteredObserver = @import("registered_observer").TransientRegisteredObserver;
/// Runtime type tag for Node hierarchy.
/// Used for safe downcasting from NodeBase to derived types.
pub const NodeTypeTag = enum {
    Node,
    CDATASection,
    ShadowRoot,
    Element,
    DocumentType,
    CharacterData,
    Document,
    Comment,
    DocumentFragment,
    Text,
    Attr,
    ProcessingInstruction,
};

/// Base struct for Node hierarchy polymorphism.
/// All Node-derived types have `base: NodeBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const NodeBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: NodeTypeTag,

    event_listener_list: ?*std.ArrayList(@import("event_target").EventListener),
    allocator: Allocator,

    node_type: u16,
    node_name: []const u8,
    parent_node: ?*Node,
    child_nodes: infra.List(*Node),
    owner_document: ?*@import("document").Document,
    /// DOM §7.1 - Registered observer list
    /// List of registered mutation observers watching this node
    registered_observers: infra.List(@import("registered_observer").RegisteredObserver),

    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for CDATASection.
    /// Use this in CDATASection.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForCDATASection(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .CDATASection,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.CDATA_SECTION_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for ShadowRoot.
    /// Use this in ShadowRoot.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForShadowRoot(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .ShadowRoot,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.DOCUMENT_FRAGMENT_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for Element.
    /// Use this in Element.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForElement(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .Element,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.ELEMENT_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for DocumentType.
    /// Use this in DocumentType.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForDocumentType(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .DocumentType,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.DOCUMENT_TYPE_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for CharacterData.
    /// Use this in CharacterData.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForCharacterData(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .CharacterData,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.TEXT_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for Document.
    /// Use this in Document.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForDocument(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .Document,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.DOCUMENT_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for Comment.
    /// Use this in Comment.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForComment(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .Comment,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.COMMENT_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for DocumentFragment.
    /// Use this in DocumentFragment.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForDocumentFragment(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .DocumentFragment,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.DOCUMENT_FRAGMENT_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for Text.
    /// Use this in Text.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForText(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .Text,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.TEXT_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for Attr.
    /// Use this in Attr.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForAttr(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .Attr,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.ATTRIBUTE_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }

    /// Create a base struct initialized for ProcessingInstruction.
    /// Use this in ProcessingInstruction.init() to properly initialize the base field.
    /// All collection fields are properly initialized with the provided allocator.
    pub fn initForProcessingInstruction(allocator: Allocator) NodeBase {
        return .{
            .type_tag = .ProcessingInstruction,
            .event_listener_list = null,
            .allocator = allocator,
            .node_type = Node.PROCESSING_INSTRUCTION_NODE,
            .node_name = "",
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
        };
    }


    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *NodeBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    /// 
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *NodeBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(NodeTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const NodeBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(NodeTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in Node hierarchy:
    //   - CDATASection
    //   - ShadowRoot
    //   - Element
    //   - DocumentType
    //   - CharacterData
    //   - Document
    //   - Comment
    //   - DocumentFragment
    //   - Text
    //   - Attr
    //   - ProcessingInstruction
    //

};

/// Node WebIDL interface
/// DOM Spec: interface Node : EventTarget
const EventTargetBase = @import("event_target").EventTargetBase;
const EventListener = @import("event_target").EventListener;
const Event = @import("event").Event;
const flattenOptions = @import("event_target").flattenOptions;
const flattenMoreOptions = @import("event_target").flattenMoreOptions;
const defaultPassiveValue = @import("event_target").defaultPassiveValue;
const callbackEquals = @import("event_target").callbackEquals;
const Allocator = std.mem.Allocator;
const infra = @import("infra");
const Document = @import("document").Document;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const Element = @import("element").Element;
const CharacterData = @import("character_data").CharacterData;
const Text = @import("text").Text;
pub const Node = struct {
    base: EventTargetBase,

    // ========================================================================
    // Node fields
    // ========================================================================
    allocator: Allocator,
    node_type: u16,
    node_name: []const u8,
    parent_node: ?*Node,
    child_nodes: infra.List(*Node),
    owner_document: ?*Document,
    /// DOM §7.1 - Registered observer list
    /// List of registered mutation observers watching this node
    registered_observers: infra.List(@import("registered_observer").RegisteredObserver),

    pub const ELEMENT_NODE: u16 = 1;
    pub const ATTRIBUTE_NODE: u16 = 2;
    pub const TEXT_NODE: u16 = 3;
    pub const CDATA_SECTION_NODE: u16 = 4;
    pub const ENTITY_REFERENCE_NODE: u16 = 5;
    pub const ENTITY_NODE: u16 = 6;
    pub const PROCESSING_INSTRUCTION_NODE: u16 = 7;
    pub const COMMENT_NODE: u16 = 8;
    pub const DOCUMENT_NODE: u16 = 9;
    pub const DOCUMENT_TYPE_NODE: u16 = 10;
    pub const DOCUMENT_FRAGMENT_NODE: u16 = 11;
    pub const NOTATION_NODE: u16 = 12;
    pub const DOCUMENT_POSITION_DISCONNECTED: u16 = 0x01;
    pub const DOCUMENT_POSITION_PRECEDING: u16 = 0x02;
    pub const DOCUMENT_POSITION_FOLLOWING: u16 = 0x04;
    pub const DOCUMENT_POSITION_CONTAINS: u16 = 0x08;
    pub const DOCUMENT_POSITION_CONTAINED_BY: u16 = 0x10;
    pub const DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: u16 = 0x20;

    pub fn init(allocator: Allocator, node_type: u16, node_name: []const u8) !Node {
        // NOTE: Parent EventTarget fields will be flattened by codegen
        // Don't manually initialize parent fields here
        return .{
            .base = EventTargetBase.initForNode(allocator),
            .allocator = allocator,
            .node_type = node_type,
            .node_name = node_name,
            .parent_node = null,
            .child_nodes = infra.List(*Node).init(allocator),
            .owner_document = null,
            .registered_observers = infra.List(@import("registered_observer").RegisteredObserver).init(allocator),
            // NOTE: Parent EventTarget initialization is handled by codegen
        };
    }
    pub fn deinit(self: *Node) void {
        // NOTE: EventTarget parent cleanup is handled by codegen
        self.child_nodes.deinit();
        self.registered_observers.deinit();
    
        
        // Clean up base fields
        if (self.base.event_listener_list) |list| {
            list.deinit(self.allocator);
            self.allocator.destroy(list);
        }
}

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to EventTargetBase for type-generic code.
    pub fn toBase(self: *Node) *EventTargetBase {
        return &self.base;
    }

    // ========================================================================
    // Node methods
    // ========================================================================

    /// insertBefore(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-insertbefore
    pub fn call_insertBefore(self: *Node, node: *Node, child: ?*Node) !*Node {
        // Call mutation.preInsert algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preInsert(node, self, child) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// appendChild(node)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-appendchild
    pub fn call_appendChild(self: *Node, node: *Node) !*Node {
        // Call mutation.append algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.append(node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// replaceChild(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-replacechild
    pub fn call_replaceChild(self: *Node, node: *Node, child: *Node) !*Node {
        // Call mutation.replace algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.replace(child, node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// removeChild(child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-removechild
    pub fn call_removeChild(self: *Node, child: *Node) !*Node {
        // Call mutation.preRemove algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preRemove(child, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// getRootNode(options)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-getrootnode
    pub fn call_getRootNode(self: *Node, options: ?GetRootNodeOptions) *Node {
        // TODO: Support shadow-including root when options.composed is true
        _ = options;
        // For now, return regular root (from tree.zig)
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        return current;
    }
    /// contains(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-contains
    pub fn call_contains(self: *const Node, other: ?*const Node) bool {
        if (other == null) return false;
        // Check if other is an inclusive descendant of this
        // TODO: Use tree.isInclusiveDescendant from src/dom/tree.zig
        const other_node = other.?;
        if (self == other_node) return true;

        var current = other_node.parent_node;
        while (current) |parent| {
            if (parent == self) return true;
            current = parent.parent_node;
        }
        return false;
    }
    /// compareDocumentPosition(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    pub fn call_compareDocumentPosition(self: *const Node, other: *const Node) u16 {
        const tree = @import("dom").tree;

        // Step 1: If this is other, then return zero
        if (self == other) {
            return 0;
        }

        // Step 2: Let node1 be other and node2 be this
        const node1 = other;
        const node2 = self;

        // Step 3: Let attr1 and attr2 be null
        // Step 4-5: Handle attributes (not implemented yet - attributes don't participate in tree)
        // For now, we skip attribute handling as Attr nodes are handled separately

        // Step 6: If node1 or node2 is null, or node1's root is not node2's root
        // Check if nodes are in the same tree by comparing roots
        const root1 = tree.root(@constCast(node1));
        const root2 = tree.root(@constCast(node2));

        if (root1 != root2) {
            // Return disconnected + implementation specific + preceding/following
            // Use pointer comparison for consistent ordering
            const ptr1 = @intFromPtr(node1);
            const ptr2 = @intFromPtr(node2);
            const ordering = if (ptr1 < ptr2) Node.DOCUMENT_POSITION_PRECEDING else Node.DOCUMENT_POSITION_FOLLOWING;
            return Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | ordering;
        }

        // Step 7: If node1 is an ancestor of node2
        if (tree.isAncestor(node1, node2)) {
            return Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 8: If node1 is a descendant of node2
        if (tree.isDescendant(node1, node2)) {
            return Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING;
        }

        // Step 9: If node1 is preceding node2
        if (tree.isPreceding(node1, node2)) {
            return Node.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 10: Return DOCUMENT_POSITION_FOLLOWING
        return Node.DOCUMENT_POSITION_FOLLOWING;
    }
    /// isEqualNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isequalnode
    pub fn call_isEqualNode(self: *const Node, other_node: ?*const Node) bool {
        // Step 1: Return true if otherNode is non-null and this equals otherNode
        if (other_node == null) return false;
        return Node.nodeEquals(self, other_node.?);
    }
    /// Node A equals node B - DOM Spec algorithm
    /// A node A equals a node B if all of the following conditions are true:
    /// - A and B implement the same interfaces
    /// - Node-specific properties are equal
    /// - If A is an element, each attribute in its list equals an attribute in B's list
    /// - A and B have the same number of children
    /// - Each child of A equals the child of B at the identical index
    pub fn nodeEquals(a: *const Node, b: *const Node) bool {
        // Step 1: A and B implement the same interfaces (check node_type)
        if (a.node_type != b.node_type) return false;

        // Step 2: Check node-type-specific properties
        switch (a.node_type) {
            DOCUMENT_TYPE_NODE => {
                // DocumentType: check name, public ID, and system ID
                // TODO: Cast to DocumentType when implemented
                // For now, just check node_name
                if (!std.mem.eql(u8, a.node_name, b.node_name)) return false;
            },
            ELEMENT_NODE => {
                // Element: check namespace, namespace prefix, local name, and attribute list size
                const elem_a: *const Element = @ptrCast(@alignCast(a));
                const elem_b: *const Element = @ptrCast(@alignCast(b));

                // Check namespace
                if (elem_a.namespace_uri == null and elem_b.namespace_uri != null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri == null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri != null) {
                    if (!std.mem.eql(u8, elem_a.namespace_uri.?, elem_b.namespace_uri.?)) return false;
                }

                // Check local name (tag_name)
                if (!std.mem.eql(u8, elem_a.tag_name, elem_b.tag_name)) return false;

                // Check attribute list size
                if (elem_a.attributes.len != elem_b.attributes.len) return false;

                // Step 3: Each attribute in A's list has an equal attribute in B's list
                for (elem_a.attributes.items) |attr_a| {
                    var found = false;
                    for (elem_b.attributes.items) |attr_b| {
                        if (Node.attributeEquals(&attr_a, &attr_b)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) return false;
                }
            },
            ATTRIBUTE_NODE => {
                // Attr: check namespace, local name, and value
                // Note: Attr nodes don't participate in tree, but we check for completeness
                const Attr = @import("attr").Attr;
                const attr_a: *const Attr = @ptrCast(@alignCast(a));
                const attr_b: *const Attr = @ptrCast(@alignCast(b));
                return Node.attributeEquals(attr_a, attr_b);
            },
            PROCESSING_INSTRUCTION_NODE => {
                // ProcessingInstruction: check target and data
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi_a: *const PI = @ptrCast(@alignCast(a));
                const pi_b: *const PI = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, pi_a.target, pi_b.target)) return false;
                if (!std.mem.eql(u8, pi_a.data, pi_b.data)) return false;
            },
            TEXT_NODE, COMMENT_NODE, CDATA_SECTION_NODE => {
                // Text, Comment, CDATASection: check data
                const cd_a: *const CharacterData = @ptrCast(@alignCast(a));
                const cd_b: *const CharacterData = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, cd_a.data, cd_b.data)) return false;
            },
            else => {
                // For other node types, basic node_name check is sufficient
                if (!std.mem.eql(u8, a.node_name, b.node_name)) return false;
            },
        }

        // Step 4: A and B have the same number of children
        if (a.child_nodes.len != b.child_nodes.len) return false;

        // Step 5: Each child of A equals the child of B at the identical index
        for (a.child_nodes.items, 0..) |child_a, i| {
            const child_b = b.child_nodes.items[i];
            if (!Node.nodeEquals(child_a, child_b)) return false;
        }

        return true;
    }
    /// Attribute equality check
    /// An attribute A equals an attribute B if:
    /// - namespace is equal
    /// - local name is equal
    /// - value is equal
    pub fn attributeEquals(a: *const @import("attr").Attr, b: *const @import("attr").Attr) bool {
        // Check namespace
        if (a.namespace_uri == null and b.namespace_uri != null) return false;
        if (a.namespace_uri != null and b.namespace_uri == null) return false;
        if (a.namespace_uri != null and b.namespace_uri != null) {
            if (!std.mem.eql(u8, a.namespace_uri.?, b.namespace_uri.?)) return false;
        }

        // Check local name
        if (!std.mem.eql(u8, a.local_name, b.local_name)) return false;

        // Check value
        if (!std.mem.eql(u8, a.value, b.value)) return false;

        return true;
    }
    /// isSameNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-issamenode
    pub fn call_isSameNode(self: *const Node, other_node: ?*const Node) bool {
        // Legacy alias of === (pointer equality)
        if (other_node == null) return false;
        return self == other_node.?;
    }
    /// hasChildNodes()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-haschildnodes
    pub fn call_hasChildNodes(self: *const Node) bool {
        return self.child_nodes.len > 0;
    }
    /// cloneNode(deep)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-clonenode
    pub fn call_cloneNode(self: *Node, deep: bool) !*Node {
        // Step 1: If this is a shadow root, throw NotSupportedError
        if (self.node_type == Node.DOCUMENT_FRAGMENT_NODE) {
            // TODO: Check if this is specifically a ShadowRoot and throw error
            // For now, allow cloning of DocumentFragment
        }

        // Step 2: Return the result of cloning this node with subtree set to deep
        return try Node.cloneNodeInternal(self, self.owner_document, deep, null, null);
    }
    /// Clone a node - DOM Spec algorithm
    /// Given a node `node` and optional document, subtree flag, parent, and fallbackRegistry
    pub fn cloneNodeInternal(
        node: *Node,
        document_param: ?*Document,
        subtree: bool,
        parent: ?*Node,
        fallback_registry: ?*anyopaque, // CustomElementRegistry - not implemented yet
    ) !*Node {
        // Step 1: Let document be document_param or node's owner_document
        const document = document_param orelse node.owner_document;

        // Assert: node is not a document or node is document
        // (We don't have full Document implementation yet, skip this assert)

        // Step 2: Let copy be the result of cloning a single node
        var copy = try Node.cloneSingleNode(node, document, fallback_registry);

        // Step 3: Run any cloning steps (not implemented - would be extension point for HTML etc.)
        // TODO: Call cloning steps hook if defined

        // Step 4: If parent is non-null, append copy to parent
        if (parent) |p| {
            try p.child_nodes.append(copy);
            copy.parent_node = p;
        }

        // Step 5: If subtree is true, clone all children recursively
        if (subtree) {
            for (node.child_nodes.items) |child| {
                _ = try Node.cloneNodeInternal(child, document, subtree, copy, fallback_registry);
            }
        }

        // Step 6: If node is an element and shadow host, clone shadow root (not implemented yet)
        // TODO: Handle shadow root cloning when shadow DOM is fully implemented

        // Step 7: Return copy
        return copy;
    }
    /// Clone a single node - DOM Spec algorithm
    /// Creates a new node with the same properties but no children
    pub fn cloneSingleNode(
        node: *Node,
        document: ?*Document,
        fallback_registry: ?*anyopaque,
    ) !*Node {
        _ = fallback_registry; // Not used yet - for custom elements

        // Step 2-3: Handle different node types
        switch (node.node_type) {
            Node.ELEMENT_NODE => {
                // Clone element with attributes
                const elem: *Element = @ptrCast(@alignCast(node));

                // Create new element
                var copy_elem = try Element.init(elem.allocator, elem.tag_name);
                copy_elem.namespace_uri = elem.namespace_uri;

                // Clone attributes
                for (elem.attributes.items) |attr| {
                    const Attr = @import("attr").Attr;
                    const copy_attr = Attr{
                        .allocator = elem.allocator,
                        .namespace_uri = attr.namespace_uri,
                        .prefix = attr.prefix,
                        .local_name = attr.local_name,
                        .value = attr.value,
                        .owner_element = &copy_elem,
                    };
                    try copy_elem.attributes.append(copy_attr);
                }

                const copy_node = @as(*Node, @ptrCast(&copy_elem));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Clone CharacterData (Text, Comment, CDATASection)
                const cd: *CharacterData = @ptrCast(@alignCast(node));

                var copy_cd = try CharacterData.init(cd.allocator);
                copy_cd.data = try cd.allocator.dupe(u8, cd.data);

                const copy_node = @as(*Node, @ptrCast(&copy_cd));
                copy_node.node_type = node.node_type;
                copy_node.node_name = node.node_name;
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.PROCESSING_INSTRUCTION_NODE => {
                // Clone ProcessingInstruction
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi: *PI = @ptrCast(@alignCast(node));

                var copy_pi = try PI.init(pi.allocator, pi.target, pi.data);

                const copy_node = @as(*Node, @ptrCast(&copy_pi));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.ATTRIBUTE_NODE => {
                // Clone Attr
                const Attr = @import("attr").Attr;
                const attr: *Attr = @ptrCast(@alignCast(node));

                var copy_attr = try Attr.init(
                    attr.allocator,
                    attr.namespace_uri,
                    attr.prefix,
                    attr.local_name,
                    attr.value,
                );

                const copy_node = @as(*Node, @ptrCast(&copy_attr));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.DOCUMENT_TYPE_NODE => {
                // Clone DocumentType (simplified - full implementation needs public ID, system ID)
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_FRAGMENT_NODE => {
                // Clone DocumentFragment
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_NODE => {
                // Cloning Document is complex and not fully supported yet
                // For now, just create a basic copy
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            else => {
                // Default: create basic node copy
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
        }
    }
    /// normalize()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-normalize
    pub fn call_normalize(self: *Node) void {
        _ = self;
        // Normalize adjacent text nodes
    }
    /// Getters
    pub fn get_nodeType(self: *const Node) u16 {
        return self.node_type;
    }
    pub fn get_nodeName(self: *const Node) []const u8 {
        return self.node_name;
    }
    pub fn get_parentNode(self: *const Node) ?*Node {
        return self.parent_node;
    }
    pub fn get_parentElement(self: *const Node) ?*Element {
        // Returns parent if it's an Element, null otherwise
        const parent = self.parent_node orelse return null;
        if (parent.node_type == ELEMENT_NODE) {
            // TODO: Proper type casting when Element type is integrated
            return @ptrCast(parent);
        }
        return null;
    }
    pub fn get_childNodes(self: *const Node) *const infra.List(*Node) {
        // Returns a NodeList rooted at this matching only children
        // TODO: Return actual NodeList interface when implemented
        return &self.child_nodes;
    }
    pub fn get_firstChild(self: *const Node) ?*Node {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(0);
        }
        return null;
    }
    pub fn get_lastChild(self: *const Node) ?*Node {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(self.child_nodes.len - 1);
        }
        return null;
    }
    pub fn get_ownerDocument(self: *const Node) ?*Document {
        return self.owner_document;
    }
    pub fn get_previousSibling(self: *const Node) ?*Node {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i == 0) return null;
                return parent.child_nodes.items[i - 1];
            }
        }
        return null;
    }
    pub fn get_nextSibling(self: *const Node) ?*Node {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i + 1 >= parent.child_nodes.items.len) return null;
                return parent.child_nodes.items[i + 1];
            }
        }
        return null;
    }
    pub fn get_isConnected(self: *const Node) bool {
        // A node is connected if its root is a document
        // TODO: Use tree.root from src/dom/tree.zig
        var current = self;
        while (current.parent_node) |parent| {
            current = parent;
        }
        // Check if root is a document (node_type == DOCUMENT_NODE)
        return current.node_type == DOCUMENT_NODE;
    }
    /// DOM §4.4 - Node.baseURI getter
    /// Returns this's node document's document base URL, serialized.
    /// 
    /// The baseURI getter steps are to return this's node document's
    /// document base URL, serialized.
    pub fn get_baseURI(self: *const Node) []const u8 {
        // Get owner document
        const doc = self.owner_document orelse {
            // If no owner document, return empty string (should not happen in normal DOM)
            return "about:blank";
        };

        // Return document's base URI
        return doc.base_uri;
    }
    pub fn get_nodeValue(self: *const Node) ?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // Returns value for Attr and CharacterData, null otherwise
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        return null;
    }
    pub fn set_nodeValue(self: *Node, value: ?[]const u8) void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // If null, treat as empty string
        // Set value for Attr, replace data for CharacterData
        // TODO: Implement for Attr and CharacterData nodes
        _ = self;
        _ = value;
    }
    pub fn get_textContent(self: *const Node) !?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // Return the result of running get text content with this
        return Node.getTextContent(self, self.allocator);
    }
    pub fn set_textContent(self: *Node, value: ?[]const u8) !void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // If the given value is null, act as if it was the empty string instead
        const str_value = value orelse "";
        try Node.setTextContent(self, str_value);
    }
    /// Get text content - DOM Spec algorithm
    /// Returns text content based on node type
    /// For Element and DocumentFragment, the returned string is allocated and must be freed by caller
    /// For other types, returns a reference to existing data (no allocation)
    pub fn getTextContent(node: *const Node, allocator: std.mem.Allocator) !?[]const u8 {
        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // Return descendant text content (allocated)
                return Node.getDescendantTextContent(node, allocator);
            },
            Node.ATTRIBUTE_NODE => {
                // Return node's value (no allocation - returns reference)
                const Attr = @import("attr").Attr;
                const attr: *const Attr = @ptrCast(@alignCast(node));
                return attr.value;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE, Node.PROCESSING_INSTRUCTION_NODE => {
                // Return node's data (no allocation - returns reference)
                const cd: *const CharacterData = @ptrCast(@alignCast(node));
                return cd.data;
            },
            else => {
                // Document, DocumentType: return null
                return null;
            },
        }
    }
    /// Get descendant text content - concatenate all Text node descendants
    /// Spec: https://dom.spec.whatwg.org/#concept-descendant-text-content
    /// Returns the concatenation of data from all Text node descendants in tree order.
    /// Caller owns the returned memory and must free it.
    pub fn getDescendantTextContent(node: *const Node, allocator: std.mem.Allocator) ![]const u8 {
        var result = std.ArrayList(u8).init(allocator);
        errdefer result.deinit();

        try collectDescendantText(node, &result);

        return result.toOwnedSlice();
    }
    /// Helper function to recursively collect text from descendants
    fn collectDescendantText(node: *const Node, result: *std.ArrayList(u8)) !void {
        // If this is a Text node, collect its data
        if (node.node_type == Node.TEXT_NODE) {
            const cd: *const CharacterData = @ptrCast(@alignCast(node));
            try result.appendSlice(cd.data);
        }

        // Recursively process all children
        for (0..node.child_nodes.len) |i| {
            if (node.child_nodes.get(i)) |child| {
                try collectDescendantText(child, result);
            }
        }
    }
    /// Set text content - DOM Spec algorithm
    /// Sets text content based on node type
    pub fn setTextContent(node: *Node, value: []const u8) !void {
        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // String replace all with value within node
                try Node.stringReplaceAll(node, value);
            },
            Node.ATTRIBUTE_NODE => {
                // Set an existing attribute value
                const Attr = @import("attr").Attr;
                const attr: *Attr = @ptrCast(@alignCast(node));
                // TODO: Use "set an existing attribute value" algorithm
                // For now, just update the value
                attr.value = value;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Replace data with node, offset 0, count node's length, and data value
                const cd: *CharacterData = @ptrCast(@alignCast(node));
                const length = @as(u32, @intCast(cd.data.len));
                try cd.replaceData(0, length, value);
            },
            else => {
                // Document, DocumentType, etc: do nothing
            },
        }
    }
    /// String replace all - DOM Spec algorithm
    /// Replace all children with a single text node containing string
    pub fn stringReplaceAll(parent: *Node, string: []const u8) !void {
        // Step 1: Let node be null
        var node_opt: ?*Node = null;

        // Step 2: If string is not the empty string, create a new Text node
        if (string.len > 0) {
            var text_node = try Text.init(parent.allocator);

            const cd: *CharacterData = @ptrCast(@alignCast(&text_node));
            cd.data = try parent.allocator.dupe(u8, string);

            const new_node: *Node = @ptrCast(&text_node);
            new_node.owner_document = parent.owner_document;
            node_opt = new_node;
        }

        // Step 3: Replace all with node within parent
        const mutation = @import("dom").mutation;
        try mutation.replaceAll(node_opt, parent);
    }
    /// lookupPrefix(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupprefix
    pub fn call_lookupPrefix(self: *const Node, namespace_param: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return null;
    }
    /// lookupNamespaceURI(prefix)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
    pub fn call_lookupNamespaceURI(self: *const Node, prefix: ?[]const u8) ?[]const u8 {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = prefix;
        return null;
    }
    /// isDefaultNamespace(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
    pub fn call_isDefaultNamespace(self: *const Node, namespace_param: ?[]const u8) bool {
        // TODO: Implement full algorithm from spec
        _ = self;
        _ = namespace_param;
        return false;
    }
    /// Get the list of registered observers for this node
    pub fn getRegisteredObservers(self: *Node) *std.ArrayList(RegisteredObserver) {
        return &self.registered_observers;
    }
    /// Add a registered observer to this node's list
    pub fn addRegisteredObserver(self: *Node, registered: RegisteredObserver) !void {
        try self.registered_observers.append(registered);
    }
    /// Remove all registered observers for a specific MutationObserver
    pub fn removeRegisteredObserver(self: *Node, observer: *const @import("mutation_observer").MutationObserver) void {
        var i: usize = 0;
        while (i < self.registered_observers.items.len) {
            if (self.registered_observers.items[i].observer == observer) {
                _ = self.registered_observers.orderedRemove(i);
                // Don't increment i, we just shifted everything down
            } else {
                i += 1;
            }
        }
    }
    /// Remove all transient registered observers whose source matches the given registered observer
    pub fn removeTransientObservers(self: *Node, source: *const RegisteredObserver) !void {
        // TODO: Implement transient registered observers
        // For now, this is a no-op since we haven't implemented transient observers yet
        _ = self;
        _ = source;
    }
    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *Node) !*std.ArrayList(EventListener) {
        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    }
    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const Node) []const EventListener {
        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    }
    /// DOM §2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *Node, listener: EventListener) !void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        if (listener.signal) |_| {
            // TODO: Add abort steps to signal to remove listener
        }
    }
    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *Node,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {
        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    }
    /// DOM §2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *Node, listener: EventListener) void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    }
    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *Node,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {
        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    }
    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *Node, event: *Event) !bool {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this
        // TODO: Implement dispatch algorithm (see whatwg-cbk)
        _ = self;
        @panic("dispatchEvent - dispatch algorithm not yet implemented (see whatwg-cbk)");
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Node",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


/// GetRootNodeOptions dictionary
/// Spec: https://dom.spec.whatwg.org/#dictdef-getrootnodeoptions
pub const GetRootNodeOptions = struct {
    composed: bool = false,
};
