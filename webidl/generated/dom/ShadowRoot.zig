// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const A = @import("a").A;
const AND = @import("a_n_d").AND;
const ATTRIBUTE_NODE = @import("a_t_t_r_i_b_u_t_e__n_o_d_e").ATTRIBUTE_NODE;
const AbortSignal = @import("abort_signal").AbortSignal;
const AbortSignalType = @import("abort_signal_type").AbortSignalType;
const Add = @import("add").Add;
const AddEventListenerOptions = @import("add_event_listener_options").AddEventListenerOptions;
const Algorithm = @import("algorithm").Algorithm;
const All = @import("all").All;
const Allocator = @import("std.mem").Allocator;
const AnEventListener = @import("an_event_listener").AnEventListener;
const Ancestor = @import("ancestor").Ancestor;
const Append = @import("append").Append;
const Assert = @import("assert").Assert;
const Attach = @import("attach").Attach;
const Attr = @import("attr").Attr;
const AttributeType = @import("attribute_type").AttributeType;
const B = @import("b").B;
const Before = @import("before").Before;
const ById = @import("by_id").ById;
const CDATASection = @import("c_d_a_t_a_section").CDATASection;
const CDATA_SECTION_NODE = @import("c_d_a_t_a__s_e_c_t_i_o_n__n_o_d_e").CDATA_SECTION_NODE;
const COMMENT_NODE = @import("c_o_m_m_e_n_t__n_o_d_e").COMMENT_NODE;
const Call = @import("call").Call;
const Cast = @import("cast").Cast;
const CharacterData = @import("character_data").CharacterData;
const Check = @import("check").Check;
const Child = @import("child").Child;
const ChildNode = @import("child_node").ChildNode;
const ChildNodeMixin = @import("child_node_mixin").ChildNodeMixin;
const ChildNodes = @import("child_nodes").ChildNodes;
const Children = @import("children").Children;
const Clean = @import("clean").Clean;
const Clone = @import("clone").Clone;
const Cloning = @import("cloning").Cloning;
const Comment = @import("comment").Comment;
const Content = @import("content").Content;
const Count = @import("count").Count;
const Create = @import("create").Create;
const Custom = @import("custom").Custom;
const CustomElementRegistry = @import("custom_element_registry").CustomElementRegistry;
const DOCUMENT_FRAGMENT_NODE = @import("d_o_c_u_m_e_n_t__f_r_a_g_m_e_n_t__n_o_d_e").DOCUMENT_FRAGMENT_NODE;
const DOCUMENT_NODE = @import("d_o_c_u_m_e_n_t__n_o_d_e").DOCUMENT_NODE;
const DOCUMENT_POSITION_CONTAINED_BY = @import("d_o_c_u_m_e_n_t__p_o_s_i_t_i_o_n__c_o_n_t_a_i_n_e_d__b_y").DOCUMENT_POSITION_CONTAINED_BY;
const DOCUMENT_POSITION_CONTAINS = @import("d_o_c_u_m_e_n_t__p_o_s_i_t_i_o_n__c_o_n_t_a_i_n_s").DOCUMENT_POSITION_CONTAINS;
const DOCUMENT_POSITION_DISCONNECTED = @import("d_o_c_u_m_e_n_t__p_o_s_i_t_i_o_n__d_i_s_c_o_n_n_e_c_t_e_d").DOCUMENT_POSITION_DISCONNECTED;
const DOCUMENT_POSITION_FOLLOWING = @import("d_o_c_u_m_e_n_t__p_o_s_i_t_i_o_n__f_o_l_l_o_w_i_n_g").DOCUMENT_POSITION_FOLLOWING;
const DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = @import("d_o_c_u_m_e_n_t__p_o_s_i_t_i_o_n__i_m_p_l_e_m_e_n_t_a_t_i_o_n__s_p_e_c_i_f_i_c").DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
const DOCUMENT_POSITION_PRECEDING = @import("d_o_c_u_m_e_n_t__p_o_s_i_t_i_o_n__p_r_e_c_e_d_i_n_g").DOCUMENT_POSITION_PRECEDING;
const DOCUMENT_TYPE_NODE = @import("d_o_c_u_m_e_n_t__t_y_p_e__n_o_d_e").DOCUMENT_TYPE_NODE;
const DOM = @import("d_o_m").DOM;
const Data = @import("data").Data;
const Default = @import("default").Default;
const DefaultNamespace = @import("default_namespace").DefaultNamespace;
const Descendant = @import("descendant").Descendant;
const DescendantText = @import("descendant_text").DescendantText;
const DescendantTextContent = @import("descendant_text_content").DescendantTextContent;
const Determine = @import("determine").Determine;
const Dispatch = @import("dispatch").Dispatch;
const Do = @import("do").Do;
const Document = @import("document").Document;
const DocumentFragment = @import("document_fragment").DocumentFragment;
const DocumentFragmentBase = @import("document_fragment_base").DocumentFragmentBase;
const DocumentOrShadowRoot = @import("document_or_shadow_root").DocumentOrShadowRoot;
const DocumentPosition = @import("document_position").DocumentPosition;
const DocumentType = @import("document_type").DocumentType;
const Don = @import("don").Don;
const ELEMENT_NODE = @import("e_l_e_m_e_n_t__n_o_d_e").ELEMENT_NODE;
const Each = @import("each").Each;
const Early = @import("early").Early;
const Element = @import("element").Element;
const Elements = @import("elements").Elements;
const Ensure = @import("ensure").Ensure;
const Equals = @import("equals").Equals;
const Event = @import("event").Event;
const EventListener = @import("event_target").EventListener;
const EventListenerList = @import("event_listener_list").EventListenerList;
const EventListenerOptions = @import("event_listener_options").EventListenerOptions;
const EventListenerRemoval = @import("event_listener_removal").EventListenerRemoval;
const EventListenerRemovalContext = @import("event_listener_removal_context").EventListenerRemovalContext;
const EventTarget = @import("event_target").EventTarget;
const ExistingAttributeValue = @import("existing_attribute_value").ExistingAttributeValue;
const Field = @import("field").Field;
const Filter = @import("filter").Filter;
const First = @import("first").First;
const Flatten = @import("flatten").Flatten;
const For = @import("for").For;
const FromPtr = @import("from_ptr").FromPtr;
const Full = @import("full").Full;
const Get = @import("get").Get;
const GetRootNodeOptions = @import("get_root_node_options").GetRootNodeOptions;
const Getters = @import("getters").Getters;
const HTML = @import("h_t_m_l").HTML;
const HTMLCollection = @import("h_t_m_l_collection").HTMLCollection;
const Handle = @import("handle").Handle;
const Helper = @import("helper").Helper;
const HierarchyRequestError = @import("hierarchy_request_error").HierarchyRequestError;
const ID = @import("i_d").ID;
const If = @import("if").If;
const InclusiveDescendant = @import("inclusive_descendant").InclusiveDescendant;
const Initialize = @import("initialize").Initialize;
const Inline = @import("inline").Inline;
const Insert = @import("insert").Insert;
const Inserts = @import("inserts").Inserts;
const InvalidStateError = @import("invalid_state_error").InvalidStateError;
const Iterate = @import("iterate").Iterate;
const JSValue = @import("j_s_value").JSValue;
const Legacy = @import("legacy").Legacy;
const Let = @import("let").Let;
const Locate = @import("locate").Locate;
const Looking = @import("looking").Looking;
const Match = @import("match").Match;
const MatchSelectorsString = @import("match_selectors_string").MatchSelectorsString;
const MoreOptions = @import("more_options").MoreOptions;
const Move = @import("move").Move;
const Moves = @import("moves").Moves;
const MutationObserver = @import("mutation_observer").MutationObserver;
const NOTE = @import("n_o_t_e").NOTE;
const Name = @import("name").Name;
const NamedItem = @import("named_item").NamedItem;
const Namespace = @import("namespace").Namespace;
const NamespacePrefix = @import("namespace_prefix").NamespacePrefix;
const NoDocument = @import("no_document").NoDocument;
const Node = @import("node").Node;
const NodeInternal = @import("node_internal").NodeInternal;
const NodeList = @import("node_list").NodeList;
const NodeOrDOMString = @import("node_or_d_o_m_string").NodeOrDOMString;
const NodeType = @import("node_type").NodeType;
const NodesIntoNode = @import("nodes_into_node").NodesIntoNode;
const Normalize = @import("normalize").Normalize;
const Not = @import("not").Not;
const NotFoundError = @import("not_found_error").NotFoundError;
const NotSupportedError = @import("not_supported_error").NotSupportedError;
const Note = @import("note").Note;
const Options = @import("options").Options;
const OptionsType = @import("options_type").OptionsType;
const Or = @import("or").Or;
const Otherwise = @import("otherwise").Otherwise;
const OwnedSlice = @import("owned_slice").OwnedSlice;
const PI = @import("p_i").PI;
const PROCESSING_INSTRUCTION_NODE = @import("p_r_o_c_e_s_s_i_n_g__i_n_s_t_r_u_c_t_i_o_n__n_o_d_e").PROCESSING_INSTRUCTION_NODE;
const ParentNode = @import("parent_node").ParentNode;
const PassiveValue = @import("passive_value").PassiveValue;
const Per = @import("per").Per;
const Populate = @import("populate").Populate;
const Pre = @import("pre").Pre;
const PreInsertValidity = @import("pre_insert_validity").PreInsertValidity;
const Preceding = @import("preceding").Preceding;
const ProcessingInstruction = @import("processing_instruction").ProcessingInstruction;
const Recursively = @import("recursively").Recursively;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const Registry = @import("registry").Registry;
const Remove = @import("remove").Remove;
const Replace = @import("replace").Replace;
const ReplaceAll = @import("replace_all").ReplaceAll;
const Replaces = @import("replaces").Replaces;
const Return = @import("return").Return;
const Returns = @import("returns").Returns;
const Run = @import("run").Run;
const SameObject = @import("same_object").SameObject;
const SearchHelper = @import("search_helper").SearchHelper;
const ServiceWorkerGlobalScope = @import("service_worker_global_scope").ServiceWorkerGlobalScope;
const Set = @import("set").Set;
const ShadowRootMode = @import("shadow_root_mode").ShadowRootMode;
const Sibling = @import("sibling").Sibling;
const SingleNode = @import("single_node").SingleNode;
const Slice = @import("slice").Slice;
const SlotAssignmentMode = @import("slot_assignment_mode").SlotAssignmentMode;
const Spec = @import("spec").Spec;
const Specifications = @import("specifications").Specifications;
const Step = @import("step").Step;
const Steps = @import("steps").Steps;
const Switch = @import("switch").Switch;
const TEXT_NODE = @import("t_e_x_t__n_o_d_e").TEXT_NODE;
const TODO = @import("t_o_d_o").TODO;
const Target = @import("target").Target;
const Text = @import("text").Text;
const TextContent = @import("text_content").TextContent;
const The = @import("the").The;
const Then = @import("then").Then;
const This = @import("this").This;
const Throws = @import("throws").Throws;
const Traverse = @import("traverse").Traverse;
const Trusted = @import("trusted").Trusted;
const Try = @import("try").Try;
const TypeOf = @import("type_of").TypeOf;
const URI = @import("u_r_i").URI;
const URL = @import("u_r_l").URL;
const Use = @import("use").Use;
const Value = @import("value").Value;
const We = @import("we").We;
const When = @import("when").When;
const Window = @import("window").Window;
const XML = @import("x_m_l").XML;
const XMLNS = @import("x_m_l_n_s").XMLNS;
const anyopaque = @import("anyopaque").anyopaque;
const std = @import("std");
const std.ArrayList(EventListener) = @import("std._array_list(_event_listener)").std.ArrayList(EventListener);
const webidl = @import("webidl");


/// DOM §4.8.1 - ShadowRootMode enum
///
/// Defines the mode of a shadow root.
/// DOM §4.8.1 - SlotAssignmentMode enum
///
/// Defines how slottables are assigned to slots.
/// DOM §4.8.1 - ShadowRoot interface
///
/// Shadow roots are DocumentFragments that serve as the root of a shadow tree.
/// A shadow root is always attached to another node tree through its host element.

/// Compare two callbacks for equality (from EventTarget)
pub fn callbackEquals(a: ?webidl.JSValue, b: ?webidl.JSValue) bool {
    if (a == null and b == null) return true;
    if (a == null or b == null) return false;
    const a_val = a.?;
    const b_val = b.?;
    if (@as(std.meta.Tag(webidl.JSValue), a_val) != @as(std.meta.Tag(webidl.JSValue), b_val)) {
        return false;
    }
    return switch (a_val) {
        .undefined, .null => true,
        .boolean => |a_bool| a_bool == b_val.boolean,
        .number => |a_num| a_num == b_val.number,
        .string => |a_str| std.mem.eql(u8, a_str, b_val.string),
        .object => |a_obj| @intFromPtr(&a_obj) == @intFromPtr(&b_val.object),
        else => false,
    };
}

pub const ShadowRoot = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    event_listener_list: ?*std.ArrayList(EventListener),
    custom_element_registry: ?*anyopaque,

    // ========================================================================
    // Constants
    // ========================================================================

    // Node type constants (inherited)
    pub const ELEMENT_NODE: u16 = Node.ELEMENT_NODE;
    pub const ATTRIBUTE_NODE: u16 = Node.ATTRIBUTE_NODE;
    pub const TEXT_NODE: u16 = Node.TEXT_NODE;
    pub const CDATA_SECTION_NODE: u16 = Node.CDATA_SECTION_NODE;
    pub const PROCESSING_INSTRUCTION_NODE: u16 = Node.PROCESSING_INSTRUCTION_NODE;
    pub const COMMENT_NODE: u16 = Node.COMMENT_NODE;
    pub const DOCUMENT_NODE: u16 = Node.DOCUMENT_NODE;
    pub const DOCUMENT_TYPE_NODE: u16 = Node.DOCUMENT_TYPE_NODE;
    pub const DOCUMENT_FRAGMENT_NODE: u16 = Node.DOCUMENT_FRAGMENT_NODE;

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: Allocator,
        host: *Element,
        mode: ShadowRootMode,
        delegates_focus: bool,
        slot_assignment: SlotAssignmentMode,
        clonable: bool,
        serializable: bool,
    ) !ShadowRoot {

        return .{
            .allocator = allocator,
            .host_element = host,
            .shadow_mode = mode,
            .delegates_focus_flag = delegates_focus,
            .slot_assignment_mode = slot_assignment,
            .clonable_flag = clonable,
            .serializable_flag = serializable,
            .available_to_element_internals = false,
            .declarative_flag = false,
            .keep_custom_element_registry_null = false,
            // custom_element_registry comes from DocumentOrShadowRoot mixin
        };
    
    }

    pub fn get_children(self: anytype) !*HTMLCollection {

        const NodeType = @import("node").Node;
        const allocator = self.allocator;

        // Create HTMLCollection
        const collection = try allocator.create(HTMLCollection);
        collection.* = try HTMLCollection.init(allocator);

        // Filter child_nodes for elements only (ELEMENT_NODE = 1)
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                const element: *Element = @ptrCast(child);
                try collection.addElement(element);
            }
        }

        return collection;
    
    }

    pub fn get_firstElementChild(self: anytype) ?*Element {

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in tree order
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    
    }

    pub fn get_lastElementChild(self: anytype) ?*Element {

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in reverse tree order
        var i: usize = self.child_nodes.items.len;
        while (i > 0) {
            i -= 1;
            const child = self.child_nodes.items[i];
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    
    }

    pub fn get_childElementCount(self: anytype) u32 {

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Count children that are Elements
        var count: u32 = 0;
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                count += 1;
            }
        }

        return count;
    
    }

    pub fn call_prepend(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Pre-insert node into this before this's first child
        const first_child = this_node.get_firstChild();
        _ = try mutation.preInsert(node, this_node, first_child);
    }

    /// DOM §4.3.2 - ParentNode.append()
    /// Inserts nodes after the last child, while replacing strings with Text nodes.
    ///
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Append node to this.
    ///
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_append(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Append node to this
        _ = try mutation.append(node, this_node);
    }

    /// DOM §4.3.2 - ParentNode.replaceChildren()
    /// Replaces all children with nodes, while replacing strings with Text nodes.
    ///
    /// Steps:
    /// 1. Let node be the result of converting nodes into a node given nodes and this's node document.
    /// 2. Ensure pre-insert validity of node into this before null.
    /// 3. Replace all with node within this.
    ///
    /// Throws HierarchyRequestError if constraints violated.
    pub fn call_replaceChildren(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Ensure pre-insert validity of node into this before null
        try mutation.ensurePreInsertValidity(node, this_node, null);

        // Step 3: Replace all with node within this
        try mutation.replaceAll(node, this_node);
    }

    /// DOM §4.3.2 - ParentNode.moveBefore()
    /// Moves, without first removing, movedNode into this after child.
    /// This method preserves state associated with movedNode.
    ///
    /// Spec: https://dom.spec.whatwg.org/#dom-parentnode-movebefore
    ///
    /// Steps:
    /// 1. Let referenceChild be child.
    /// 2. If referenceChild is node, then set referenceChild to node's next sibling.
    /// 3. Move node into this before referenceChild.
    ///
    /// Throws HierarchyRequestError if constraints violated, or state cannot be preserved.
    pub fn call_moveBefore(self: anytype, node: anytype, child: anytype) !void {

        const mutation = @import("dom").mutation;

        // Get Node pointers from the anytype parameters
        const parent_node = @as(*@import("node").Node, @ptrCast(self));
        const moved_node = @as(*@import("node").Node, @ptrCast(node));
        const child_node = if (child) |c| @as(?*@import("node").Node, @ptrCast(c)) else null;

        // Step 1: Let referenceChild be child
        var reference_child = child_node;

        // Step 2: If referenceChild is node, then set referenceChild to node's next sibling
        if (reference_child == moved_node) {
            reference_child = moved_node.next_sibling;
        }

        // Step 3: Move node into this before referenceChild
        try mutation.move(moved_node, parent_node, reference_child);
    
    }

    pub fn call_querySelector(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !?*Element {

        // Run scope-match a selectors string against this
        const matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Return first result if not empty; otherwise null
        if (matches.items.len > 0) {
            return matches.items[0];
        }

        return null;
    
    }

    pub fn call_querySelectorAll(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !*NodeList {

        // Run scope-match a selectors string against this
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Create NodeList and populate with matches (static snapshot)
        var node_list = try allocator.create(NodeList);
        node_list.* = try NodeList.init(allocator);

        // Add all matched elements to the NodeList
        for (matches.items) |element| {
            // Cast Element to Node
            const node = @as(*@import("node").Node, @ptrCast(element));
            try node_list.addNode(node);
        }

        return node_list;
    
    }

    pub fn call_getElementById(self: anytype, allocator: std.mem.Allocator, element_id: []const u8) !?*Element {

        _ = allocator; // Not needed for traversal

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Inline recursive search to avoid private function copying issues with codegen
        const SearchHelper = struct {
            fn findById(nodes: anytype, target_id: []const u8) ?*Element {
                for (nodes) |node| {
                    // Check if this node is an element with matching ID
                    if (node.node_type == NodeType.ELEMENT_NODE) {
                        // Cast to Element to access ID
                        const element: *Element = @ptrCast(node);

                        // Check if id attribute matches
                        // Per spec: element's ID is the value of its "id" attribute
                        const attributes = element.get_attributes();
                        if (attributes.call_getNamedItem("id")) |id_attr| {
                            if (std.mem.eql(u8, id_attr.value, target_id)) {
                                return element;
                            }
                        }
                    }

                    // Recursively search descendants
                    if (findById(node.child_nodes.items, target_id)) |found| {
                        return found;
                    }
                }

                return null;
            }
        };

        // Traverse descendants in tree order (preorder depth-first)
        return SearchHelper.findById(self.child_nodes.items, element_id);
    
    }

    pub fn deinit(self: *Node) void {

        // NOTE: EventTarget parent cleanup is handled by codegen
        self.child_nodes.deinit();
        self.registered_observers.deinit();

        // Clean up cached NodeList if it exists
        if (self.cached_child_nodes) |list| {
            list.deinit();
            self.allocator.destroy(list);
        }
    
    }

    pub fn call_insertBefore(self: *Node, node: *Node, child: ?*Node) !*Node {

        // Call mutation.preInsert algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preInsert(node, self, child) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    
    }

    pub fn call_appendChild(self: *Node, node: *Node) !*Node {

        // Call mutation.append algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.append(node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    
    }

    pub fn call_replaceChild(self: *Node, node: *Node, child: *Node) !*Node {

        // Call mutation.replace algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.replace(child, node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    
    }

    pub fn call_removeChild(self: *Node, child: *Node) !*Node {

        // Call mutation.preRemove algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preRemove(child, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    
    }

    pub fn call_getRootNode(self: *Node, options: ?GetRootNodeOptions) *Node {

        const tree = @import("dom").tree;

        // Check if we need shadow-including root
        const composed = if (options) |opts| opts.composed else false;

        if (composed) {
            // Return shadow-including root (DOM §4.2.2.4)
            // Algorithm:
            // 1. Let root be node's root
            // 2. If root is a shadow root, return root's host's shadow-including root
            // 3. Return root
            var root = tree.root(self);

            // Check if root is a ShadowRoot by checking type_tag
            while (root.base.type_tag == .ShadowRoot) {
                // Cast to ShadowRoot to access host
                const shadow_root: *ShadowRoot = @ptrCast(@alignCast(root));

                // Get the host element (which is a Node)
                const host_element = shadow_root.host_element;
                const host_node: *Node = @ptrCast(@alignCast(&host_element.base));

                // Get host's root (might be another shadow root)
                root = tree.root(host_node);
            }

            return root;
        } else {
            // Return regular root
            return tree.root(self);
        }
    
    }

    pub fn call_contains(self: *const Node, other: ?*const Node) bool {
        if (other == null) return false;
        // Check if other is an inclusive descendant of this
        const tree = @import("dom").tree;
        const other_node = other.?;
        return tree.isInclusiveDescendant(other_node, self);
    }

    /// compareDocumentPosition(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    pub fn call_compareDocumentPosition(self: *const Node, other: *const Node) u16 {

        const tree = @import("dom").tree;

        // Step 1: If this is other, then return zero
        if (self == other) {
            return 0;
        }

        // Step 2: Let node1 be other and node2 be this
        const node1 = other;
        const node2 = self;

        // Step 3: Let attr1 and attr2 be null
        // Step 4-5: Handle attributes (not implemented yet - attributes don't participate in tree)
        // For now, we skip attribute handling as Attr nodes are handled separately

        // Step 6: If node1 or node2 is null, or node1's root is not node2's root
        // Check if nodes are in the same tree by comparing roots
        const root1 = tree.root(@constCast(node1));
        const root2 = tree.root(@constCast(node2));

        if (root1 != root2) {
            // Return disconnected + implementation specific + preceding/following
            // Use pointer comparison for consistent ordering
            const ptr1 = @intFromPtr(node1);
            const ptr2 = @intFromPtr(node2);
            const ordering = if (ptr1 < ptr2) Node.DOCUMENT_POSITION_PRECEDING else Node.DOCUMENT_POSITION_FOLLOWING;
            return Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | ordering;
        }

        // Step 7: If node1 is an ancestor of node2
        if (tree.isAncestor(node1, node2)) {
            return Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 8: If node1 is a descendant of node2
        if (tree.isDescendant(node1, node2)) {
            return Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING;
        }

        // Step 9: If node1 is preceding node2
        if (tree.isPreceding(node1, node2)) {
            return Node.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 10: Return DOCUMENT_POSITION_FOLLOWING
        return Node.DOCUMENT_POSITION_FOLLOWING;
    
    }

    pub fn call_isEqualNode(self: *const Node, other_node: ?*const Node) bool {
        // Step 1: Return true if otherNode is non-null and this equals otherNode
        if (other_node == null) return false;
        return Node.nodeEquals(self, other_node.?);
    }

    /// Node A equals node B - DOM Spec algorithm
    /// A node A equals a node B if all of the following conditions are true:
    /// - A and B implement the same interfaces
    /// - Node-specific properties are equal
    /// - If A is an element, each attribute in its list equals an attribute in B's list
    /// - A and B have the same number of children
    /// - Each child of A equals the child of B at the identical index
    pub fn nodeEquals(a: *const Node, b: *const Node) bool {

        // Step 1: A and B implement the same interfaces (check node_type)
        if (a.node_type != b.node_type) return false;

        // Step 2: Check node-type-specific properties
        switch (a.node_type) {
            DOCUMENT_TYPE_NODE => {
                // DocumentType: check name, public ID, and system ID
                const DocumentType = @import("document_type").DocumentType;
                const doctype_a: *const DocumentType = @ptrCast(@alignCast(a));
                const doctype_b: *const DocumentType = @ptrCast(@alignCast(b));

                // Check name
                if (!std.mem.eql(u8, doctype_a.name, doctype_b.name)) return false;

                // Check public ID
                if (!std.mem.eql(u8, doctype_a.public_id, doctype_b.public_id)) return false;

                // Check system ID
                if (!std.mem.eql(u8, doctype_a.system_id, doctype_b.system_id)) return false;
            },
            ELEMENT_NODE => {
                // Element: check namespace, namespace prefix, local name, and attribute list size
                const elem_a: *const Element = @ptrCast(@alignCast(a));
                const elem_b: *const Element = @ptrCast(@alignCast(b));

                // Check namespace
                if (elem_a.namespace_uri == null and elem_b.namespace_uri != null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri == null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri != null) {
                    if (!std.mem.eql(u8, elem_a.namespace_uri.?, elem_b.namespace_uri.?)) return false;
                }

                // Check local name (tag_name)
                if (!std.mem.eql(u8, elem_a.tag_name, elem_b.tag_name)) return false;

                // Check attribute list size
                if (elem_a.attributes.len != elem_b.attributes.len) return false;

                // Step 3: Each attribute in A's list has an equal attribute in B's list
                for (elem_a.attributes.items) |attr_a| {
                    var found = false;
                    for (elem_b.attributes.items) |attr_b| {
                        if (Node.attributeEquals(&attr_a, &attr_b)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) return false;
                }
            },
            ATTRIBUTE_NODE => {
                // Attr: check namespace, local name, and value
                // Note: Attr nodes don't participate in tree, but we check for completeness
                const attr_a: *const Attr = @ptrCast(@alignCast(a));
                const attr_b: *const Attr = @ptrCast(@alignCast(b));
                return Node.attributeEquals(attr_a, attr_b);
            },
            PROCESSING_INSTRUCTION_NODE => {
                // ProcessingInstruction: check target and data
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi_a: *const PI = @ptrCast(@alignCast(a));
                const pi_b: *const PI = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, pi_a.target, pi_b.target)) return false;
                if (!std.mem.eql(u8, pi_a.data, pi_b.data)) return false;
            },
            TEXT_NODE, COMMENT_NODE, CDATA_SECTION_NODE => {
                // Text, Comment, CDATASection: check data
                const cd_a: *const CharacterData = @ptrCast(@alignCast(a));
                const cd_b: *const CharacterData = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, cd_a.data, cd_b.data)) return false;
            },
            else => {
                // For other node types, basic node_name check is sufficient
                if (!std.mem.eql(u8, a.node_name, b.node_name)) return false;
            },
        }

        // Step 4: A and B have the same number of children
        if (a.child_nodes.len != b.child_nodes.len) return false;

        // Step 5: Each child of A equals the child of B at the identical index
        for (a.child_nodes.items, 0..) |child_a, i| {
            const child_b = b.child_nodes.items[i];
            if (!Node.nodeEquals(child_a, child_b)) return false;
        }

        return true;
    
    }

    pub fn attributeEquals(a: *const @import("attr").Attr, b: *const @import("attr").Attr) bool {

        // Check namespace
        if (a.namespace_uri == null and b.namespace_uri != null) return false;
        if (a.namespace_uri != null and b.namespace_uri == null) return false;
        if (a.namespace_uri != null and b.namespace_uri != null) {
            if (!std.mem.eql(u8, a.namespace_uri.?, b.namespace_uri.?)) return false;
        }

        // Check local name
        if (!std.mem.eql(u8, a.local_name, b.local_name)) return false;

        // Check value
        if (!std.mem.eql(u8, a.value, b.value)) return false;

        return true;
    
    }

    pub fn call_isSameNode(self: *const Node, other_node: ?*const Node) bool {
        // Legacy alias of === (pointer equality)
        if (other_node == null) return false;
        return self == other_node.?;
    }

    /// hasChildNodes()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-haschildnodes
    pub fn call_hasChildNodes(self: *const Node) bool {
        return self.child_nodes.len > 0;
    }

    /// cloneNode(deep)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-clonenode
    pub fn call_cloneNode(self: *Node, deep: bool) !*Node {

        // Step 1: If this is a shadow root, throw NotSupportedError
        if (self.node_type == Node.DOCUMENT_FRAGMENT_NODE) {
            // Check if this is specifically a ShadowRoot
            // ShadowRoot inherits from DocumentFragment, so we need to check the type tag
            const DocumentFragmentBase = @import("document_fragment").DocumentFragmentBase;

            // Try to access as DocumentFragmentBase to check type tag
            // This is safe because DocumentFragment/ShadowRoot have base as first field
            const frag_base: *const DocumentFragmentBase = @ptrCast(@alignCast(self));
            if (frag_base.type_tag == .ShadowRoot) {
                return error.NotSupportedError;
            }
        }

        // Step 2: Return the result of cloning this node with subtree set to deep
        return try Node.cloneNodeInternal(self, self.owner_document, deep, null, null);
    
    }

    pub fn cloneNodeInternal(
        node: *Node,
        document_param: ?*Document,
        subtree: bool,
        parent: ?*Node,
        fallback_registry: ?*anyopaque, // CustomElementRegistry - not implemented yet
    ) !*Node {

        // Step 1: Let document be document_param or node's owner_document
        const document = document_param orelse node.owner_document;

        // Assert: node is not a document or node is document
        // (We don't have full Document implementation yet, skip this assert)

        // Step 2: Let copy be the result of cloning a single node
        var copy = try Node.cloneSingleNode(node, document, fallback_registry);

        // Step 3: Run any cloning steps defined for node
        // Specifications may define cloning steps for specific node types
        if (node.cloning_steps_hook) |hook| {
            try hook(node, copy, subtree);
        }

        // Step 4: If parent is non-null, append copy to parent
        if (parent) |p| {
            try p.child_nodes.append(copy);
            copy.parent_node = p;
        }

        // Step 5: If subtree is true, clone all children recursively
        if (subtree) {
            for (node.child_nodes.items) |child| {
                _ = try Node.cloneNodeInternal(child, document, subtree, copy, fallback_registry);
            }
        }

        // Step 6: If node is an element, node is shadow host, and shadow root is clonable, clone shadow
        if (node.node_type == Node.ELEMENT_NODE) {
            const elem: *const Element = @ptrCast(@alignCast(node));
            if (elem.shadow_root) |shadow| {
                // Check if shadow root is clonable
                if (shadow.clonable_flag) {
                    // Clone the shadow root per spec
                    const copy_elem: *Element = @ptrCast(@alignCast(copy));

                    // Assert: copy is not a shadow host (should be true since we just created it)
                    std.debug.assert(copy_elem.shadow_root == null);

                    // Step 6.2-6.4: Determine shadow root registry and attach shadow root
                    //
                    // Per spec (DOM §4.2.7):
                    // - If node's shadow root's custom element registry is non-null, use it
                    // - Otherwise, if fallbackRegistry is non-null, use fallbackRegistry
                    // - Otherwise, set registry to null
                    //
                    // NOTE: Custom element registry is part of the HTML spec, not DOM spec.
                    // Full implementation requires:
                    // - ShadowRoot.custom_element_registry field (currently not present)
                    // - CustomElementRegistry type and implementation
                    // - Registry scoping logic
                    //
                    // For now, we pass null for the registry. When custom elements are
                    // implemented, fallback_registry will be used here to determine the
                    // registry for the cloned shadow root.

                    // Attach shadow root to copy
                    var copy_shadow = try ShadowRoot.init(
                        copy.allocator,
                        copy_elem,
                        shadow.shadow_mode,
                        shadow.delegates_focus_flag,
                        shadow.slot_assignment_mode,
                        shadow.clonable_flag,
                        shadow.serializable_flag,
                        shadow.available_to_element_internals,
                        false, // declarative will be set next
                    );

                    // Step 6.5: Set copy's shadow root's declarative to node's shadow root's declarative
                    copy_shadow.declarative_flag = shadow.declarative_flag;

                    copy_elem.shadow_root = &copy_shadow;

                    // Step 6.6: Clone shadow root children
                    const shadow_node = shadow.asNode();
                    for (shadow_node.child_nodes.items) |child| {
                        const copy_shadow_node = copy_shadow.asNode();
                        _ = try Node.cloneNodeInternal(child, document, subtree, copy_shadow_node, null);
                    }
                }
            }
        }

        // Step 7: Return copy
        return copy;
    
    }

    pub fn cloneSingleNode(
        node: *Node,
        document: ?*Document,
        fallback_registry: ?*anyopaque,
    ) !*Node {

        _ = fallback_registry; // Not used yet - for custom elements

        // Step 2-3: Handle different node types
        switch (node.node_type) {
            Node.ELEMENT_NODE => {
                // Clone element with attributes
                const elem: *Element = @ptrCast(@alignCast(node));

                // Create new element
                var copy_elem = try Element.init(elem.allocator, elem.tag_name);
                copy_elem.namespace_uri = elem.namespace_uri;

                // Clone attributes
                for (elem.attributes.items) |attr| {
                    const copy_attr = Attr{
                        .allocator = elem.allocator,
                        .namespace_uri = attr.namespace_uri,
                        .prefix = attr.prefix,
                        .local_name = attr.local_name,
                        .value = attr.value,
                        .owner_element = &copy_elem,
                    };
                    try copy_elem.attributes.append(copy_attr);
                }

                const copy_node = @as(*Node, @ptrCast(&copy_elem));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Clone CharacterData (Text, Comment, CDATASection)
                const cd: *CharacterData = @ptrCast(@alignCast(node));

                var copy_cd = try CharacterData.init(cd.allocator);
                copy_cd.data = try cd.allocator.dupe(u8, cd.data);

                const copy_node = @as(*Node, @ptrCast(&copy_cd));
                copy_node.node_type = node.node_type;
                copy_node.node_name = node.node_name;
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.PROCESSING_INSTRUCTION_NODE => {
                // Clone ProcessingInstruction
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi: *PI = @ptrCast(@alignCast(node));

                var copy_pi = try PI.init(pi.allocator, pi.target, pi.data);

                const copy_node = @as(*Node, @ptrCast(&copy_pi));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.ATTRIBUTE_NODE => {
                // Clone Attr
                const attr: *Attr = @ptrCast(@alignCast(node));

                var copy_attr = try Attr.init(
                    attr.allocator,
                    attr.namespace_uri,
                    attr.prefix,
                    attr.local_name,
                    attr.value,
                );

                const copy_node = @as(*Node, @ptrCast(&copy_attr));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.DOCUMENT_TYPE_NODE => {
                // Clone DocumentType (simplified - full implementation needs public ID, system ID)
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_FRAGMENT_NODE => {
                // Clone DocumentFragment
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_NODE => {
                // Cloning Document is complex and not fully supported yet
                // For now, just create a basic copy
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            else => {
                // Default: create basic node copy
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
        }
    
    }

    pub fn call_normalize(self: *Node) void {
        _ = self;
        // Normalize adjacent text nodes
    }

    /// Getters
    pub fn get_nodeType(self: *const Node) u16 {
        return self.node_type;
    }

    pub fn get_nodeName(self: *const Node) []const u8 {
        return self.node_name;
    }

    pub fn get_parentNode(self: *const Node) ?*Node {
        return self.parent_node;
    }

    pub fn get_parentElement(self: *const Node) ?*Element {

        // Returns parent if it's an Element, null otherwise
        const parent = self.parent_node orelse return null;
        if (parent.node_type == ELEMENT_NODE) {
            // Cast to Element - safe because we checked node_type
            return @ptrCast(@alignCast(parent));
        }
        return null;
    
    }

    pub fn get_childNodes(self: *Node) !*@import("node_list").NodeList {

        // [SameObject] - Return the same NodeList object each time
        // The NodeList is a live view of this node's children

        if (self.cached_child_nodes) |list| {
            return list;
        }

        // Create new NodeList on first access
        const list = try self.allocator.create(NodeList);
        list.* = try NodeList.init(self.allocator);

        // Populate with current children (live view will track changes)
        for (self.child_nodes.items) |child| {
            try list.addNode(child);
        }

        self.cached_child_nodes = list;
        return list;
    
    }

    pub fn get_firstChild(self: *const Node) ?*Node {

        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(0);
        }
        return null;
    
    }

    pub fn get_lastChild(self: *const Node) ?*Node {

        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(self.child_nodes.len - 1);
        }
        return null;
    
    }

    pub fn get_ownerDocument(self: *const Node) ?*Document {
        return self.owner_document;
    }

    pub fn get_previousSibling(self: *const Node) ?*Node {

        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i == 0) return null;
                return parent.child_nodes.items[i - 1];
            }
        }
        return null;
    
    }

    pub fn get_nextSibling(self: *const Node) ?*Node {

        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i + 1 >= parent.child_nodes.items.len) return null;
                return parent.child_nodes.items[i + 1];
            }
        }
        return null;
    
    }

    pub fn get_isConnected(self: *const Node) bool {
        // A node is connected if its root is a document
        const tree = @import("dom").tree;
        // tree.root requires mutable pointer but doesn't actually mutate
        // Cast to mutable for the algorithm (safe for read-only root traversal)
        const mutable_self = @constCast(self);
        const root_node = tree.root(mutable_self);
        // Check if root is a document (node_type == DOCUMENT_NODE)
        return root_node.node_type == DOCUMENT_NODE;
    }

    /// DOM §4.4 - Node.baseURI getter
    /// Returns this's node document's document base URL, serialized.
    ///
    /// The baseURI getter steps are to return this's node document's
    /// document base URL, serialized.
    pub fn get_baseURI(self: *const Node) []const u8 {

        // Get owner document
        const doc = self.owner_document orelse {
            // If no owner document, return empty string (should not happen in normal DOM)
            return "about:blank";
        };

        // Return document's base URI
        return doc.base_uri;
    
    }

    pub fn get_nodeValue(self: *const Node) ?[]const u8 {

        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // The nodeValue getter steps are to return the following, switching on the interface:
        // - Attr: this's value
        // - CharacterData: this's data
        // - Otherwise: null

        switch (self.node_type) {
            ATTRIBUTE_NODE => {
                // Attr node
                const attr: *const Attr = @ptrCast(@alignCast(self));
                return attr.value;
            },
            TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE => {
                // CharacterData nodes (Text, Comment, ProcessingInstruction, CDATASection)
                const char_data: *const CharacterData = @ptrCast(@alignCast(self));
                return char_data.data;
            },
            else => {
                // All other node types return null
                return null;
            },
        }
    
    }

    pub fn set_nodeValue(self: *Node, value: ?[]const u8) !void {

        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // The nodeValue setter steps are to, if given value is null, act as if it was empty string
        // Then:
        // - Attr: Set an existing attribute value with this and the given value
        // - CharacterData: Replace data with node this, offset 0, count this's length, data given value
        // - Otherwise: Do nothing

        const str_value = value orelse "";

        switch (self.node_type) {
            ATTRIBUTE_NODE => {
                // Attr node - set an existing attribute value
                const attr: *Attr = @ptrCast(@alignCast(self));
                // Use "set an existing attribute value" algorithm from Attr
                try Attr.setExistingAttributeValue(attr, str_value);
            },
            TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE => {
                // CharacterData nodes - replace data
                const char_data: *CharacterData = @ptrCast(@alignCast(self));
                // Replace data: offset 0, count = length, data = str_value
                try char_data.call_replaceData(0, @intCast(char_data.data.len), str_value);
            },
            else => {
                // All other node types do nothing
            },
        }
    
    }

    pub fn get_textContent(self: *const Node) !?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // Return the result of running get text content with this
        return Node.getTextContent(self, self.allocator);
    }

    pub fn set_textContent(self: *Node, value: ?[]const u8) !void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // If the given value is null, act as if it was the empty string instead
        const str_value = value orelse "";
        try Node.setTextContent(self, str_value);
    }

    /// Get text content - DOM Spec algorithm
    /// Returns text content based on node type
    /// For Element and DocumentFragment, the returned string is allocated and must be freed by caller
    /// For other types, returns a reference to existing data (no allocation)
    pub fn getTextContent(node: *const Node, allocator: std.mem.Allocator) !?[]const u8 {

        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // Return descendant text content (allocated)
                return Node.getDescendantTextContent(node, allocator);
            },
            Node.ATTRIBUTE_NODE => {
                // Return node's value (no allocation - returns reference)
                const attr: *const Attr = @ptrCast(@alignCast(node));
                return attr.value;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE, Node.PROCESSING_INSTRUCTION_NODE => {
                // Return node's data (no allocation - returns reference)
                const cd: *const CharacterData = @ptrCast(@alignCast(node));
                return cd.data;
            },
            else => {
                // Document, DocumentType: return null
                return null;
            },
        }
    
    }

    pub fn getDescendantTextContent(node: *const Node, allocator: std.mem.Allocator) ![]const u8 {
        var result = std.ArrayList(u8).init(allocator);
        errdefer result.deinit();

        try collectDescendantText(node, &result);

        return result.toOwnedSlice();
    }

    /// Helper function to recursively collect text from descendants
    fn collectDescendantText(node: *const Node, result: *std.ArrayList(u8)) !void {

        // If this is a Text node, collect its data
        if (node.node_type == Node.TEXT_NODE) {
            const cd: *const CharacterData = @ptrCast(@alignCast(node));
            try result.appendSlice(cd.data);
        }

        // Recursively process all children
        for (0..node.child_nodes.len) |i| {
            if (node.child_nodes.get(i)) |child| {
                try collectDescendantText(child, result);
            }
        }
    
    }

    pub fn setTextContent(node: *Node, value: []const u8) !void {

        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // String replace all with value within node
                try Node.stringReplaceAll(node, value);
            },
            Node.ATTRIBUTE_NODE => {
                // Set an existing attribute value
                const attr: *Attr = @ptrCast(@alignCast(node));
                // Use "set an existing attribute value" algorithm from Attr
                try Attr.setExistingAttributeValue(attr, value);
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Replace data with node, offset 0, count node's length, and data value
                const cd: *CharacterData = @ptrCast(@alignCast(node));
                const length = @as(u32, @intCast(cd.data.len));
                try cd.replaceData(0, length, value);
            },
            else => {
                // Document, DocumentType, etc: do nothing
            },
        }
    
    }

    pub fn stringReplaceAll(parent: *Node, string: []const u8) !void {

        // Step 1: Let node be null
        var node_opt: ?*Node = null;

        // Step 2: If string is not the empty string, create a new Text node
        if (string.len > 0) {
            var text_node = try Text.init(parent.allocator);

            const cd: *CharacterData = @ptrCast(@alignCast(&text_node));
            cd.data = try parent.allocator.dupe(u8, string);

            const new_node: *Node = @ptrCast(&text_node);
            new_node.owner_document = parent.owner_document;
            node_opt = new_node;
        }

        // Step 3: Replace all with node within parent
        const mutation = @import("dom").mutation;
        try mutation.replaceAll(node_opt, parent);
    
    }

    pub fn call_lookupPrefix(self: *const Node, namespace_param: ?[]const u8) ?[]const u8 {

        // Spec step 1: If namespace is null or empty, return null
        const namespace = namespace_param orelse return null;
        if (namespace.len == 0) return null;

        // Spec step 2: Switch on node type
        switch (self.node_type) {
            ELEMENT_NODE => {
                // Return result of locating a namespace prefix
                return self.locateNamespacePrefix(namespace);
            },
            DOCUMENT_NODE => {
                // If document element is null, return null
                const doc: *const Document = @ptrCast(@alignCast(self));
                const doc_elem = doc.documentElement() orelse return null;
                return doc_elem.base.locateNamespacePrefix(namespace);
            },
            DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE => {
                return null;
            },
            else => {
                // For other node types, use parent element if exists
                const parent = self.parent_element orelse return null;
                return parent.base.locateNamespacePrefix(namespace);
            },
        }
    
    }

    pub fn call_lookupNamespaceURI(self: *const Node, prefix_param: ?[]const u8) ?[]const u8 {
        // Spec step 1: If prefix is empty string, set to null
        const prefix = if (prefix_param) |p| if (p.len == 0) null else p else null;

        // Spec step 2: Return result of locating a namespace
        return self.locateNamespace(prefix);
    }

    /// isDefaultNamespace(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
    pub fn call_isDefaultNamespace(self: *const Node, namespace_param: ?[]const u8) bool {
        // Spec step 1: If namespace is empty string, set to null
        const namespace = if (namespace_param) |ns| if (ns.len == 0) null else ns else null;

        // Spec step 2: Let defaultNamespace be result of locating namespace using null prefix
        const default_namespace = self.locateNamespace(null);

        // Spec step 3: Return true if defaultNamespace equals namespace
        if (default_namespace == null and namespace == null) return true;
        if (default_namespace == null or namespace == null) return false;
        return std.mem.eql(u8, default_namespace.?, namespace.?);
    }

    /// Locate a namespace prefix for element (internal algorithm)
    /// Spec: https://dom.spec.whatwg.org/#locate-a-namespace-prefix
    fn locateNamespacePrefix(self: *const Node, namespace: []const u8) ?[]const u8 {

        if (self.node_type != ELEMENT_NODE) return null;

        const elem: *const Element = @ptrCast(@alignCast(self));

        // Step 1: If element's namespace is namespace and prefix is non-null, return prefix
        if (elem.namespace_uri) |ns| {
            if (std.mem.eql(u8, ns, namespace)) {
                if (elem.prefix) |p| return p;
            }
        }

        // Step 2: If element has attribute with prefix "xmlns" and value namespace, return local name
        for (elem.attributes.items) |attr| {
            if (attr.prefix) |attr_prefix| {
                if (std.mem.eql(u8, attr_prefix, "xmlns") and std.mem.eql(u8, attr.value, namespace)) {
                    return attr.local_name;
                }
            }
        }

        // Step 3: If parent element exists, recurse
        if (self.parent_element) |parent| {
            return parent.base.locateNamespacePrefix(namespace);
        }

        // Step 4: Return null
        return null;
    
    }

    fn locateNamespace(self: *const Node, prefix: ?[]const u8) ?[]const u8 {

        switch (self.node_type) {
            ELEMENT_NODE => {
                const elem: *const Element = @ptrCast(@alignCast(self));

                // Step 1: If prefix is "xml", return XML namespace
                if (prefix) |p| {
                    if (std.mem.eql(u8, p, "xml")) {
                        return "http://www.w3.org/XML/1998/namespace";
                    }
                    // Step 2: If prefix is "xmlns", return XMLNS namespace
                    if (std.mem.eql(u8, p, "xmlns")) {
                        return "http://www.w3.org/2000/xmlns/";
                    }
                }

                // Step 3: If namespace is non-null and prefix matches, return namespace
                if (elem.namespace_uri) |ns| {
                    if ((prefix == null and elem.prefix == null) or
                        (prefix != null and elem.prefix != null and std.mem.eql(u8, prefix.?, elem.prefix.?)))
                    {
                        return ns;
                    }
                }

                // Step 4: Check for xmlns attributes
                // If it has an attribute whose namespace is XMLNS namespace, prefix is "xmlns",
                // and local name is prefix, return its value if not empty string, else null.
                // Or if prefix is null and it has an attribute whose namespace is XMLNS namespace,
                // prefix is null, and local name is "xmlns", return its value if not empty, else null.
                for (elem.attributes.items) |attr| {
                    const xmlns_ns = "http://www.w3.org/2000/xmlns/";

                    if (attr.namespace_uri) |attr_ns| {
                        if (std.mem.eql(u8, attr_ns, xmlns_ns)) {
                            // Check if this matches our prefix
                            if (prefix) |p| {
                                // Looking for xmlns:prefix attribute
                                if (attr.prefix) |attr_prefix| {
                                    if (std.mem.eql(u8, attr_prefix, "xmlns") and std.mem.eql(u8, attr.local_name, p)) {
                                        return if (attr.value.len > 0) attr.value else null;
                                    }
                                }
                            } else {
                                // Looking for xmlns attribute (default namespace)
                                if (attr.prefix == null and std.mem.eql(u8, attr.local_name, "xmlns")) {
                                    return if (attr.value.len > 0) attr.value else null;
                                }
                            }
                        }
                    }
                }

                // Step 5: If parent element is null, return null
                const parent = self.parent_element orelse return null;

                // Step 6: Return result of locating namespace on parent
                return parent.base.locateNamespace(prefix);
            },
            DOCUMENT_NODE => {
                // Step 1: If document element is null, return null
                const doc: *const Document = @ptrCast(@alignCast(self));
                const doc_elem = doc.documentElement() orelse return null;

                // Step 2: Return result of locating namespace on document element
                return doc_elem.base.locateNamespace(prefix);
            },
            DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE => {
                return null;
            },
            ATTRIBUTE_NODE => {
                // Step 1: If element is null, return null
                const AttributeType = @import("attr").Attr;
                const attr: *const AttributeType = @ptrCast(@alignCast(self));
                const element = attr.owner_element orelse return null;

                // Step 2: Return result of locating namespace on element
                return element.base.locateNamespace(prefix);
            },
            else => {
                // Step 1: If parent element is null, return null
                const parent = self.parent_element orelse return null;

                // Step 2: Return result of locating namespace on parent
                return parent.base.locateNamespace(prefix);
            },
        }
    
    }

    pub fn getRegisteredObservers(self: *Node) *std.ArrayList(RegisteredObserver) {
        return &self.registered_observers;
    }

    /// Add a registered observer to this node's list
    pub fn addRegisteredObserver(self: *Node, registered: RegisteredObserver) !void {
        try self.registered_observers.append(registered);
    }

    /// Remove all registered observers for a specific MutationObserver
    pub fn removeRegisteredObserver(self: *Node, observer: *const @import("mutation_observer").MutationObserver) void {

        var i: usize = 0;
        while (i < self.registered_observers.items.len) {
            if (self.registered_observers.items[i].observer == observer) {
                _ = self.registered_observers.orderedRemove(i);
                // Don't increment i, we just shifted everything down
            } else {
                i += 1;
            }
        }
    
    }

    fn ensureEventListenerList(self: *EventTarget) !*std.ArrayList(EventListener) {

        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    
    }

    fn getEventListenerList(self: *const EventTarget) []const EventListener {

        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    
    }

    fn flattenOptions(options: anytype) bool {

        const OptionsType = @TypeOf(options);

        // Step 1: If options is a boolean, return it
        if (OptionsType == bool) {
            return options;
        }

        // Step 2: If it's EventListenerOptions or AddEventListenerOptions, return capture field
        if (@hasField(OptionsType, "capture")) {
            return options.capture;
        }

        // Default: return false
        return false;
    
    }

    fn flattenMoreOptions(options: anytype) struct { capture: bool, passive: ?bool, once: bool, signal: ?*AbortSignal } {

        const OptionsType = @TypeOf(options);

        // If options is a boolean, only capture is set to that value
        if (OptionsType == bool) {
            return .{
                .capture = options,
                .passive = null,
                .once = false,
                .signal = null,
            };
        }

        // If options is AddEventListenerOptions dictionary, extract all fields
        if (@hasField(OptionsType, "capture")) {
            return .{
                .capture = if (@hasField(OptionsType, "capture")) options.capture else false,
                .passive = if (@hasField(OptionsType, "passive")) options.passive else null,
                .once = if (@hasField(OptionsType, "once")) options.once else false,
                .signal = if (@hasField(OptionsType, "signal")) options.signal else null,
            };
        }

        // Default: return all defaults
        return .{
            .capture = false,
            .passive = null,
            .once = false,
            .signal = null,
        };
    
    }

    fn defaultPassiveValue(event_type: []const u8, event_target: *EventTarget) bool {

        _ = event_target;
        // Step 1: Return true if type is touchstart, touchmove, wheel, or mousewheel
        // AND eventTarget is Window or specific node conditions
        // For now, simplified: return true for touch/wheel events
        if (std.mem.eql(u8, event_type, "touchstart") or
            std.mem.eql(u8, event_type, "touchmove") or
            std.mem.eql(u8, event_type, "wheel") or
            std.mem.eql(u8, event_type, "mousewheel"))
        {
            // TODO: Check eventTarget conditions per spec
            return true;
        }
        // Step 2: Return false
        return false;
    
    }

    fn addAnEventListener(self: *EventTarget, listener: EventListener) !void {

        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        // Spec: "If listener's signal is not null, then add the following abort steps to it:
        // Remove an event listener with eventTarget and listener."
        // https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
        if (listener.signal) |signal| {
            const AbortSignalType = @import("abort_signal").AbortSignal;
            const removal_context = AbortSignalType.EventListenerRemovalContext{
                .target = self,
                .listener_type = updated_listener.type,
                .listener_callback = updated_listener.callback,
                .listener_capture = updated_listener.capture,
            };
            try signal.addEventListenerRemoval(removal_context);
        }
    
    }

    pub fn call_addEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {

        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    
    }

    fn removeAnEventListener(self: *EventTarget, listener: EventListener) void {

        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    
    }

    pub fn call_removeEventListener(
        self: *EventTarget,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {

        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    
    }

    pub fn call_dispatchEvent(self: *EventTarget, event: *Event) !bool {

        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this using full dispatch algorithm
        const event_dispatch = @import("dom").event_dispatch;
        return event_dispatch.dispatch(event, self, false, null) catch |err| {
            // Handle dispatch errors
            return err;
        };
    
    }

};


