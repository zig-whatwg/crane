// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const AbortSignal = @import("abort_signal").AbortSignal;
const Allocator = std.mem.Allocator;
const Attr = @import("attr").Attr;
const CharacterData = @import("character_data").CharacterData;
const Document = @import("document").Document;
const DocumentFragment = @import("document_fragment").DocumentFragment;
const DocumentOrShadowRoot = @import("document_or_shadow_root").DocumentOrShadowRoot;
const Element = @import("element").Element;
const Event = @import("event").Event;
const EventTarget = @import("event_target").EventTarget;
const HTMLCollection = @import("html_collection").HTMLCollection;
const Node = @import("node").Node;
const NodeList = @import("node_list").NodeList;
const NonElementParentNode = @import("non_element_parent_node").NonElementParentNode;
const ParentNode = @import("parent_node").ParentNode;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const Text = @import("text").Text;
const TransientRegisteredObserver = @import("registered_observer").TransientRegisteredObserver;
const dom = @import("dom");
const dom_types = @import("dom_types");
const infra = @import("infra");
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง4.8.1 - ShadowRootMode enum
///
/// Defines the mode of a shadow root.
pub const ShadowRootMode = enum {
    open,
    closed,

    pub fn toString(self: ShadowRootMode) []const u8 {
        return switch (self) {
            .open => "open",
            .closed => "closed",
        };
    }
};

/// DOM ยง4.8.1 - SlotAssignmentMode enum
///
/// Defines how slottables are assigned to slots.
pub const SlotAssignmentMode = enum {
    manual,
    named,

    pub fn toString(self: SlotAssignmentMode) []const u8 {
        return switch (self) {
            .manual => "manual",
            .named => "named",
        };
    }
};

/// DOM ยง4.8.1 - ShadowRoot interface
///
/// Shadow roots are DocumentFragments that serve as the root of a shadow tree.
/// A shadow root is always attached to another node tree through its host element.

pub const ShadowRoot = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    host_element: *Element,
    shadow_mode: ShadowRootMode,
    delegates_focus_flag: bool,
    slot_assignment_mode: SlotAssignmentMode,
    clonable_flag: bool,
    serializable_flag: bool,
    available_to_element_internals: bool,
    declarative_flag: bool,
    keep_custom_element_registry_null: bool,
    onslotchange: ?*anyopaque,

    // ========================================================================
    // Constants
    // ========================================================================

    // Node type constants (inherited)
    pub const ELEMENT_NODE: u16 = Node.ELEMENT_NODE;
    pub const ATTRIBUTE_NODE: u16 = Node.ATTRIBUTE_NODE;
    pub const TEXT_NODE: u16 = Node.TEXT_NODE;
    pub const CDATA_SECTION_NODE: u16 = Node.CDATA_SECTION_NODE;
    pub const PROCESSING_INSTRUCTION_NODE: u16 = Node.PROCESSING_INSTRUCTION_NODE;
    pub const COMMENT_NODE: u16 = Node.COMMENT_NODE;
    pub const DOCUMENT_NODE: u16 = Node.DOCUMENT_NODE;
    pub const DOCUMENT_TYPE_NODE: u16 = Node.DOCUMENT_TYPE_NODE;
    pub const DOCUMENT_FRAGMENT_NODE: u16 = Node.DOCUMENT_FRAGMENT_NODE;

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: Allocator,
        host: *Element,
        mode: ShadowRootMode,
        delegates_focus: bool,
        slot_assignment: SlotAssignmentMode,
        clonable: bool,
        serializable: bool,
    ) !ShadowRoot {

        return .{
            .allocator = allocator,
            .host_element = host,
            .shadow_mode = mode,
            .delegates_focus_flag = delegates_focus,
            .slot_assignment_mode = slot_assignment,
            .clonable_flag = clonable,
            .serializable_flag = serializable,
            .available_to_element_internals = false,
            .declarative_flag = false,
            .keep_custom_element_registry_null = false,
            // custom_element_registry comes from DocumentOrShadowRoot mixin
        };
    
    }

    pub fn deinit(self: *ShadowRoot) void {

        _ = self;
        // NOTE: Parent DocumentFragment cleanup is handled by codegen
    
    }

    pub fn get_mode(self: *const ShadowRoot) []const u8 {

        return self.shadow_mode.toString();
    
    }

    pub fn get_delegatesFocus(self: *const ShadowRoot) bool {

        return self.delegates_focus_flag;
    
    }

    pub fn get_slotAssignment(self: *const ShadowRoot) []const u8 {

        return self.slot_assignment_mode.toString();
    
    }

    pub fn get_clonable(self: *const ShadowRoot) bool {

        return self.clonable_flag;
    
    }

    pub fn get_serializable(self: *const ShadowRoot) bool {

        return self.serializable_flag;
    
    }

    pub fn get_host(self: *const ShadowRoot) *Element {

        return self.host_element;
    
    }

    pub fn get_onslotchange(self: *const ShadowRoot) ?*anyopaque {

        return self.onslotchange;
    
    }

    pub fn set_onslotchange(self: *ShadowRoot, handler: ?*anyopaque) void {

        self.onslotchange = handler;
    
    }

    pub fn getMode(self: *const ShadowRoot) ShadowRootMode {
        return self.shadow_mode;
    }

    /// Get the slot assignment mode as an enum value
    pub fn getSlotAssignmentMode(self: *const ShadowRoot) SlotAssignmentMode {
        return self.slot_assignment_mode;
    }

    /// Check if this shadow root is available to element internals
    pub fn isAvailableToElementInternals(self: *const ShadowRoot) bool {

        return self.available_to_element_internals;
    
    }

    pub fn isDeclarative(self: *const ShadowRoot) bool {

        return self.declarative_flag;
    
    }

    pub fn setAvailableToElementInternals(self: *ShadowRoot, value: bool) void {

        self.available_to_element_internals = value;
    
    }

    pub fn setDeclarative(self: *ShadowRoot, value: bool) void {

        self.declarative_flag = value;
    
    }

    pub fn get_customElementRegistry(self: *const @This()) ?*anyopaque {

        // Step 1: If this is a document, then return this's custom element registry
        // Step 2: Assert: this is a ShadowRoot node
        // Step 3: Return this's custom element registry

        // Both cases just return the custom_element_registry field
        return self.custom_element_registry;
    
    }

    pub fn getCustomElementRegistry(self: *const @This()) ?*anyopaque {

        return self.custom_element_registry;
    
    }

    pub fn setCustomElementRegistry(self: *@This(), registry: ?*anyopaque) void {

        self.custom_element_registry = registry;
    
    }

    pub fn get_children(self: anytype) !*HTMLCollection {

        const NodeType = @import("node").Node;
        const allocator = self.allocator;

        // Create HTMLCollection
        const collection = try allocator.create(HTMLCollection);
        collection.* = try HTMLCollection.init(allocator);

        // Filter child_nodes for elements only (ELEMENT_NODE = 1)
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                const element: *Element = @ptrCast(child);
                try collection.addElement(element);
            }
        }

        return collection;
    
    }

    pub fn get_firstElementChild(self: anytype) ?*Element {

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in tree order
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    
    }

    pub fn get_lastElementChild(self: anytype) ?*Element {

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Iterate through children in reverse tree order
        var i: usize = self.child_nodes.items.len;
        while (i > 0) {
            i -= 1;
            const child = self.child_nodes.items[i];
            if (child.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(child);
            }
        }

        return null;
    
    }

    pub fn get_childElementCount(self: anytype) u32 {

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Count children that are Elements
        var count: u32 = 0;
        for (self.child_nodes.items) |child| {
            if (child.node_type == NodeType.ELEMENT_NODE) {
                count += 1;
            }
        }

        return count;
    
    }

    pub fn call_prepend(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Pre-insert node into this before this's first child
        const first_child = this_node.get_firstChild();
        _ = try mutation.preInsert(node, this_node, first_child);
    
    }

    pub fn call_append(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Append node to this
        _ = try mutation.append(node, this_node);
    
    }

    pub fn call_replaceChildren(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {

        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;
        const ChildNodeMixin = @import("child_node").ChildNode;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try ChildNodeMixin.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 2: Ensure pre-insert validity of node into this before null
        try mutation.ensurePreInsertValidity(node, this_node, null);

        // Step 3: Replace all with node within this
        try mutation.replaceAll(node, this_node);
    
    }

    pub fn call_moveBefore(self: anytype, node: anytype, child: anytype) !void {

        const mutation = @import("dom").mutation;

        // Get Node pointers from the anytype parameters
        const parent_node = @as(*@import("node").Node, @ptrCast(self));
        const moved_node = @as(*@import("node").Node, @ptrCast(node));
        const child_node = if (child) |c| @as(?*@import("node").Node, @ptrCast(c)) else null;

        // Step 1: Let referenceChild be child
        var reference_child = child_node;

        // Step 2: If referenceChild is node, then set referenceChild to node's next sibling
        if (reference_child == moved_node) {
            reference_child = moved_node.next_sibling;
        }

        // Step 3: Move node into this before referenceChild
        try mutation.move(moved_node, parent_node, reference_child);
    
    }

    pub fn call_querySelector(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !?*Element {

        // Run scope-match a selectors string against this
        const matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Return first result if not empty; otherwise null
        if (matches.items.len > 0) {
            return matches.items[0];
        }

        return null;
    
    }

    pub fn call_querySelectorAll(self: anytype, allocator: std.mem.Allocator, selectors: []const u8) !*NodeList {

        // Run scope-match a selectors string against this
        var matches = try dom.selectors.scopeMatchSelectorsString(allocator, selectors, self);
        defer matches.deinit();

        // Create NodeList and populate with matches (static snapshot)
        var node_list = try allocator.create(NodeList);
        node_list.* = try NodeList.init(allocator);

        // Add all matched elements to the NodeList
        for (matches.items) |element| {
            // Cast Element to Node
            const node = @as(*@import("node").Node, @ptrCast(element));
            try node_list.addNode(node);
        }

        return node_list;
    
    }

    pub fn call_getElementById(self: anytype, allocator: std.mem.Allocator, element_id: []const u8) !?*Element {

        _ = allocator; // Not needed for traversal

        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;

        // Inline recursive search to avoid private function copying issues with codegen
        const SearchHelper = struct {
            fn findById(nodes: anytype, target_id: []const u8) ?*Element {
                for (nodes) |node| {
                    // Check if this node is an element with matching ID
                    if (node.node_type == NodeType.ELEMENT_NODE) {
                        // Cast to Element to access ID
                        const element: *Element = @ptrCast(node);

                        // Check if id attribute matches
                        // Per spec: element's ID is the value of its "id" attribute
                        const attributes = element.get_attributes();
                        if (attributes.call_getNamedItem("id")) |id_attr| {
                            if (std.mem.eql(u8, id_attr.value, target_id)) {
                                return element;
                            }
                        }
                    }

                    // Recursively search descendants
                    if (findById(node.child_nodes.items, target_id)) |found| {
                        return found;
                    }
                }

                return null;
            }
        };

        // Traverse descendants in tree order (preorder depth-first)
        return SearchHelper.findById(self.child_nodes.items, element_id);
    
    }

    pub fn nodeEquals(a: *const Node, b: *const Node) bool {

        // Step 1: A and B implement the same interfaces (check node_type)
        if (a.node_type != b.node_type) return false;

        // Step 2: Check node-type-specific properties
        switch (a.node_type) {
            DOCUMENT_TYPE_NODE => {
                // DocumentType: check name, public ID, and system ID
                const DocumentType = @import("document_type").DocumentType;
                const doctype_a: *const DocumentType = @ptrCast(@alignCast(a));
                const doctype_b: *const DocumentType = @ptrCast(@alignCast(b));

                // Check name
                if (!std.mem.eql(u8, doctype_a.name, doctype_b.name)) return false;

                // Check public ID
                if (!std.mem.eql(u8, doctype_a.public_id, doctype_b.public_id)) return false;

                // Check system ID
                if (!std.mem.eql(u8, doctype_a.system_id, doctype_b.system_id)) return false;
            },
            ELEMENT_NODE => {
                // Element: check namespace, namespace prefix, local name, and attribute list size
                const elem_a: *const Element = @ptrCast(@alignCast(a));
                const elem_b: *const Element = @ptrCast(@alignCast(b));

                // Check namespace
                if (elem_a.namespace_uri == null and elem_b.namespace_uri != null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri == null) return false;
                if (elem_a.namespace_uri != null and elem_b.namespace_uri != null) {
                    if (!std.mem.eql(u8, elem_a.namespace_uri.?, elem_b.namespace_uri.?)) return false;
                }

                // Check local name (tag_name)
                if (!std.mem.eql(u8, elem_a.tag_name, elem_b.tag_name)) return false;

                // Check attribute list size
                if (elem_a.attributes.len != elem_b.attributes.len) return false;

                // Step 3: Each attribute in A's list has an equal attribute in B's list
                for (elem_a.attributes.items) |attr_a| {
                    var found = false;
                    for (elem_b.attributes.items) |attr_b| {
                        if (Node.attributeEquals(&attr_a, &attr_b)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) return false;
                }
            },
            ATTRIBUTE_NODE => {
                // Attr: check namespace, local name, and value
                // Note: Attr nodes don't participate in tree, but we check for completeness
                const attr_a: *const Attr = @ptrCast(@alignCast(a));
                const attr_b: *const Attr = @ptrCast(@alignCast(b));
                return Node.attributeEquals(attr_a, attr_b);
            },
            PROCESSING_INSTRUCTION_NODE => {
                // ProcessingInstruction: check target and data
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi_a: *const PI = @ptrCast(@alignCast(a));
                const pi_b: *const PI = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, pi_a.target, pi_b.target)) return false;
                if (!std.mem.eql(u8, pi_a.data, pi_b.data)) return false;
            },
            TEXT_NODE, COMMENT_NODE, CDATA_SECTION_NODE => {
                // Text, Comment, CDATASection: check data
                const cd_a: *const CharacterData = @ptrCast(@alignCast(a));
                const cd_b: *const CharacterData = @ptrCast(@alignCast(b));

                if (!std.mem.eql(u8, cd_a.data, cd_b.data)) return false;
            },
            else => {
                // For other node types, basic node_name check is sufficient
                if (!std.mem.eql(u8, a.node_name, b.node_name)) return false;
            },
        }

        // Step 4: A and B have the same number of children
        if (a.child_nodes.len != b.child_nodes.len) return false;

        // Step 5: Each child of A equals the child of B at the identical index
        for (a.child_nodes.items, 0..) |child_a, i| {
            const child_b = b.child_nodes.items[i];
            if (!Node.nodeEquals(child_a, child_b)) return false;
        }

        return true;
    
    }

    pub fn attributeEquals(a: *const @import("attr").Attr, b: *const @import("attr").Attr) bool {

        // Check namespace
        if (a.namespace_uri == null and b.namespace_uri != null) return false;
        if (a.namespace_uri != null and b.namespace_uri == null) return false;
        if (a.namespace_uri != null and b.namespace_uri != null) {
            if (!std.mem.eql(u8, a.namespace_uri.?, b.namespace_uri.?)) return false;
        }

        // Check local name
        if (!std.mem.eql(u8, a.local_name, b.local_name)) return false;

        // Check value
        if (!std.mem.eql(u8, a.value, b.value)) return false;

        return true;
    
    }

    pub fn cloneNodeInternal(
        node: *Node,
        document_param: ?*Document,
        subtree: bool,
        parent: ?*Node,
        fallback_registry: ?*anyopaque, // CustomElementRegistry - not implemented yet
    ) !*Node {

        // Step 1: Let document be document_param or node's owner_document
        const document = document_param orelse node.owner_document;

        // Assert: node is not a document or node is document
        // (We don't have full Document implementation yet, skip this assert)

        // Step 2: Let copy be the result of cloning a single node
        var copy = try Node.cloneSingleNode(node, document, fallback_registry);

        // Step 3: Run any cloning steps defined for node
        // Specifications may define cloning steps for specific node types
        if (node.cloning_steps_hook) |hook| {
            try hook(node, copy, subtree);
        }

        // Step 4: If parent is non-null, append copy to parent
        if (parent) |p| {
            try p.child_nodes.append(copy);
            copy.parent_node = p;
        }

        // Step 5: If subtree is true, clone all children recursively
        if (subtree) {
            for (node.child_nodes.items) |child| {
                _ = try Node.cloneNodeInternal(child, document, subtree, copy, fallback_registry);
            }
        }

        // Step 6: If node is an element, node is shadow host, and shadow root is clonable, clone shadow
        if (node.node_type == Node.ELEMENT_NODE) {
            const elem: *const Element = @ptrCast(@alignCast(node));
            if (elem.shadow_root) |shadow| {
                // Check if shadow root is clonable
                if (shadow.clonable_flag) {
                    // Clone the shadow root per spec
                    const copy_elem: *Element = @ptrCast(@alignCast(copy));

                    // Assert: copy is not a shadow host (should be true since we just created it)
                    std.debug.assert(copy_elem.shadow_root == null);

                    // Step 6.2-6.4: Determine shadow root registry and attach shadow root
                    //
                    // Per spec (DOM ยง4.2.7):
                    // - If node's shadow root's custom element registry is non-null, use it
                    // - Otherwise, if fallbackRegistry is non-null, use fallbackRegistry
                    // - Otherwise, set registry to null
                    //
                    // NOTE: Custom element registry is part of the HTML spec, not DOM spec.
                    // Full implementation requires:
                    // - ShadowRoot.custom_element_registry field (currently not present)
                    // - CustomElementRegistry type and implementation
                    // - Registry scoping logic
                    //
                    // For now, we pass null for the registry. When custom elements are
                    // implemented, fallback_registry will be used here to determine the
                    // registry for the cloned shadow root.

                    // Attach shadow root to copy
                    var copy_shadow = try ShadowRoot.init(
                        copy.allocator,
                        copy_elem,
                        shadow.shadow_mode,
                        shadow.delegates_focus_flag,
                        shadow.slot_assignment_mode,
                        shadow.clonable_flag,
                        shadow.serializable_flag,
                        shadow.available_to_element_internals,
                        false, // declarative will be set next
                    );

                    // Step 6.5: Set copy's shadow root's declarative to node's shadow root's declarative
                    copy_shadow.declarative_flag = shadow.declarative_flag;

                    copy_elem.shadow_root = &copy_shadow;

                    // Step 6.6: Clone shadow root children
                    const shadow_node = shadow.asNode();
                    for (shadow_node.child_nodes.items) |child| {
                        const copy_shadow_node = copy_shadow.asNode();
                        _ = try Node.cloneNodeInternal(child, document, subtree, copy_shadow_node, null);
                    }
                }
            }
        }

        // Step 7: Return copy
        return copy;
    
    }

    pub fn cloneSingleNode(
        node: *Node,
        document: ?*Document,
        fallback_registry: ?*anyopaque,
    ) !*Node {

        _ = fallback_registry; // Not used yet - for custom elements

        // Step 2-3: Handle different node types
        switch (node.node_type) {
            Node.ELEMENT_NODE => {
                // Clone element with attributes
                const elem: *Element = @ptrCast(@alignCast(node));

                // Create new element
                var copy_elem = try Element.init(elem.allocator, elem.tag_name);
                copy_elem.namespace_uri = elem.namespace_uri;

                // Clone attributes
                for (elem.attributes.items) |attr| {
                    const copy_attr = Attr{
                        .allocator = elem.allocator,
                        .namespace_uri = attr.namespace_uri,
                        .prefix = attr.prefix,
                        .local_name = attr.local_name,
                        .value = attr.value,
                        .owner_element = &copy_elem,
                    };
                    try copy_elem.attributes.append(copy_attr);
                }

                const copy_node = @as(*Node, @ptrCast(&copy_elem));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Clone CharacterData (Text, Comment, CDATASection)
                const cd: *CharacterData = @ptrCast(@alignCast(node));

                var copy_cd = try CharacterData.init(cd.allocator);
                copy_cd.data = try cd.allocator.dupe(u8, cd.data);

                const copy_node = @as(*Node, @ptrCast(&copy_cd));
                copy_node.node_type = node.node_type;
                copy_node.node_name = node.node_name;
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.PROCESSING_INSTRUCTION_NODE => {
                // Clone ProcessingInstruction
                const PI = @import("processing_instruction").ProcessingInstruction;
                const pi: *PI = @ptrCast(@alignCast(node));

                var copy_pi = try PI.init(pi.allocator, pi.target, pi.data);

                const copy_node = @as(*Node, @ptrCast(&copy_pi));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.ATTRIBUTE_NODE => {
                // Clone Attr
                const attr: *Attr = @ptrCast(@alignCast(node));

                var copy_attr = try Attr.init(
                    attr.allocator,
                    attr.namespace_uri,
                    attr.prefix,
                    attr.local_name,
                    attr.value,
                );

                const copy_node = @as(*Node, @ptrCast(&copy_attr));
                copy_node.owner_document = document;
                return copy_node;
            },
            Node.DOCUMENT_TYPE_NODE => {
                // Clone DocumentType (simplified - full implementation needs public ID, system ID)
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_FRAGMENT_NODE => {
                // Clone DocumentFragment
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            Node.DOCUMENT_NODE => {
                // Cloning Document is complex and not fully supported yet
                // For now, just create a basic copy
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
            else => {
                // Default: create basic node copy
                var copy = try Node.init(node.allocator, node.node_type, node.node_name);
                copy.owner_document = document;
                return copy;
            },
        }
    
    }

    pub fn getTextContent(node: *const Node, allocator: std.mem.Allocator) !?[]const u8 {

        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // Return descendant text content (allocated)
                return Node.getDescendantTextContent(node, allocator);
            },
            Node.ATTRIBUTE_NODE => {
                // Return node's value (no allocation - returns reference)
                const attr: *const Attr = @ptrCast(@alignCast(node));
                return attr.value;
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE, Node.PROCESSING_INSTRUCTION_NODE => {
                // Return node's data (no allocation - returns reference)
                const cd: *const CharacterData = @ptrCast(@alignCast(node));
                return cd.data;
            },
            else => {
                // Document, DocumentType: return null
                return null;
            },
        }
    
    }

    pub fn getDescendantTextContent(node: *const Node, allocator: std.mem.Allocator) ![]const u8 {

        var result = std.ArrayList(u8).init(allocator);
        errdefer result.deinit();

        try collectDescendantText(node, &result);

        return result.toOwnedSlice();
    
    }

    fn collectDescendantText(node: *const Node, result: *std.ArrayList(u8)) !void {

        // If this is a Text node, collect its data
        if (node.node_type == Node.TEXT_NODE) {
            const cd: *const CharacterData = @ptrCast(@alignCast(node));
            try result.appendSlice(cd.data);
        }

        // Recursively process all children
        for (0..node.child_nodes.len) |i| {
            if (node.child_nodes.get(i)) |child| {
                try collectDescendantText(child, result);
            }
        }
    
    }

    pub fn setTextContent(node: *Node, value: []const u8) !void {

        switch (node.node_type) {
            Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE => {
                // String replace all with value within node
                try Node.stringReplaceAll(node, value);
            },
            Node.ATTRIBUTE_NODE => {
                // Set an existing attribute value
                const attr: *Attr = @ptrCast(@alignCast(node));
                // Use "set an existing attribute value" algorithm from Attr
                try Attr.setExistingAttributeValue(attr, value);
            },
            Node.TEXT_NODE, Node.COMMENT_NODE, Node.CDATA_SECTION_NODE => {
                // Replace data with node, offset 0, count node's length, and data value
                const cd: *CharacterData = @ptrCast(@alignCast(node));
                const length = @as(u32, @intCast(cd.data.len));
                try cd.replaceData(0, length, value);
            },
            else => {
                // Document, DocumentType, etc: do nothing
            },
        }
    
    }

    pub fn stringReplaceAll(parent: *Node, string: []const u8) !void {

        // Step 1: Let node be null
        var node_opt: ?*Node = null;

        // Step 2: If string is not the empty string, create a new Text node
        if (string.len > 0) {
            var text_node = try Text.init(parent.allocator);

            const cd: *CharacterData = @ptrCast(@alignCast(&text_node));
            cd.data = try parent.allocator.dupe(u8, string);

            const new_node: *Node = @ptrCast(&text_node);
            new_node.owner_document = parent.owner_document;
            node_opt = new_node;
        }

        // Step 3: Replace all with node within parent
        const mutation = @import("dom").mutation;
        try mutation.replaceAll(node_opt, parent);
    
    }

    fn flattenOptions(options: anytype) bool {

        const OptionsType = @TypeOf(options);

        // Step 1: If options is a boolean, return it
        if (OptionsType == bool) {
            return options;
        }

        // Step 2: If it's EventListenerOptions or AddEventListenerOptions, return capture field
        if (@hasField(OptionsType, "capture")) {
            return options.capture;
        }

        // Default: return false
        return false;
    
    }

    fn flattenMoreOptions(options: anytype) struct { capture: bool, passive: ?bool, once: bool, signal: ?*AbortSignal } {

        const OptionsType = @TypeOf(options);

        // If options is a boolean, only capture is set to that value
        if (OptionsType == bool) {
            return .{
                .capture = options,
                .passive = null,
                .once = false,
                .signal = null,
            };
        }

        // If options is AddEventListenerOptions dictionary, extract all fields
        if (@hasField(OptionsType, "capture")) {
            return .{
                .capture = if (@hasField(OptionsType, "capture")) options.capture else false,
                .passive = if (@hasField(OptionsType, "passive")) options.passive else null,
                .once = if (@hasField(OptionsType, "once")) options.once else false,
                .signal = if (@hasField(OptionsType, "signal")) options.signal else null,
            };
        }

        // Default: return all defaults
        return .{
            .capture = false,
            .passive = null,
            .once = false,
            .signal = null,
        };
    
    }

    fn defaultPassiveValue(event_type: []const u8, event_target: *EventTarget) bool {

        _ = event_target;
        // Step 1: Return true if type is touchstart, touchmove, wheel, or mousewheel
        // AND eventTarget is Window or specific node conditions
        // For now, simplified: return true for touch/wheel events
        if (std.mem.eql(u8, event_type, "touchstart") or
            std.mem.eql(u8, event_type, "touchmove") or
            std.mem.eql(u8, event_type, "wheel") or
            std.mem.eql(u8, event_type, "mousewheel"))
        {
            // TODO: Check eventTarget conditions per spec
            return true;
        }
        // Step 2: Return false
        return false;
    
    }

};


// Tests

test "ShadowRoot - creation with basic properties" {
    const allocator = std.testing.allocator;

    // Create a mock Element to use as host
    var mock_element: Element = undefined;

    var shadow_root = try ShadowRoot.init(
        allocator,
        &mock_element,
        .open,
        false, // delegates_focus
        .named, // slot_assignment
        false, // clonable
        false, // serializable
    );
    defer shadow_root.deinit();

    try std.testing.expectEqual(ShadowRootMode.open, shadow_root.getMode());
    try std.testing.expectEqualStrings("open", shadow_root.get_mode());
    try std.testing.expectEqual(false, shadow_root.get_delegatesFocus());
    try std.testing.expectEqual(SlotAssignmentMode.named, shadow_root.getSlotAssignmentMode());
    try std.testing.expectEqualStrings("named", shadow_root.get_slotAssignment());
    try std.testing.expectEqual(false, shadow_root.get_clonable());
    try std.testing.expectEqual(false, shadow_root.get_serializable());
    try std.testing.expectEqual(&mock_element, shadow_root.get_host());
}

test "ShadowRoot - closed mode" {
    const allocator = std.testing.allocator;

    var mock_element: Element = undefined;

    var shadow_root = try ShadowRoot.init(
        allocator,
        &mock_element,
        .closed,
        true, // delegates_focus
        .manual, // slot_assignment
        true, // clonable
        true, // serializable
    );
    defer shadow_root.deinit();

    try std.testing.expectEqual(ShadowRootMode.closed, shadow_root.getMode());
    try std.testing.expectEqualStrings("closed", shadow_root.get_mode());
    try std.testing.expectEqual(true, shadow_root.get_delegatesFocus());
    try std.testing.expectEqual(SlotAssignmentMode.manual, shadow_root.getSlotAssignmentMode());
    try std.testing.expectEqualStrings("manual", shadow_root.get_slotAssignment());
    try std.testing.expectEqual(true, shadow_root.get_clonable());
    try std.testing.expectEqual(true, shadow_root.get_serializable());
}

test "ShadowRoot - internal flags" {
    const allocator = std.testing.allocator;

    var mock_element: Element = undefined;

    var shadow_root = try ShadowRoot.init(
        allocator,
        &mock_element,
        .open,
        false,
        .named,
        false,
        false,
    );
    defer shadow_root.deinit();

    // Test initial values
    try std.testing.expectEqual(false, shadow_root.isAvailableToElementInternals());
    try std.testing.expectEqual(false, shadow_root.isDeclarative());

    // Test setters
    shadow_root.setAvailableToElementInternals(true);
    try std.testing.expectEqual(true, shadow_root.isAvailableToElementInternals());

    shadow_root.setDeclarative(true);
    try std.testing.expectEqual(true, shadow_root.isDeclarative());
}

test "ShadowRootMode - toString" {
    try std.testing.expectEqualStrings("open", ShadowRootMode.open.toString());
    try std.testing.expectEqualStrings("closed", ShadowRootMode.closed.toString());
}

test "SlotAssignmentMode - toString" {
    try std.testing.expectEqualStrings("manual", SlotAssignmentMode.manual.toString());
    try std.testing.expectEqualStrings("named", SlotAssignmentMode.named.toString());
}


