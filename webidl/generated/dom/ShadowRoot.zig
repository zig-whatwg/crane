// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! ShadowRoot interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-shadowroot

const std = @import("std");
const webidl = @import("webidl");
pub const DocumentFragment = @import("document_fragment").DocumentFragment;

/// DOM §4.8.1 - ShadowRootMode enum
///
/// Defines the mode of a shadow root.
pub const ShadowRootMode = enum {
    open,
    closed,

    pub fn toString(self: ShadowRootMode) []const u8 {
        return switch (self) {
            .open => "open",
            .closed => "closed",
        };
    }
};

/// DOM §4.8.1 - SlotAssignmentMode enum
///
/// Defines how slottables are assigned to slots.
pub const SlotAssignmentMode = enum {
    manual,
    named,

    pub fn toString(self: SlotAssignmentMode) []const u8 {
        return switch (self) {
            .manual => "manual",
            .named => "named",
        };
    }
};
/// DOM §4.8.1 - ShadowRoot interface
/// 
/// Shadow roots are DocumentFragments that serve as the root of a shadow tree.
/// A shadow root is always attached to another node tree through its host element.
const DocumentFragmentBase = @import("document_fragment").DocumentFragmentBase;
const Allocator = std.mem.Allocator;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const GetRootNodeOptions = @import("node").GetRootNodeOptions;
const Document = @import("document").Document;
const Element = @import("element").Element;
const ELEMENT_NODE = @import("node").ELEMENT_NODE;
const DOCUMENT_NODE = @import("node").DOCUMENT_NODE;
const DOCUMENT_POSITION_DISCONNECTED = @import("node").DOCUMENT_POSITION_DISCONNECTED;
const infra = @import("infra");
const DocumentOrShadowRoot = @import("document_or_shadow_root").DocumentOrShadowRoot;
pub const ShadowRoot = struct {
    base: DocumentFragmentBase,

    // ========================================================================
    // Fields from DocumentOrShadowRoot mixin
    // ========================================================================
    /// Custom element registry for this document or shadow root
    /// TODO: Implement when CustomElementRegistry is available
    custom_element_registry: ?*anyopaque = null,

    // ========================================================================
    // ShadowRoot fields
    // ========================================================================
    allocator: Allocator,
    /// The element that hosts this shadow root (never null)
    host_element: *Element,
    /// The mode of this shadow root ("open" or "closed")
    shadow_mode: ShadowRootMode,
    /// Whether focus is delegated to the first focusable element
    delegates_focus_flag: bool,
    /// How slottables are assigned to slots ("manual" or "named")
    slot_assignment_mode: SlotAssignmentMode,
    /// Whether this shadow root can be cloned
    clonable_flag: bool,
    /// Whether this shadow root can be serialized
    serializable_flag: bool,
    /// Whether this shadow root is available to element internals
    available_to_element_internals: bool,
    /// Whether this shadow root is declarative
    declarative_flag: bool,
    /// Keep custom element registry null (for declarative shadow roots)
    /// Note: custom_element_registry comes from DocumentOrShadowRoot mixin
    keep_custom_element_registry_null: bool,

    pub const includes = .{DocumentOrShadowRoot};

    /// DOM §4.8.1 - ShadowRoot constructor (internal)
    /// 
    /// Shadow roots are created via Element.attachShadow(), not directly.
    pub fn init(
        allocator: Allocator,
        host: *Element,
        mode: ShadowRootMode,
        delegates_focus: bool,
        slot_assignment: SlotAssignmentMode,
        clonable: bool,
        serializable: bool,
    ) !ShadowRoot {
        
        var result = .{
            .base = undefined,
            .allocator = allocator,
            .host_element = host,
            .shadow_mode = mode,
            .delegates_focus_flag = delegates_focus,
            .slot_assignment_mode = slot_assignment,
            .clonable_flag = clonable,
            .serializable_flag = serializable,
            .available_to_element_internals = false,
            .declarative_flag = false,
            .keep_custom_element_registry_null = false,
            // custom_element_registry comes from DocumentOrShadowRoot mixin
        };
        result.base.type_tag = .ShadowRoot;
        return result;
    }
    pub fn deinit(self: *ShadowRoot) void {
        _ = self;
        // DocumentFragment parent will handle cleanup
        // TODO: Call parent DocumentFragment deinit (will be added by codegen)
    }

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to DocumentFragmentBase for type-generic code.
    pub fn toBase(self: *ShadowRoot) *DocumentFragmentBase {
        return &self.base;
    }


    // ========================================================================
    // Methods from DocumentOrShadowRoot mixin
    // ========================================================================

    /// Set the custom element registry
    /// (Included from DocumentOrShadowRoot mixin)
    pub fn setCustomElementRegistry(self: *@This(), registry: ?*anyopaque) void {
        self.custom_element_registry = registry;
    }
    // ========================================================================
    // ShadowRoot methods
    // ========================================================================

    /// DOM §4.8.1 - ShadowRoot.mode
    /// 
    /// Returns the mode of this shadow root ("open" or "closed").
    pub fn get_mode(self: *const ShadowRoot) []const u8 {
        return self.shadow_mode.toString();
    }
    /// DOM §4.8.1 - ShadowRoot.delegatesFocus
    /// 
    /// Returns whether focus is delegated to the first focusable element.
    pub fn get_delegatesFocus(self: *const ShadowRoot) bool {
        return self.delegates_focus_flag;
    }
    /// DOM §4.8.1 - ShadowRoot.slotAssignment
    /// 
    /// Returns how slottables are assigned to slots ("manual" or "named").
    pub fn get_slotAssignment(self: *const ShadowRoot) []const u8 {
        return self.slot_assignment_mode.toString();
    }
    /// DOM §4.8.1 - ShadowRoot.clonable
    /// 
    /// Returns whether this shadow root can be cloned.
    pub fn get_clonable(self: *const ShadowRoot) bool {
        return self.clonable_flag;
    }
    /// DOM §4.8.1 - ShadowRoot.serializable
    /// 
    /// Returns whether this shadow root can be serialized.
    pub fn get_serializable(self: *const ShadowRoot) bool {
        return self.serializable_flag;
    }
    /// DOM §4.8.1 - ShadowRoot.host
    /// 
    /// Returns the element that hosts this shadow root.
    pub fn get_host(self: *const ShadowRoot) *Element {
        return self.host_element;
    }
    /// DOM §4.8.1 - ShadowRoot.onslotchange
    /// 
    /// Event handler for the slotchange event.
    /// Fired when slot assignments change.
    pub fn get_onslotchange(self: *const ShadowRoot) ?*anyopaque {
        // TODO: Implement event handler IDL attribute
        _ = self;
        return null;
    }

    pub fn set_onslotchange(self: *ShadowRoot, handler: ?*anyopaque) void {
        // TODO: Implement event handler IDL attribute
        _ = self;
        _ = handler;
    }

    // ========================================================================
    // Internal Methods
    // ========================================================================

    /// Get the mode as an enum value
    pub fn getMode(self: *const ShadowRoot) ShadowRootMode {
        return self.shadow_mode;
    }

    /// Get the slot assignment mode as an enum value
    pub fn getSlotAssignmentMode(self: *const ShadowRoot) SlotAssignmentMode {
        return self.slot_assignment_mode;
    }

    /// Check if this shadow root is available to element internals
    pub fn isAvailableToElementInternals(self: *const ShadowRoot) bool {
        return self.available_to_element_internals;
    }
    /// Check if this shadow root is declarative
    pub fn isDeclarative(self: *const ShadowRoot) bool {
        return self.declarative_flag;
    }
    /// Set available to element internals
    pub fn setAvailableToElementInternals(self: *ShadowRoot, value: bool) void {
        self.available_to_element_internals = value;
    }
    /// Set declarative flag
    pub fn setDeclarative(self: *ShadowRoot, value: bool) void {
        self.declarative_flag = value;
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "ShadowRoot",
        .kind = .interface,
        .exposed = null,
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};


// Tests

test "ShadowRoot - creation with basic properties" {
    const allocator = std.testing.allocator;

    // Create a mock Element to use as host
    // TODO: Use real Element when fully integrated
    var mock_element: Element = undefined;

    var shadow_root = try ShadowRoot.init(
        allocator,
        &mock_element,
        .open,
        false, // delegates_focus
        .named, // slot_assignment
        false, // clonable
        false, // serializable
    );
    defer shadow_root.deinit();

    try std.testing.expectEqual(ShadowRootMode.open, shadow_root.getMode());
    try std.testing.expectEqualStrings("open", shadow_root.get_mode());
    try std.testing.expectEqual(false, shadow_root.get_delegatesFocus());
    try std.testing.expectEqual(SlotAssignmentMode.named, shadow_root.getSlotAssignmentMode());
    try std.testing.expectEqualStrings("named", shadow_root.get_slotAssignment());
    try std.testing.expectEqual(false, shadow_root.get_clonable());
    try std.testing.expectEqual(false, shadow_root.get_serializable());
    try std.testing.expectEqual(&mock_element, shadow_root.get_host());
}

test "ShadowRoot - closed mode" {
    const allocator = std.testing.allocator;

    var mock_element: Element = undefined;

    var shadow_root = try ShadowRoot.init(
        allocator,
        &mock_element,
        .closed,
        true, // delegates_focus
        .manual, // slot_assignment
        true, // clonable
        true, // serializable
    );
    defer shadow_root.deinit();

    try std.testing.expectEqual(ShadowRootMode.closed, shadow_root.getMode());
    try std.testing.expectEqualStrings("closed", shadow_root.get_mode());
    try std.testing.expectEqual(true, shadow_root.get_delegatesFocus());
    try std.testing.expectEqual(SlotAssignmentMode.manual, shadow_root.getSlotAssignmentMode());
    try std.testing.expectEqualStrings("manual", shadow_root.get_slotAssignment());
    try std.testing.expectEqual(true, shadow_root.get_clonable());
    try std.testing.expectEqual(true, shadow_root.get_serializable());
}

test "ShadowRoot - internal flags" {
    const allocator = std.testing.allocator;

    var mock_element: Element = undefined;

    var shadow_root = try ShadowRoot.init(
        allocator,
        &mock_element,
        .open,
        false,
        .named,
        false,
        false,
    );
    defer shadow_root.deinit();

    // Test initial values
    try std.testing.expectEqual(false, shadow_root.isAvailableToElementInternals());
    try std.testing.expectEqual(false, shadow_root.isDeclarative());

    // Test setters
    shadow_root.setAvailableToElementInternals(true);
    try std.testing.expectEqual(true, shadow_root.isAvailableToElementInternals());

    shadow_root.setDeclarative(true);
    try std.testing.expectEqual(true, shadow_root.isDeclarative());
}

test "ShadowRootMode - toString" {
    try std.testing.expectEqualStrings("open", ShadowRootMode.open.toString());
    try std.testing.expectEqualStrings("closed", ShadowRootMode.closed.toString());
}

test "SlotAssignmentMode - toString" {
    try std.testing.expectEqualStrings("manual", SlotAssignmentMode.manual.toString());
    try std.testing.expectEqualStrings("named", SlotAssignmentMode.named.toString());
}
