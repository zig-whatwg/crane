// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! Text interface per WHATWG DOM Standard
//! Spec: https://dom.spec.whatwg.org/#interface-text

const std = @import("std");
const webidl = @import("webidl");
pub const dom_types = @import("dom_types");
/// Runtime type tag for Text hierarchy.
/// Used for safe downcasting from TextBase to derived types.
pub const TextTypeTag = enum {
    Text,
    CDATASection,
};

/// Base struct for Text hierarchy polymorphism.
/// All Text-derived types have `base: TextBase` as their first field.
/// This enables safe downcasting via @ptrCast.
pub const TextBase = struct {
    /// Runtime type tag for safe downcasting.
    type_tag: TextTypeTag,

    event_listener_list: ?*std.ArrayList(@import("event_target").EventListener),
    cached_child_nodes: ?*@import("node_list").NodeList = null,
    cloning_steps_hook: ?*const fn (node: *Node, copy: *Node, subtree: bool) anyerror!void = null,
    registered_observers: infra.List(@import("registered_observer").RegisteredObserver),
    owner_document: ?*@import("document").Document,
    child_nodes: infra.List(*Node),
    parent_node: ?*Node,
    node_name: []const u8,
    node_type: u16,
    data: []u8,
    allocator: Allocator,


    // ========================================================================
    // Base struct initialization helpers
    // ========================================================================
    //
    // Helper functions to create properly initialized base structs.
    // Each derived type gets its own initialization helper.
    // All collection fields (lists) are properly initialized with allocator.
    //

    /// Create a base struct initialized for CDATASection.
    /// Use this in CDATASection.init() to properly initialize the base field.
    pub fn initForCDATASection(allocator: std.mem.Allocator) TextBase {
        return .{
            .type_tag = .CDATASection,
            .allocator = allocator,
        };
    }


    // ========================================================================
    // Type-safe downcasting helpers
    // ========================================================================
    //
    // Generic downcast function that checks type tag before casting.
    // Use this for safe runtime downcasting:
    //
    //   const base: *TextBase = ...;
    //   if (base.tryCast(Element)) |elem| {
    //       // elem is *Element
    //   }
    //

    /// Type-safe downcast to any derived type.
    /// Returns null if type_tag doesn't match the requested type.
    /// 
    /// Example:
    ///   if (base.tryCast(Element)) |elem| {
    ///       // elem is *Element
    ///   }
    pub fn tryCast(self: *TextBase, comptime T: type) ?*T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            // Extract just the type name from the full path
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(TextTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }

    /// Type-safe downcast to any derived type (const version).
    pub fn tryCastConst(self: *const TextBase, comptime T: type) ?*const T {
        const type_name = @typeName(T);
        const tag = comptime blk: {
            var iter = std.mem.splitScalar(u8, type_name, '.');
            var last: []const u8 = "";
            while (iter.next()) |part| {
                last = part;
            }
            break :blk std.meta.stringToEnum(TextTypeTag, last) orelse return null;
        };
        if (self.type_tag != tag) return null;
        return @ptrCast(@alignCast(self));
    }
    //
    // Available types for tryCast() in Text hierarchy:
    //   - CDATASection
    //

};

/// DOM Spec: interface Text : CharacterData
/// Text extends CharacterData (fields/methods inherited)
/// Text must EXPLICITLY include parent mixins (codegen doesn't inherit them)
/// CharacterData includes: ChildNode, NonDocumentTypeChildNode
/// Text also includes: Slottable
const Node = @import("node").Node;
const Allocator = std.mem.Allocator;
const infra = @import("infra");
const CharacterDataBase = @import("character_data").CharacterDataBase;
const EventListener = @import("event_target").EventListener;
const Event = @import("event").Event;
const flattenOptions = @import("event_target").flattenOptions;
const flattenMoreOptions = @import("event_target").flattenMoreOptions;
const defaultPassiveValue = @import("event_target").defaultPassiveValue;
const callbackEquals = @import("event_target").callbackEquals;
const RegisteredObserver = @import("registered_observer").RegisteredObserver;
const GetRootNodeOptions = @import("node").GetRootNodeOptions;
const Document = @import("document").Document;
const Element = @import("element").Element;
const Attr = @import("attr").Attr;
const CharacterData = @import("character_data").CharacterData;
const NodeList = @import("node_list").NodeList;
const ELEMENT_NODE = @import("node").ELEMENT_NODE;
const ATTRIBUTE_NODE = @import("node").ATTRIBUTE_NODE;
const TEXT_NODE = @import("node").TEXT_NODE;
const CDATA_SECTION_NODE = @import("node").CDATA_SECTION_NODE;
const ENTITY_REFERENCE_NODE = @import("node").ENTITY_REFERENCE_NODE;
const ENTITY_NODE = @import("node").ENTITY_NODE;
const PROCESSING_INSTRUCTION_NODE = @import("node").PROCESSING_INSTRUCTION_NODE;
const COMMENT_NODE = @import("node").COMMENT_NODE;
const DOCUMENT_NODE = @import("node").DOCUMENT_NODE;
const DOCUMENT_TYPE_NODE = @import("node").DOCUMENT_TYPE_NODE;
const DOCUMENT_FRAGMENT_NODE = @import("node").DOCUMENT_FRAGMENT_NODE;
const NOTATION_NODE = @import("node").NOTATION_NODE;
const DOCUMENT_POSITION_DISCONNECTED = @import("node").DOCUMENT_POSITION_DISCONNECTED;
const ChildNode = @import("child_node").ChildNode;
const NonDocumentTypeChildNode = @import("non_document_type_child_node").NonDocumentTypeChildNode;
const Slottable = @import("slottable").Slottable;
pub const Text = struct {
    base: CharacterDataBase,

    // ========================================================================
    // Fields from Slottable mixin
    // ========================================================================
    /// Slottable name (from "slot" attribute)
    slottable_name: []const u8 = "",
    /// Currently assigned slot (null if not assigned)
    /// TODO: Implement when HTMLSlotElement is available
    assigned_slot: ?*anyopaque = null,
    /// Manual slot assignment (for manual slot assignment mode)
    /// TODO: Implement when HTMLSlotElement is available
    /// Should use weak reference per spec
    manual_slot_assignment: ?*anyopaque = null,

    // ========================================================================
    // Text fields
    // ========================================================================
    allocator: Allocator,

    pub const includes = .{ ChildNode, NonDocumentTypeChildNode, Slottable }; // From parent CharacterData + Slottable

    pub fn init(allocator: Allocator) !Text {
        return .{
            .base = CharacterDataBase.initForText(allocator),
            .allocator = allocator,
        };
    }
    pub fn deinit(self: *Text) void {
        _ = self;
        // NOTE: Parent CharacterData cleanup is handled by codegen
    }

    /// Helper to get base struct for polymorphic operations.
    /// This enables safe upcasting to CharacterDataBase for type-generic code.
    pub fn toBase(self: *Text) *CharacterDataBase {
        return &self.base;
    }


    // ========================================================================
    // Methods from ChildNode mixin
    // ========================================================================

    /// DOM §4.3.4 - ChildNode.before()
    /// Inserts nodes just before this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If viablePreviousSibling is null, then set it to parent's first child; otherwise to viablePreviousSibling's next sibling.
    /// 6. Pre-insert node into parent before viablePreviousSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_before(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viablePreviousSibling be this's first preceding sibling not in nodes; otherwise null
        var viable_previous_sibling: ?*NodeType = null;

        // Walk backwards through siblings to find first one not in nodes
        var current = this_node.get_previousSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_previous_sibling = sibling;
                break;
            }

            current = sibling.get_previousSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try Text.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If viablePreviousSibling is null, set it to parent's first child;
        // otherwise to viablePreviousSibling's next sibling
        const reference_child = if (viable_previous_sibling) |vps|
            vps.get_nextSibling()
        else
            parent.?.get_firstChild();

        // Step 6: Pre-insert node into parent before viablePreviousSibling
        _ = try mutation.preInsert(node, parent.?, reference_child);
    }
    /// DOM §4.3.4 - ChildNode.after()
    /// Inserts nodes just after this node, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. Pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_after(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try Text.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: Pre-insert node into parent before viableNextSibling
        _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
    }
    /// DOM §4.3.4 - ChildNode.replaceWith()
    /// Replaces this node with nodes, while replacing strings with Text nodes.
    /// 
    /// Steps:
    /// 1. Let parent be this's parent.
    /// 2. If parent is null, then return.
    /// 3. Let viableNextSibling be this's first following sibling not in nodes; otherwise null.
    /// 4. Let node be the result of converting nodes into a node, given nodes and this's node document.
    /// 5. If this's parent is parent, replace this with node within parent.
    /// 6. Otherwise, pre-insert node into parent before viableNextSibling.
    /// 
    /// Throws HierarchyRequestError if constraints violated.
    /// (Included from ChildNode mixin)
    pub fn call_replaceWith(self: anytype, nodes: []const dom_types.NodeOrDOMString) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const this_node = @as(*NodeType, @ptrCast(self));

        // Step 1: Let parent be this's parent
        const parent = this_node.parent_node;

        // Step 2: If parent is null, then return
        if (parent == null) {
            return;
        }

        // Step 3: Let viableNextSibling be this's first following sibling not in nodes; otherwise null
        var viable_next_sibling: ?*NodeType = null;

        // Walk forward through siblings to find first one not in nodes
        var current = this_node.get_nextSibling();
        while (current) |sibling| {
            // Check if this sibling is in the nodes array
            var found_in_nodes = false;
            for (nodes) |item| {
                if (item == .node and item.node == sibling) {
                    found_in_nodes = true;
                    break;
                }
            }

            if (!found_in_nodes) {
                viable_next_sibling = sibling;
                break;
            }

            current = sibling.get_nextSibling();
        }

        // Step 4: Let node be the result of converting nodes into a node
        const document = this_node.owner_document orelse return error.NoDocument;
        const node = try Text.convertNodesIntoNode(this_node.allocator, nodes, document);

        // Step 5: If this's parent is parent, replace this with node within parent
        // Note: The parent could have changed during convertNodesIntoNode if one of the nodes
        // contained 'this' in its subtree
        if (this_node.parent_node == parent) {
            try mutation.replace(this_node, node, parent.?);
        } else {
            // Step 6: Otherwise, pre-insert node into parent before viableNextSibling
            _ = try mutation.preInsert(node, parent.?, viable_next_sibling);
        }
    }
    /// DOM §4.3.4 - ChildNode.remove()
    /// Removes this node from its parent.
    /// 
    /// Steps:
    /// 1. If this's parent is null, then return.
    /// 2. Remove this.
    /// (Included from ChildNode mixin)
    pub fn call_remove(self: anytype) !void {
        const NodeType = @import("node").Node;
        const mutation = @import("dom").mutation;

        // Cast self to Node pointer
        const node = @as(*NodeType, @ptrCast(self));

        // Step 1: If this's parent is null, then return
        if (node.parent_node == null) {
            return;
        }

        // Step 2: Remove this
        try mutation.remove(node, false);
    }
    // ========================================================================
    // Methods from NonDocumentTypeChildNode mixin
    // ========================================================================

    /// DOM §4.3.3 - NonDocumentTypeChildNode.previousElementSibling
    /// Returns the first preceding sibling that is an element; otherwise null.
    /// 
    /// The previousElementSibling getter steps are to return the first preceding
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn previousElementSibling(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        var i: usize = parent.child_nodes.items.len;
        while (i > 0) {
            i -= 1;
            const sibling = parent.child_nodes.items[i];

            if (sibling == @as(*NodeType, @ptrCast(self))) {
                found_self = true;
                continue;
            }

            // Only look at siblings before us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    }
    /// DOM §4.3.3 - NonDocumentTypeChildNode.nextElementSibling
    /// Returns the first following sibling that is an element; otherwise null.
    /// 
    /// The nextElementSibling getter steps are to return the first following
    /// sibling that is an element; otherwise null.
    /// (Included from NonDocumentTypeChildNode mixin)
    pub fn nextElementSibling(self: anytype) ?*Element {
        // Node type will be available from module-level import in generated code
        const NodeType = @import("node").Node;
        const parent = self.parent_node orelse return null;

        // Find our index in parent's children
        var found_self = false;
        for (parent.child_nodes.items) |sibling| {
            if (sibling == @as(*NodeType, @ptrCast(self))) {
                found_self = true;
                continue;
            }

            // Only look at siblings after us
            if (found_self and sibling.node_type == NodeType.ELEMENT_NODE) {
                return @ptrCast(sibling);
            }
        }

        return null;
    }
    // ========================================================================
    // Methods from Slottable mixin
    // ========================================================================

    /// DOM §4.3.7 - Slottable.assignedSlot
    /// 
    /// Returns the slot element this slottable is assigned to, if any.
    /// Returns null if not assigned or if the shadow root is closed.
    /// 
    /// Spec: https://dom.spec.whatwg.org/#dom-slottable-assignedslot
    /// (Included from Slottable mixin)
    pub fn get_assignedSlot(self: *const @This()) ?*anyopaque {
        // The assignedSlot getter steps are to return the result of
        // find a slot given this and true (open flag)

        // TODO: Implement findSlot algorithm from shadow_dom_algorithms
        // For now, return the assigned slot if it exists
        // The "open" parameter means we only return slots in open shadow roots

        _ = self;
        return null; // TODO: Implement when slot algorithms are available
    }

    // ========================================================================
    // Internal Methods
    // ========================================================================

    /// Get the slottable name
    pub fn getSlottableName(self: *const @This()) []const u8 {
        return self.slottable_name;
    }
    /// Set the slottable name
    /// (Included from Slottable mixin)
    pub fn setSlottableName(self: *@This(), name: []const u8) void {
        self.slottable_name = name;
    }
    /// Check if this slottable is assigned
    /// (Included from Slottable mixin)
    pub fn isAssigned(self: *const @This()) bool {
        return self.assigned_slot != null;
    }
    /// Set the assigned slot
    /// (Included from Slottable mixin)
    pub fn setAssignedSlot(self: *@This(), slot: ?*anyopaque) void {
        self.assigned_slot = slot;
    }
    /// Set the manual slot assignment
    /// (Included from Slottable mixin)
    pub fn setManualSlotAssignment(self: *@This(), slot: ?*anyopaque) void {
        self.manual_slot_assignment = slot;
    }
    // ========================================================================
    // Text methods
    // ========================================================================

    /// DOM §4.12 - splitText(offset)
    /// Splits this text node at the given offset and returns the remainder as a new Text node.
    /// 
    /// Spec: To split a Text node with offset:
    /// 1. Let length be node's length.
    /// 2. If offset is greater than length, throw "IndexSizeError".
    /// 3. Let count be length minus offset.
    /// 4. Let new data be the result of substringing data with node, offset, and count.
    /// 5. Let new node be a new Text node with same node document. Set new node's data to new data.
    /// 6. If parent is not null:
    /// 6.1. Insert new node into parent before node's next sibling
    /// 6.2-6.5. Update live ranges (TODO: when Range is implemented)
    /// 7. Replace data with node, offset, count, and empty string.
    /// 8. Return new node.
    pub fn call_splitText(self: *Text, offset: u32) !*Text {
        // Step 1: Let length be node's length
        const length = self.get_length();

        // Step 2: If offset is greater than length, throw "IndexSizeError"
        if (offset > length) {
            return error.IndexSizeError;
        }

        // Step 3: Let count be length minus offset
        const count = length - offset;

        // Step 4: Let new data be the result of substringing data with node, offset, and count
        const new_data = try self.call_substringData(offset, count);

        // Step 5: Let new node be a new Text node with same node document
        // Set new node's data to new data
        const new_node = try self.allocator.create(Text);
        new_node.* = try Text.init(self.allocator);

        // Set owner document
        const self_node: *Node = @ptrCast(self);
        const new_node_as_node: *Node = @ptrCast(new_node);
        new_node_as_node.owner_document = self_node.owner_document;
        new_node_as_node.node_type = Node.TEXT_NODE;

        // Set the data by allocating a copy
        const new_node_as_cd: *CharacterData = @ptrCast(new_node);
        self.allocator.free(new_node_as_cd.data);
        new_node_as_cd.data = try self.allocator.dupe(u8, new_data);

        // Step 6: If parent is not null
        const parent = self_node.parent_node;
        if (parent) |p| {
            // Step 6.1: Insert new node into parent before node's next sibling
            const mutation = @import("dom").mutation;
            const next_sibling = self_node.get_nextSibling();
            try mutation.insert(new_node_as_node, p, next_sibling, false);

            // Steps 6.2-6.5: Update live ranges
            if (self_node.owner_document) |owner_doc| {
                const doc = try Document.fromNode(owner_doc);
                const range_tracking = @import("range_tracking");
                range_tracking.updateRangesAfterSplit(doc, self_node, new_node_as_node, offset);
            }
        }

        // Step 7: Replace data with node, offset, count, and empty string
        try self.call_deleteData(offset, count);

        // Step 8: Return new node
        return new_node;
    }
    /// DOM §4.12 - wholeText getter
    /// Returns the concatenation of the data of all contiguous Text nodes.
    /// 
    /// Steps: Return the concatenation of the data of the contiguous Text nodes of this, in tree order.
    pub fn get_wholeText(self: *const Text) ![]const u8 {
        const dom = @import("dom");
        var result = std.ArrayList(u8).init(self.allocator);
        errdefer result.deinit();

        // Collect all contiguous Text nodes in tree order
        // Start from the first contiguous Text node (walk backward to find start)
        var first = &self.base.base;
        while (dom.tree_helpers.getPreviousSibling(first)) |prev| {
            if (prev.node_type != Node.TEXT_NODE) break;
            first = prev;
        }

        // Walk forward from first, collecting data
        var current: ?*Node = first;
        while (current) |node| {
            if (node.node_type == Node.TEXT_NODE) {
                const textNode = try Text.fromNode(node);
                try result.appendSlice(textNode.base.get_data());
                current = dom.tree_helpers.getNextSibling(node);
            } else {
                break;
            }
        }

        return result.toOwnedSlice();
    }
    /// DOM §4.11 - data getter
    /// Returns this's data.
    pub fn get_data(self: *const Text) []const u8 {
        return self.data;
    }
    /// DOM §4.11 - data setter
    /// Replace data with node this, offset 0, count this's length, and data new value.
    pub fn set_data(self: *Text, new_value: []const u8) !void {
        try self.replaceData(0, @intCast(self.data.len), new_value);
    }
    /// DOM §4.11 - length getter
    /// Returns this's length (number of code units).
    pub fn get_length(self: *const Text) u32 {
        return @intCast(self.data.len);
    }
    /// DOM §4.11 - substringData(offset, count)
    /// Returns a substring of this's data.
    /// 
    /// Steps:
    /// 1. Let length be node's length.
    /// 2. If offset is greater than length, then throw an "IndexSizeError" DOMException.
    /// 3. If offset plus count is greater than length, return code units from offset to end.
    /// 4. Return code units from offset to offset+count.
    pub fn call_substringData(self: *const Text, offset: u32, count: u32) ![]const u8 {
        const length: u32 = @intCast(self.data.len);

        // Step 2: Check bounds
        if (offset > length) {
            return error.IndexSizeError;
        }

        // Step 3: Handle overflow
        if (offset + count > length) {
            return self.data[offset..];
        }

        // Step 4: Return substring
        return self.data[offset .. offset + count];
    }
    /// DOM §4.11 - appendData(data)
    /// Appends data to this's data.
    /// 
    /// Steps: Replace data with node this, offset this's length, count 0, and data.
    pub fn call_appendData(self: *Text, data: []const u8) !void {
        try self.replaceData(@intCast(self.data.len), 0, data);
    }
    /// DOM §4.11 - insertData(offset, data)
    /// Inserts data at the given offset.
    /// 
    /// Steps: Replace data with node this, offset, count 0, and data.
    pub fn call_insertData(self: *Text, offset: u32, data: []const u8) !void {
        try self.replaceData(offset, 0, data);
    }
    /// DOM §4.11 - deleteData(offset, count)
    /// Deletes count code units starting at offset.
    /// 
    /// Steps: Replace data with node this, offset, count, and empty string.
    pub fn call_deleteData(self: *Text, offset: u32, count: u32) !void {
        try self.replaceData(offset, count, "");
    }
    /// DOM §4.11 - replaceData(offset, count, data)
    /// Replaces count code units at offset with data.
    /// 
    /// Steps (simplified - full spec includes range and mutation handling):
    /// 1. Let length be node's length.
    /// 2. If offset is greater than length, throw "IndexSizeError".
    /// 3. If offset + count > length, set count to length - offset.
    /// 4-12. [Mutation records, ranges, and parent notification skipped for now]
    /// 5. Insert data into node's data after offset code units.
    /// 6-7. Remove count code units starting from offset + data's length.
    pub fn call_replaceData(self: *Text, offset: u32, count: u32, data: []const u8) !void {
        try self.replaceData(offset, count, data);
    }
    /// Internal replace data implementation
    fn replaceData(self: *Text, offset: u32, count_param: u32, data: []const u8) !void {
        const length: u32 = @intCast(self.data.len);
        var count = count_param;

        // Step 2: Check bounds
        if (offset > length) {
            return error.IndexSizeError;
        }

        // Step 3: Clamp count
        if (offset + count > length) {
            count = length - offset;
        }

        // Step 4: Queue mutation record
        const mutation = @import("mutation");
        const empty_nodes: []const *Node = &[_]*Node{};
        try mutation.queueMutationRecord(
            "characterData",
            &self.base,
            null,
            null,
            self.data, // oldValue
            empty_nodes,
            empty_nodes,
            null,
            null,
        );

        // Steps 5-7: Build new data string
        const new_len = length - count + @as(u32, @intCast(data.len));
        const new_data = try self.allocator.alloc(u8, new_len);

        // Copy before offset
        @memcpy(new_data[0..offset], self.data[0..offset]);

        // Copy new data
        @memcpy(new_data[offset .. offset + data.len], data);

        // Copy after deleted region
        const after_start = offset + count;
        if (after_start < length) {
            @memcpy(new_data[offset + data.len ..], self.data[after_start..]);
        }

        // Replace old data
        self.allocator.free(self.data);
        self.data = new_data;

        // Steps 8-11 - Update ranges
        if (self.base.owner_document) |owner_doc| {
            if (Document.fromNode(owner_doc)) |doc| {
                const range_tracking = @import("range_tracking");
                const new_length = @as(u32, @intCast(data.len));
                range_tracking.updateRangesAfterReplace(doc, &self.base, offset, count, new_length);
            } else |_| {
                // Document conversion failed, skip range updates
            }
        }

        // Step 12 - Run children changed steps for parent
        // Per spec: "If node's parent is non-null, then run the children changed steps for node's parent"
        // Spec: https://dom.spec.whatwg.org/#concept-node-replace
        //
        // Children changed steps are extension points for other specifications (e.g., HTML)
        // to define custom behavior when children change. Examples:
        // - Shadow DOM slot assignment algorithm
        // - Form-associated element connections
        // - Custom element reactions
        if (self.base.parent_node) |parent| {
            // Call the mutation module's children changed callback system
            // This will invoke any registered callbacks from other specifications
            @import("mutation").runChildrenChangedSteps(parent);
        }
    }
    /// insertBefore(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-insertbefore
    pub fn call_insertBefore(self: *Text, node: *Text, child: ?*Text) !*Text {
        // Call mutation.preInsert algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preInsert(node, self, child) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// appendChild(node)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-appendchild
    pub fn call_appendChild(self: *Text, node: *Text) !*Text {
        // Call mutation.append algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.append(node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// replaceChild(node, child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-replacechild
    pub fn call_replaceChild(self: *Text, node: *Text, child: *Text) !*Text {
        // Call mutation.replace algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.replace(child, node, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// removeChild(child)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-removechild
    pub fn call_removeChild(self: *Text, child: *Text) !*Text {
        // Call mutation.preRemove algorithm from src/dom/mutation.zig
        const mutation = @import("dom").mutation;
        return mutation.preRemove(child, self) catch |err| switch (err) {
            error.HierarchyRequestError => error.HierarchyRequestError,
            error.NotFoundError => error.NotFoundError,
            error.NotSupportedError => error.NotSupportedError,
        };
    }
    /// getRootNode(options)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-getrootnode
    /// 
    /// The getRootNode(options) method steps are to return this's shadow-including root
    /// if options["composed"] is true; otherwise this's root.
    pub fn call_getRootNode(self: *Text, options: ?GetRootNodeOptions) *Text {
        const tree = @import("dom").tree;

        // Check if we need shadow-including root
        const composed = if (options) |opts| opts.composed else false;

        if (composed) {
            // Return shadow-including root
            // TODO: Implement shadow-including root traversal when Shadow DOM is fully integrated
            // For now, shadow-including root falls back to regular root
            // Shadow-including root algorithm:
            // - Get node's root
            // - If root is shadow root, recursively get root's host's shadow-including root
            // - Otherwise return root
            return tree.root(self);
        } else {
            // Return regular root
            return tree.root(self);
        }
    }
    /// contains(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-contains
    pub fn call_contains(self: *const Text, other: ?*const Text) bool {
        if (other == null) return false;
        // Check if other is an inclusive descendant of this
        const tree = @import("dom").tree;
        const other_node = other.?;
        return tree.isInclusiveDescendant(other_node, self);
    }
    /// compareDocumentPosition(other)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    pub fn call_compareDocumentPosition(self: *const Text, other: *const Text) u16 {
        const tree = @import("dom").tree;

        // Step 1: If this is other, then return zero
        if (self == other) {
            return 0;
        }

        // Step 2: Let node1 be other and node2 be this
        const node1 = other;
        const node2 = self;

        // Step 3: Let attr1 and attr2 be null
        // Step 4-5: Handle attributes (not implemented yet - attributes don't participate in tree)
        // For now, we skip attribute handling as Attr nodes are handled separately

        // Step 6: If node1 or node2 is null, or node1's root is not node2's root
        // Check if nodes are in the same tree by comparing roots
        const root1 = tree.root(@constCast(node1));
        const root2 = tree.root(@constCast(node2));

        if (root1 != root2) {
            // Return disconnected + implementation specific + preceding/following
            // Use pointer comparison for consistent ordering
            const ptr1 = @intFromPtr(node1);
            const ptr2 = @intFromPtr(node2);
            const ordering = if (ptr1 < ptr2) Text.DOCUMENT_POSITION_PRECEDING else Text.DOCUMENT_POSITION_FOLLOWING;
            return Text.DOCUMENT_POSITION_DISCONNECTED | Text.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | ordering;
        }

        // Step 7: If node1 is an ancestor of node2
        if (tree.isAncestor(node1, node2)) {
            return Text.DOCUMENT_POSITION_CONTAINS | Text.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 8: If node1 is a descendant of node2
        if (tree.isDescendant(node1, node2)) {
            return Text.DOCUMENT_POSITION_CONTAINED_BY | Text.DOCUMENT_POSITION_FOLLOWING;
        }

        // Step 9: If node1 is preceding node2
        if (tree.isPreceding(node1, node2)) {
            return Text.DOCUMENT_POSITION_PRECEDING;
        }

        // Step 10: Return DOCUMENT_POSITION_FOLLOWING
        return Text.DOCUMENT_POSITION_FOLLOWING;
    }
    /// isEqualNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isequalnode
    pub fn call_isEqualNode(self: *const Text, other_node: ?*const Text) bool {
        // Step 1: Return true if otherNode is non-null and this equals otherNode
        if (other_node == null) return false;
        return Text.nodeEquals(self, other_node.?);
    }
    /// isSameNode(otherNode)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-issamenode
    pub fn call_isSameNode(self: *const Text, other_node: ?*const Text) bool {
        // Legacy alias of === (pointer equality)
        if (other_node == null) return false;
        return self == other_node.?;
    }
    /// hasChildNodes()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-haschildnodes
    pub fn call_hasChildNodes(self: *const Text) bool {
        return self.child_nodes.len > 0;
    }
    /// cloneNode(deep)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-clonenode
    pub fn call_cloneNode(self: *Text, deep: bool) !*Text {
        // Step 1: If this is a shadow root, throw NotSupportedError
        if (self.node_type == Text.DOCUMENT_FRAGMENT_NODE) {
            // Check if this is specifically a ShadowRoot
            // ShadowRoot inherits from DocumentFragment, so we need to check the type tag
            const DocumentFragmentBase = @import("document_fragment").DocumentFragmentBase;

            // Try to access as DocumentFragmentBase to check type tag
            // This is safe because DocumentFragment/ShadowRoot have base as first field
            const frag_base: *const DocumentFragmentBase = @ptrCast(@alignCast(self));
            if (frag_base.type_tag == .ShadowRoot) {
                return error.NotSupportedError;
            }
        }

        // Step 2: Return the result of cloning this node with subtree set to deep
        return try Text.cloneNodeInternal(self, self.owner_document, deep, null, null);
    }
    /// normalize()
    /// Spec: https://dom.spec.whatwg.org/#dom-node-normalize
    pub fn call_normalize(self: *Text) void {
        _ = self;
        // Normalize adjacent text nodes
    }
    /// Getters
    pub fn get_nodeType(self: *const Text) u16 {
        return self.node_type;
    }
    pub fn get_nodeName(self: *const Text) []const u8 {
        return self.node_name;
    }
    pub fn get_parentNode(self: *const Text) ?*Text {
        return self.parent_node;
    }
    pub fn get_parentElement(self: *const Text) ?*Element {
        // Returns parent if it's an Element, null otherwise
        const parent = self.parent_node orelse return null;
        if (parent.node_type == ELEMENT_NODE) {
            // Cast to Element - safe because we checked node_type
            return @ptrCast(@alignCast(parent));
        }
        return null;
    }
    pub fn get_childNodes(self: *Text) !*@import("node_list").NodeList {
        // [SameObject] - Return the same NodeList object each time
        // The NodeList is a live view of this node's children

        if (self.cached_child_nodes) |list| {
            return list;
        }

        // Create new NodeList on first access
        const list = try self.allocator.create(NodeList);
        list.* = try NodeList.init(self.allocator);

        // Populate with current children (live view will track changes)
        for (self.child_nodes.items) |child| {
            try list.addNode(child);
        }

        self.cached_child_nodes = list;
        return list;
    }
    pub fn get_firstChild(self: *const Text) ?*Text {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(0);
        }
        return null;
    }
    pub fn get_lastChild(self: *const Text) ?*Text {
        if (self.child_nodes.len > 0) {
            return self.child_nodes.get(self.child_nodes.len - 1);
        }
        return null;
    }
    pub fn get_ownerDocument(self: *const Text) ?*Document {
        return self.owner_document;
    }
    pub fn get_previousSibling(self: *const Text) ?*Text {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i == 0) return null;
                return parent.child_nodes.items[i - 1];
            }
        }
        return null;
    }
    pub fn get_nextSibling(self: *const Text) ?*Text {
        const parent = self.parent_node orelse return null;
        for (parent.child_nodes.items, 0..) |child, i| {
            if (child == self) {
                if (i + 1 >= parent.child_nodes.items.len) return null;
                return parent.child_nodes.items[i + 1];
            }
        }
        return null;
    }
    pub fn get_isConnected(self: *const Text) bool {
        // A node is connected if its root is a document
        const tree = @import("dom").tree;
        // tree.root requires mutable pointer but doesn't actually mutate
        // Cast to mutable for the algorithm (safe for read-only root traversal)
        const mutable_self = @constCast(self);
        const root_node = tree.root(mutable_self);
        // Check if root is a document (node_type == DOCUMENT_NODE)
        return root_node.node_type == DOCUMENT_NODE;
    }
    /// DOM §4.4 - Node.baseURI getter
    /// Returns this's node document's document base URL, serialized.
    /// 
    /// The baseURI getter steps are to return this's node document's
    /// document base URL, serialized.
    pub fn get_baseURI(self: *const Text) []const u8 {
        // Get owner document
        const doc = self.owner_document orelse {
            // If no owner document, return empty string (should not happen in normal DOM)
            return "about:blank";
        };

        // Return document's base URI
        return doc.base_uri;
    }
    pub fn get_nodeValue(self: *const Text) ?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // The nodeValue getter steps are to return the following, switching on the interface:
        // - Attr: this's value
        // - CharacterData: this's data
        // - Otherwise: null

        switch (self.node_type) {
            ATTRIBUTE_NODE => {
                // Attr node
                const attr: *const Attr = @ptrCast(@alignCast(self));
                return attr.value;
            },
            TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE => {
                // CharacterData nodes (Text, Comment, ProcessingInstruction, CDATASection)
                const char_data: *const CharacterData = @ptrCast(@alignCast(self));
                return char_data.data;
            },
            else => {
                // All other node types return null
                return null;
            },
        }
    }
    pub fn set_nodeValue(self: *Text, value: ?[]const u8) !void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-nodevalue
        // The nodeValue setter steps are to, if given value is null, act as if it was empty string
        // Then:
        // - Attr: Set an existing attribute value with this and the given value
        // - CharacterData: Replace data with node this, offset 0, count this's length, data given value
        // - Otherwise: Do nothing

        const str_value = value orelse "";

        switch (self.node_type) {
            ATTRIBUTE_NODE => {
                // Attr node - set an existing attribute value
                const attr: *Attr = @ptrCast(@alignCast(self));
                // Use "set an existing attribute value" algorithm from Attr
                try Attr.setExistingAttributeValue(attr, str_value);
            },
            TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE => {
                // CharacterData nodes - replace data
                const char_data: *CharacterData = @ptrCast(@alignCast(self));
                // Replace data: offset 0, count = length, data = str_value
                try char_data.call_replaceData(0, @intCast(char_data.data.len), str_value);
            },
            else => {
                // All other node types do nothing
            },
        }
    }
    pub fn get_textContent(self: *const Text) !?[]const u8 {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // Return the result of running get text content with this
        return Text.getTextContent(self, self.allocator);
    }
    pub fn set_textContent(self: *Text, value: ?[]const u8) !void {
        // Spec: https://dom.spec.whatwg.org/#dom-node-textcontent
        // If the given value is null, act as if it was the empty string instead
        const str_value = value orelse "";
        try Text.setTextContent(self, str_value);
    }
    /// lookupPrefix(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupprefix
    pub fn call_lookupPrefix(self: *const Text, namespace_param: ?[]const u8) ?[]const u8 {
        // Spec step 1: If namespace is null or empty, return null
        const namespace = namespace_param orelse return null;
        if (namespace.len == 0) return null;

        // Spec step 2: Switch on node type
        switch (self.node_type) {
            ELEMENT_NODE => {
                // Return result of locating a namespace prefix
                return self.locateNamespacePrefix(namespace);
            },
            DOCUMENT_NODE => {
                // If document element is null, return null
                const doc: *const Document = @ptrCast(@alignCast(self));
                const doc_elem = doc.documentElement() orelse return null;
                return doc_elem.base.locateNamespacePrefix(namespace);
            },
            DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE => {
                return null;
            },
            else => {
                // For other node types, use parent element if exists
                const parent = self.parent_element orelse return null;
                return parent.base.locateNamespacePrefix(namespace);
            },
        }
    }
    /// lookupNamespaceURI(prefix)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
    pub fn call_lookupNamespaceURI(self: *const Text, prefix_param: ?[]const u8) ?[]const u8 {
        // Spec step 1: If prefix is empty string, set to null
        const prefix = if (prefix_param) |p| if (p.len == 0) null else p else null;

        // Spec step 2: Return result of locating a namespace
        return self.locateNamespace(prefix);
    }
    /// isDefaultNamespace(namespace)
    /// Spec: https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
    pub fn call_isDefaultNamespace(self: *const Text, namespace_param: ?[]const u8) bool {
        // Spec step 1: If namespace is empty string, set to null
        const namespace = if (namespace_param) |ns| if (ns.len == 0) null else ns else null;

        // Spec step 2: Let defaultNamespace be result of locating namespace using null prefix
        const default_namespace = self.locateNamespace(null);

        // Spec step 3: Return true if defaultNamespace equals namespace
        if (default_namespace == null and namespace == null) return true;
        if (default_namespace == null or namespace == null) return false;
        return std.mem.eql(u8, default_namespace.?, namespace.?);
    }
    /// Locate a namespace prefix for element (internal algorithm)
    /// Spec: https://dom.spec.whatwg.org/#locate-a-namespace-prefix
    fn locateNamespacePrefix(self: *const Text, namespace: []const u8) ?[]const u8 {
        if (self.node_type != ELEMENT_NODE) return null;

        const elem: *const Element = @ptrCast(@alignCast(self));

        // Step 1: If element's namespace is namespace and prefix is non-null, return prefix
        if (elem.namespace_uri) |ns| {
            if (std.mem.eql(u8, ns, namespace)) {
                if (elem.prefix) |p| return p;
            }
        }

        // Step 2: If element has attribute with prefix "xmlns" and value namespace, return local name
        for (elem.attributes.items) |attr| {
            if (attr.prefix) |attr_prefix| {
                if (std.mem.eql(u8, attr_prefix, "xmlns") and std.mem.eql(u8, attr.value, namespace)) {
                    return attr.local_name;
                }
            }
        }

        // Step 3: If parent element exists, recurse
        if (self.parent_element) |parent| {
            return parent.base.locateNamespacePrefix(namespace);
        }

        // Step 4: Return null
        return null;
    }
    /// Locate a namespace for node (internal algorithm)
    /// Spec: https://dom.spec.whatwg.org/#locate-a-namespace
    fn locateNamespace(self: *const Text, prefix: ?[]const u8) ?[]const u8 {
        switch (self.node_type) {
            ELEMENT_NODE => {
                const elem: *const Element = @ptrCast(@alignCast(self));

                // Step 1: If prefix is "xml", return XML namespace
                if (prefix) |p| {
                    if (std.mem.eql(u8, p, "xml")) {
                        return "http://www.w3.org/XML/1998/namespace";
                    }
                    // Step 2: If prefix is "xmlns", return XMLNS namespace
                    if (std.mem.eql(u8, p, "xmlns")) {
                        return "http://www.w3.org/2000/xmlns/";
                    }
                }

                // Step 3: If namespace is non-null and prefix matches, return namespace
                if (elem.namespace_uri) |ns| {
                    if ((prefix == null and elem.prefix == null) or
                        (prefix != null and elem.prefix != null and std.mem.eql(u8, prefix.?, elem.prefix.?)))
                    {
                        return ns;
                    }
                }

                // Step 4: Check for xmlns attributes
                // If it has an attribute whose namespace is XMLNS namespace, prefix is "xmlns",
                // and local name is prefix, return its value if not empty string, else null.
                // Or if prefix is null and it has an attribute whose namespace is XMLNS namespace,
                // prefix is null, and local name is "xmlns", return its value if not empty, else null.
                for (elem.attributes.items) |attr| {
                    const xmlns_ns = "http://www.w3.org/2000/xmlns/";

                    if (attr.namespace_uri) |attr_ns| {
                        if (std.mem.eql(u8, attr_ns, xmlns_ns)) {
                            // Check if this matches our prefix
                            if (prefix) |p| {
                                // Looking for xmlns:prefix attribute
                                if (attr.prefix) |attr_prefix| {
                                    if (std.mem.eql(u8, attr_prefix, "xmlns") and std.mem.eql(u8, attr.local_name, p)) {
                                        return if (attr.value.len > 0) attr.value else null;
                                    }
                                }
                            } else {
                                // Looking for xmlns attribute (default namespace)
                                if (attr.prefix == null and std.mem.eql(u8, attr.local_name, "xmlns")) {
                                    return if (attr.value.len > 0) attr.value else null;
                                }
                            }
                        }
                    }
                }

                // Step 5: If parent element is null, return null
                const parent = self.parent_element orelse return null;

                // Step 6: Return result of locating namespace on parent
                return parent.base.locateNamespace(prefix);
            },
            DOCUMENT_NODE => {
                // Step 1: If document element is null, return null
                const doc: *const Document = @ptrCast(@alignCast(self));
                const doc_elem = doc.documentElement() orelse return null;

                // Step 2: Return result of locating namespace on document element
                return doc_elem.base.locateNamespace(prefix);
            },
            DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE => {
                return null;
            },
            ATTRIBUTE_NODE => {
                // Step 1: If element is null, return null
                const AttributeType = @import("attr").Attr;
                const attr: *const AttributeType = @ptrCast(@alignCast(self));
                const element = attr.owner_element orelse return null;

                // Step 2: Return result of locating namespace on element
                return element.base.locateNamespace(prefix);
            },
            else => {
                // Step 1: If parent element is null, return null
                const parent = self.parent_element orelse return null;

                // Step 2: Return result of locating namespace on parent
                return parent.base.locateNamespace(prefix);
            },
        }
    }
    /// Get the list of registered observers for this node
    pub fn getRegisteredObservers(self: *Text) *std.ArrayList(RegisteredObserver) {
        return &self.registered_observers;
    }
    /// Add a registered observer to this node's list
    pub fn addRegisteredObserver(self: *Text, registered: RegisteredObserver) !void {
        try self.registered_observers.append(registered);
    }
    /// Remove all registered observers for a specific MutationObserver
    pub fn removeRegisteredObserver(self: *Text, observer: *const @import("mutation_observer").MutationObserver) void {
        var i: usize = 0;
        while (i < self.registered_observers.items.len) {
            if (self.registered_observers.items[i].observer == observer) {
                _ = self.registered_observers.orderedRemove(i);
                // Don't increment i, we just shifted everything down
            } else {
                i += 1;
            }
        }
    }
    /// Remove all transient registered observers whose source matches the given registered observer
    /// 
    /// Spec: Used during MutationObserver.observe() to clean up old transient observers
    /// when re-observing a node with updated options.
    pub fn removeTransientObservers(self: *Text, source: *const RegisteredObserver) void {
        // Note: In our current implementation, we don't have a way to distinguish
        // transient observers from regular ones in the registered_observers list.
        // This would require either:
        // 1. A separate transient_observers list, OR
        // 2. Wrapping RegisteredObserver in a tagged union
        //
        // For now, this is a no-op. Transient observers are not yet fully implemented.
        // When they are, they should be stored separately or tagged so we can identify
        // and remove them here.
        _ = self;
        _ = source;
    }
    /// Ensure event listener list is allocated
    /// Lazily allocates the list on first use to save memory
    fn ensureEventListenerList(self: *Text) !*std.ArrayList(EventListener) {
        if (self.event_listener_list) |list| {
            return list;
        }

        // First time adding a listener - allocate the list
        const list = try self.allocator.create(std.ArrayList(EventListener));
        list.* = std.ArrayList(EventListener).init(self.allocator);
        self.event_listener_list = list;
        return list;
    }
    /// Get event listener list (read-only access)
    /// Returns empty slice if no listeners have been added yet
    fn getEventListenerList(self: *const Text) []const EventListener {
        if (self.event_listener_list) |list| {
            return list.items;
        }
        return &[_]EventListener{};
    }
    /// DOM §2.7 - add an event listener
    /// To add an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn addAnEventListener(self: *Text, listener: EventListener) !void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Step 2: If listener's signal is not null and is aborted, then return
        if (listener.signal) |signal| {
            if (signal.aborted) return;
        }

        // Step 3: If listener's callback is null, then return
        if (listener.callback == null) return;

        // Step 4: If listener's passive is null, set it to default passive value
        var updated_listener = listener;
        if (updated_listener.passive == null) {
            updated_listener.passive = defaultPassiveValue(listener.type, self);
        }

        // Step 5: If event listener list does not contain matching listener, append it
        const list = try self.ensureEventListenerList();

        const already_exists = for (list.items) |existing| {
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                break true;
            }
        } else false;

        if (!already_exists) {
            try list.append(updated_listener);
        }

        // Step 6: If listener's signal is not null, add abort steps
        // Spec: "If listener's signal is not null, then add the following abort steps to it:
        // Remove an event listener with eventTarget and listener."
        // https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
        if (listener.signal) |signal| {
            const AbortSignalType = @import("abort_signal").AbortSignal;
            const removal_context = AbortSignalType.EventListenerRemovalContext{
                .target = self,
                .listener_type = updated_listener.type,
                .listener_callback = updated_listener.callback,
                .listener_capture = updated_listener.capture,
            };
            try signal.addEventListenerRemoval(removal_context);
        }
    }
    /// addEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
    /// The addEventListener(type, callback, options) method steps are:
    /// 1. Let capture, passive, once, and signal be the result of flattening more options.
    /// 2. Add an event listener with this and an event listener whose type is type,
    /// callback is callback, capture is capture, passive is passive, once is once,
    /// and signal is signal.
    pub fn call_addEventListener(
        self: *Text,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) !void {
        // Step 1: Flatten more options
        const flattened = flattenMoreOptions(options);

        // Step 2: Add an event listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = flattened.capture,
            .passive = flattened.passive,
            .once = flattened.once,
            .signal = flattened.signal,
        };

        try self.addAnEventListener(listener);
    }
    /// DOM §2.7 - remove an event listener
    /// To remove an event listener, given an EventTarget object eventTarget and
    /// an event listener listener, run these steps:
    fn removeAnEventListener(self: *Text, listener: EventListener) void {
        // Step 1: ServiceWorkerGlobalScope warning (skipped - not applicable)

        // Early exit if no listeners have been added yet
        const list = self.event_listener_list orelse return;

        // Step 2: Set listener's removed to true and remove listener from event listener list
        var i: usize = 0;
        while (i < list.items.len) {
            const existing = &list.items[i];

            // Match on type, callback, and capture
            if (std.mem.eql(u8, existing.type, listener.type) and
                existing.capture == listener.capture and
                callbackEquals(existing.callback, listener.callback))
            {
                existing.removed = true;
                _ = list.orderedRemove(i);
                return;
            }
            i += 1;
        }
    }
    /// removeEventListener(type, callback, options)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
    /// The removeEventListener(type, callback, options) method steps are:
    /// 1. Let capture be the result of flattening options.
    /// 2. If this's event listener list contains an event listener whose type is type,
    /// callback is callback, and capture is capture, then remove an event listener
    /// with this and that event listener.
    pub fn call_removeEventListener(
        self: *Text,
        event_type: []const u8,
        callback: ?webidl.JSValue,
        options: anytype,
    ) void {
        // Step 1: Flatten options
        const capture = flattenOptions(options);

        // Step 2: Remove matching listener
        const listener = EventListener{
            .type = event_type,
            .callback = callback,
            .capture = capture,
        };

        self.removeAnEventListener(listener);
    }
    /// dispatchEvent(event)
    /// Spec: https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent
    /// The dispatchEvent(event) method steps are:
    /// 1. If event's dispatch flag is set, or if its initialized flag is not set,
    /// then throw an "InvalidStateError" DOMException.
    /// 2. Initialize event's isTrusted attribute to false.
    /// 3. Return the result of dispatching event to this.
    pub fn call_dispatchEvent(self: *Text, event: *Event) !bool {
        // Step 1: Check flags
        if (event.dispatch_flag or !event.initialized_flag) {
            return error.InvalidStateError;
        }

        // Step 2: Initialize isTrusted to false
        event.is_trusted = false;

        // Step 3: Dispatch event to this using full dispatch algorithm
        const event_dispatch = @import("dom").event_dispatch;
        return event_dispatch.dispatch(event, self, false, null) catch |err| {
            // Handle dispatch errors
            return err;
        };
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "Text",
        .kind = .interface,
        .exposed = &.{.Window},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

