// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const Node = @import("node").Node;
const NodeFilter = @import("node_filter").NodeFilter;
const std = @import("std");
const webidl = @import("webidl");


/// DOM ยง6.3 - TreeWalker interface
///
/// TreeWalker objects can be used to filter and traverse node trees.
/// Unlike NodeIterator, TreeWalker provides rich navigation methods
/// (parentNode, firstChild, lastChild, previousSibling, nextSibling)
/// and maintains a mutable currentNode pointer.

pub const TreeWalker = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    root: *Node,
    current: *Node,
    what_to_show: u32,
    filter: NodeFilter.OptionalAcceptNodeFn,
    active_flag: bool,

    // ========================================================================
    // Constants
    // ========================================================================

    pub const ChildType = enum { first, last };
    pub const SiblingType = enum { next, previous };

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: Allocator,
        root: *Node,
        what_to_show: u32,
        filter: NodeFilter.OptionalAcceptNodeFn,
    ) !TreeWalker {

        return .{
            .allocator = allocator,
            .root = root,
            .current = root, // Start at root
            .what_to_show = what_to_show,
            .filter = filter,
            .active_flag = false,
        };
    
    }

    pub fn deinit(self: *TreeWalker) void {

        _ = self;
        // No cleanup needed - we don't own the nodes
    
    }

    pub fn get_root(self: *const TreeWalker) *Node {

        return self.root;
    
    }

    pub fn get_whatToShow(self: *const TreeWalker) u32 {

        return self.what_to_show;
    
    }

    pub fn get_filter(self: *const TreeWalker) NodeFilter.OptionalAcceptNodeFn {

        return self.filter;
    
    }

    pub fn get_currentNode(self: *const TreeWalker) *Node {

        return self.current;
    
    }

    pub fn set_currentNode(self: *TreeWalker, node: *Node) void {

        self.current = node;
    
    }

    pub fn parentNode(self: *TreeWalker) !?*Node {

        const dom = @import("dom");

        // Step 1: Let node be this's current
        var node = self.current;

        // Step 2: While node is non-null and is not this's root
        while (node != self.root) {
            // Step 2.1: Set node to node's parent
            const parent = dom.tree_helpers.getParentNode(node) orelse break;
            node = parent;

            // Step 2.2: If node is non-null and filtering node returns FILTER_ACCEPT
            const result = try self.filterNode(node);
            if (result == NodeFilter.FILTER_ACCEPT) {
                self.current = node;
                return node;
            }
        }

        // Step 3: Return null
        return null;
    
    }

    pub fn firstChild(self: *TreeWalker) !?*Node {

        return try self.traverseChildren(.first);
    
    }

    pub fn lastChild(self: *TreeWalker) !?*Node {

        return try self.traverseChildren(.last);
    
    }

    pub fn previousSibling(self: *TreeWalker) !?*Node {

        return try self.traverseSiblings(.previous);
    
    }

    pub fn nextSibling(self: *TreeWalker) !?*Node {

        return try self.traverseSiblings(.next);
    
    }

    pub fn previousNode(self: *TreeWalker) !?*Node {

        const dom = @import("dom");

        // Step 1: Let node be this's current
        var node = self.current;

        // Step 2: While node is not this's root
        while (node != self.root) {
            // Step 2.1: Let sibling be node's previous sibling
            var sibling = dom.tree_helpers.getPreviousSibling(node);

            // Step 2.2: While sibling is non-null
            while (sibling) |sib| {
                // Step 2.2.1: Set node to sibling
                node = sib;

                // Step 2.2.2: Let result be the result of filtering node
                var result = try self.filterNode(node);

                // Step 2.2.3: While result is not FILTER_REJECT and node has a child
                while (result != NodeFilter.FILTER_REJECT and dom.tree_helpers.hasChildren(node)) {
                    // Step 2.2.3.1: Set node to node's last child
                    node = dom.tree_helpers.getLastChild(node).?;

                    // Step 2.2.3.2: Set result to the result of filtering node
                    result = try self.filterNode(node);
                }

                // Step 2.2.4: If result is FILTER_ACCEPT, set current and return
                if (result == NodeFilter.FILTER_ACCEPT) {
                    self.current = node;
                    return node;
                }

                // Step 2.2.5: Set sibling to node's previous sibling
                sibling = dom.tree_helpers.getPreviousSibling(node);
            }

            // Step 2.3: If node is root or node's parent is null, return null
            if (node == self.root or dom.tree_helpers.getParentNode(node) == null) {
                return null;
            }

            // Step 2.4: Set node to node's parent
            node = dom.tree_helpers.getParentNode(node).?;

            // Step 2.5: If filtering node returns FILTER_ACCEPT, set current and return
            const result = try self.filterNode(node);
            if (result == NodeFilter.FILTER_ACCEPT) {
                self.current = node;
                return node;
            }
        }

        // Step 3: Return null
        return null;
    
    }

    pub fn nextNode(self: *TreeWalker) !?*Node {

        const dom = @import("dom");

        // Step 1: Let node be this's current
        var node = self.current;

        // Step 2: Let result be FILTER_ACCEPT
        var result: u16 = NodeFilter.FILTER_ACCEPT;

        // Step 3: While true
        while (true) {
            // Step 3.1: While result is not FILTER_REJECT and node has a child
            while (result != NodeFilter.FILTER_REJECT and dom.tree_helpers.hasChildren(node)) {
                // Step 3.1.1: Set node to its first child
                node = dom.tree_helpers.getFirstChild(node).?;

                // Step 3.1.2: Set result to the result of filtering node
                result = try self.filterNode(node);

                // Step 3.1.3: If result is FILTER_ACCEPT, set current and return
                if (result == NodeFilter.FILTER_ACCEPT) {
                    self.current = node;
                    return node;
                }
            }

            // Step 3.2: Let sibling be null
            var sibling: ?*Node = null;

            // Step 3.3: Let temporary be node
            var temporary: ?*Node = node;

            // Step 3.4: While temporary is non-null
            while (temporary) |temp| {
                // Step 3.4.1: If temporary is root, return null
                if (temp == self.root) {
                    return null;
                }

                // Step 3.4.2: Set sibling to temporary's next sibling
                sibling = dom.tree_helpers.getNextSibling(temp);

                // Step 3.4.3: If sibling is non-null, set node and break
                if (sibling) |sib| {
                    node = sib;
                    break;
                }

                // Step 3.4.4: Set temporary to temporary's parent
                temporary = dom.tree_helpers.getParentNode(temp);
            }

            // If we didn't find a sibling, return null
            if (sibling == null) {
                return null;
            }

            // Step 3.5: Set result to the result of filtering node
            result = try self.filterNode(node);

            // Step 3.6: If result is FILTER_ACCEPT, set current and return
            if (result == NodeFilter.FILTER_ACCEPT) {
                self.current = node;
                return node;
            }
        }
    
    }

};


