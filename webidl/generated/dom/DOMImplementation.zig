// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const A = @import("a").A;
const ASCII = @import("a_s_c_i_i").ASCII;
const Allocator = @import("std.mem").Allocator;
const C = @import("c").C;
const CR = @import("c_r").CR;
const Cast = @import("cast").Cast;
const Create = @import("create").Create;
const Creates = @import("creates").Creates;
const D = @import("d").D;
const DOM = @import("d_o_m").DOM;
const DOMException = @import("d_o_m_exception").DOMException;
const Document = @import("document").Document;
const DocumentType = @import("document_type").DocumentType;
const E = @import("e").E;
const Element = @import("element").Element;
const ElementNS = @import("element_n_s").ElementNS;
const FF = @import("f_f").FF;
const HTML = @import("h_t_m_l").HTML;
const ID = @import("i_d").ID;
const Id = @import("id").Id;
const If = @import("if").If;
const InvalidCharacterError = @import("invalid_character_error").InvalidCharacterError;
const LF = @import("l_f").LF;
const NULL = @import("n_u_l_l").NULL;
const Name = @import("name").Name;
const Namespaces = @import("namespaces").Namespaces;
const No = @import("no").No;
const Node = @import("node").Node;
const Return = @import("return").Return;
const SPACE = @import("s_p_a_c_e").SPACE;
const SVG = @import("s_v_g").SVG;
const Set = @import("set").Set;
const Spec = @import("spec").Spec;
const Step = @import("step").Step;
const TAB = @import("t_a_b").TAB;
const Text = @import("text").Text;
const TextNode = @import("text_node").TextNode;
const The = @import("the").The;
const This = @import("this").This;
const U = @import("u").U;
const ValidDoctypeName = @import("valid_doctype_name").ValidDoctypeName;
const Validate = @import("validate").Validate;
const XMLDocument = @import("x_m_l_document").XMLDocument;
const dom = @import("dom").dom;
const std = @import("std");
const webidl = @import("webidl");


/// DOM Spec: interface DOMImplementation
///
/// Factory interface for creating documents and document types.
/// Accessed via document.implementation getter.

pub const DOMImplementation = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: Allocator,
    document: *Document,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: Allocator, document: *Document) !DOMImplementation {

        return .{
            .allocator = allocator,
            .document = document,
        };
    
    }

    pub fn deinit(self: *DOMImplementation) void {
        _ = self;
        // No cleanup needed - document owns this
    }

    /// createDocumentType(name, publicId, systemId)
    /// DOM ยง4.5 - Creates a DocumentType node
    ///
    /// Spec algorithm:
    /// 1. If name is not a valid doctype name, then throw an "InvalidCharacterError" DOMException.
    /// 2. Return a new doctype, with name as its name, publicId as its public ID, and systemId
    ///    as its system ID, and with its node document set to the associated document of this.
    pub fn call_createDocumentType(
        self: *DOMImplementation,
        name: []const u8,
        public_id: []const u8,
        system_id: []const u8,
    ) !*DocumentType {

        // Step 1: Validate doctype name
        // A string is a valid doctype name if it does not contain:
        // - ASCII whitespace (U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE)
        // - U+0000 NULL
        // - U+003E (>)
        // The empty string is valid.
        if (!isValidDoctypeName(name)) {
            return error.InvalidCharacterError;
        }

        // Step 2: Create and return new doctype
        const doctype = try self.allocator.create(DocumentType);
        doctype.* = try DocumentType.init(self.allocator, name, public_id, system_id);

        // Set node document
        doctype.base.owner_document = self.document;

        return doctype;
    
    }

    pub fn call_createDocument(
        self: *DOMImplementation,
        namespace: ?[]const u8,
        qualified_name: []const u8,
        doctype: ?*DocumentType,
    ) !*Document {

        const Node = @import("node").Node;
        const mutation = dom.mutation;

        // Step 1: Create new XMLDocument
        const document = try self.allocator.create(Document);
        document.* = try Document.init(self.allocator);
        document.document_type = .xml;

        const document_node: *Node = @ptrCast(document);

        // Step 2: element = null (handled by step 3 condition)

        // Step 3: If qualifiedName is not empty, create element
        // This throws the same exceptions as createElementNS()
        var element: ?*Element = null;
        if (qualified_name.len > 0) {
            element = try document.call_createElementNS(namespace, qualified_name);
        }

        // Step 4: If doctype is non-null, append to document
        if (doctype) |dt| {
            const dt_node: *Node = @ptrCast(dt);
            _ = try mutation.append(dt_node, document_node);
        }

        // Step 5: If element is non-null, append to document
        if (element) |elem| {
            const elem_node: *Node = @ptrCast(elem);
            _ = try mutation.append(elem_node, document_node);
        }

        // Step 6: Set document's origin
        document.origin = self.document.origin;

        // Step 7: Set content type based on namespace
        const Namespaces = @import("infra").Namespaces;
        document.content_type = if (namespace) |ns| blk: {
            if (std.mem.eql(u8, ns, Namespaces.HTML)) {
                break :blk "application/xhtml+xml";
            } else if (std.mem.eql(u8, ns, Namespaces.SVG)) {
                break :blk "image/svg+xml";
            } else {
                break :blk "application/xml";
            }
        } else "application/xml";

        // Step 8: Return document
        return document;
    
    }

    pub fn call_createHTMLDocument(
        self: *DOMImplementation,
        title: ?[]const u8,
    ) !*Document {

        const Node = @import("node").Node;
        const mutation = dom.mutation;

        // Step 1: Create new HTML document
        const doc = try self.allocator.create(Document);
        doc.* = try Document.init(self.allocator);
        doc.document_type = .html;

        const doc_node: *Node = @ptrCast(doc);

        // Step 2: Set content type to "text/html"
        doc.content_type = "text/html";

        // Step 3: Create and append doctype
        const doctype = try doc.call_createDocumentType("html", "", "");
        const doctype_node: *Node = @ptrCast(doctype);
        _ = try mutation.append(doctype_node, doc_node);

        // Step 4: Create and append html element
        const html_namespace = "http://www.w3.org/1999/xhtml";
        const html = try doc.call_createElementNS(html_namespace, "html");
        const html_node: *Node = @ptrCast(html);
        _ = try mutation.append(html_node, doc_node);

        // Step 5: Create and append head element to html
        const head = try doc.call_createElementNS(html_namespace, "head");
        const head_node: *Node = @ptrCast(head);
        _ = try mutation.append(head_node, html_node);

        // Step 6: If title is given, create title element with text
        if (title) |title_text| {
            const title_elem = try doc.call_createElementNS(html_namespace, "title");
            const title_node: *Node = @ptrCast(title_elem);
            _ = try mutation.append(title_node, head_node);

            const text_node = try doc.call_createTextNode(title_text);
            const text_node_as_node: *Node = @ptrCast(text_node);
            _ = try mutation.append(text_node_as_node, title_node);
        }

        // Step 7: Create and append body element to html
        const body = try doc.call_createElementNS(html_namespace, "body");
        const body_node: *Node = @ptrCast(body);
        _ = try mutation.append(body_node, html_node);

        // Step 8: Set doc's origin
        doc.origin = self.document.origin;

        // Step 9: Return doc
        return doc;
    
    }

};


