// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! DocumentFragment interface per WHATWG DOM Standard
//!
//! Spec: https://dom.spec.whatwg.org/#interface-documentfragment
//! Section: 4.6 "Interface DocumentFragment"
//!
//! DocumentFragment is a lightweight container for holding nodes.

const std = @import("std");
const webidl = @import("webidl");
const infra = @import("infra");

// Forward declarations
const node_mod = @import("node");
pub const Node = node_mod.Node;

const element_mod = @import("element");
pub const Element = element_mod.Element;
/// DocumentFragment interface
/// 
/// IDL:
/// ```webidl
/// [Exposed=Window]
/// interface DocumentFragment : Node {
/// constructor();
/// };
/// ```
/// 
/// From spec:
/// - DocumentFragment is a minimal Document object that has no parent
/// - It is used as a lightweight version of Document to store a well-formed
/// or potentially non-well-formed fragment of XML or HTML
/// - A DocumentFragment node has an associated host (null or an element in
/// a different node tree). It is null unless otherwise stated.
/// 
/// Use cases:
/// - Building complex DOM structures off-document (better performance)
/// - Inserting multiple nodes at once (appendChild moves all children)
/// - Template instantiation (HTML <template> uses DocumentFragment)
pub const DocumentFragment = struct {
    allocator: std.mem.Allocator,
    /// Host element (null or an element in a different node tree)
    /// 
    /// From spec: "A DocumentFragment node has an associated host (null or
    /// an element in a different node tree). It is null unless otherwise stated."
    /// 
    /// The host concept is useful for:
    /// - HTML's <template> element
    /// - Shadow roots (ShadowRoot extends DocumentFragment)
    host: ?*Element,
    /// Children nodes
    /// 
    /// From spec: DocumentFragment extends Node, so it can have children
    children: infra.List(*Node),

    /// Create a new DocumentFragment
    /// 
    /// Spec: ยง 4.6 constructor steps
    /// From spec: "The new DocumentFragment() constructor steps are to set
    /// this's node document to current global object's associated Document."
    /// 
    /// Note: We don't track node document yet, so we just initialize the fragment
    pub fn init(allocator: std.mem.Allocator) !*DocumentFragment {
        const self = try allocator.create(DocumentFragment);
        errdefer allocator.destroy(self);

        self.* = .{
            .allocator = allocator,
            .host = null,
            .children = infra.List(*Node).init(allocator),
        };

        return self;
    }
    /// Free the DocumentFragment and its resources
    pub fn deinit(self: *DocumentFragment) void {
        self.children.deinit();
        self.allocator.destroy(self);
    }
    /// Get host element
    /// 
    /// From spec: Returns the associated host element or null
    pub fn getHost(self: *const DocumentFragment) ?*Element {
        return self.host;
    }
    /// Set host element
    /// 
    /// From spec: Sets the associated host element
    /// Used by shadow roots and template elements
    pub fn setHost(self: *DocumentFragment, host: ?*Element) void {
        self.host = host;
    }
    /// Get children list
    /// 
    /// Returns reference to the children list for Node operations
    pub fn getChildren(self: *DocumentFragment) *infra.List(*Node) {
        return &self.children;
    }
    /// Get child count
    /// 
    /// Returns the number of child nodes
    pub fn childCount(self: *const DocumentFragment) usize {
        return self.children.len();
    }
    /// Append a child node
    /// 
    /// Note: This is a simplified version. The full spec algorithm involves
    /// mutation observers, validation, and other steps that we'll implement
    /// when Node appendChild is fully integrated.
    pub fn appendChild(self: *DocumentFragment, child: *Node) !void {
        try self.children.append(child);
    }
    /// Remove a child node
    /// 
    /// Note: This is a simplified version. The full spec algorithm involves
    /// mutation observers and other steps.
    pub fn removeChild(self: *DocumentFragment, child: *Node) !void {
        for (self.children.items(), 0..) |node, i| {
            if (node == child) {
                _ = self.children.remove(i);
                return;
            }
        }
        return error.NotFoundError;
    }
};


// ===== Tests =====

test "DocumentFragment - initialization" {
    const allocator = std.testing.allocator;

    const fragment = try DocumentFragment.init(allocator);
    defer fragment.deinit();

    try std.testing.expectEqual(@as(?*Element, null), fragment.getHost());
    try std.testing.expectEqual(@as(usize, 0), fragment.childCount());
}

test "DocumentFragment - host property" {
    const allocator = std.testing.allocator;

    const fragment = try DocumentFragment.init(allocator);
    defer fragment.deinit();

    try std.testing.expectEqual(@as(?*Element, null), fragment.getHost());

    // Note: We can't easily create an Element here without full setup,
    // so we just test that setHost works with null
    fragment.setHost(null);
    try std.testing.expectEqual(@as(?*Element, null), fragment.getHost());
}

test "DocumentFragment - children operations" {
    const allocator = std.testing.allocator;

    const fragment = try DocumentFragment.init(allocator);
    defer fragment.deinit();

    // Create test nodes
    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    var node2 = try Node.init(allocator, 1, "node2");
    defer node2.deinit();

    // Initially empty
    try std.testing.expectEqual(@as(usize, 0), fragment.childCount());

    // Append children
    try fragment.appendChild(&node1);
    try std.testing.expectEqual(@as(usize, 1), fragment.childCount());

    try fragment.appendChild(&node2);
    try std.testing.expectEqual(@as(usize, 2), fragment.childCount());

    // Remove child
    try fragment.removeChild(&node1);
    try std.testing.expectEqual(@as(usize, 1), fragment.childCount());
}

test "DocumentFragment - remove non-existent child throws" {
    const allocator = std.testing.allocator;

    const fragment = try DocumentFragment.init(allocator);
    defer fragment.deinit();

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    var node2 = try Node.init(allocator, 1, "node2");
    defer node2.deinit();

    try fragment.appendChild(&node1);

    const result = fragment.removeChild(&node2);
    try std.testing.expectError(error.NotFoundError, result);
}

test "DocumentFragment - multiple append and remove" {
    const allocator = std.testing.allocator;

    const fragment = try DocumentFragment.init(allocator);
    defer fragment.deinit();

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    var node2 = try Node.init(allocator, 1, "node2");
    defer node2.deinit();

    var node3 = try Node.init(allocator, 1, "node3");
    defer node3.deinit();

    // Add all three
    try fragment.appendChild(&node1);
    try fragment.appendChild(&node2);
    try fragment.appendChild(&node3);
    try std.testing.expectEqual(@as(usize, 3), fragment.childCount());

    // Remove middle one
    try fragment.removeChild(&node2);
    try std.testing.expectEqual(@as(usize, 2), fragment.childCount());

    // Remove first one
    try fragment.removeChild(&node1);
    try std.testing.expectEqual(@as(usize, 1), fragment.childCount());

    // Remove last one
    try fragment.removeChild(&node3);
    try std.testing.expectEqual(@as(usize, 0), fragment.childCount());
}

test "DocumentFragment - getChildren returns list reference" {
    const allocator = std.testing.allocator;

    const fragment = try DocumentFragment.init(allocator);
    defer fragment.deinit();

    const children = fragment.getChildren();
    try std.testing.expectEqual(@as(usize, 0), children.len());

    var node1 = try Node.init(allocator, 1, "node1");
    defer node1.deinit();

    try fragment.appendChild(&node1);

    // Children list should reflect the change
    try std.testing.expectEqual(@as(usize, 1), children.len());
}
