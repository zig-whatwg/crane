// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const URLRecord = @import("url_record").URLRecord;
const URLSearchParamsImpl = @import("url_search_params_impl").URLSearchParamsImpl;
const api_parser = @import("api_parser");
const std = @import("std");
const url_serializer = @import("url_serializer");
const webidl = @import("webidl");


pub const URL = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    /// The underlying URL record
    /// Spec: https://url.spec.whatwg.org/#concept-url-url (line 1786)
    url_record: URLRecord,
    /// The associated URLSearchParams implementation
    /// Spec: https://url.spec.whatwg.org/#url-query-object (line 1788)
    /// [SameObject] - must return same instance each time
    /// We store the implementation directly to avoid circular module dependencies
    query_impl: *URLSearchParamsImpl,
    allocator: std.mem.Allocator,

    // ========================================================================
    // WebIDL Metadata
    // ========================================================================

    pub const __webidl__ = .{
        .name = "URL",
        .kind = .interface,
        .parent = null,
        .extended_attrs = &.{
            .{ .name = "Exposed", .value = .wildcard },
        },
    };

    // ========================================================================
    // Methods
    // ========================================================================

    /// URL constructor: new URL(url, base)
    /// Spec: https://url.spec.whatwg.org/#dom-url-url (lines 1794-1800)
    /// 
    /// Steps:
    /// 1. Let parsedURL be the result of running the API URL parser on url with base, if given.
    /// 2. If parsedURL is failure, then throw a TypeError.
    /// 3. Initialize this with parsedURL.
    pub fn init(allocator: std.mem.Allocator, url: []const u8, base: ?[]const u8) !URL {

        // Step 1: Parse base URL if provided
        var base_record: ?URLRecord = null;
        if (base) |base_str| {
            base_record = api_parser.parseURL(allocator, base_str, null) catch {
                return error.TypeError; // Base URL parse failed
            };
        }
        defer if (base_record) |*br| br.deinit();

        // Step 1: Parse URL with optional base
        var parsed_url = api_parser.parseURL(
            allocator,
            url,
            if (base_record) |*br| br else null,
        ) catch {
            // Step 2: If parsedURL is failure, throw TypeError
            return error.TypeError;
        };
        errdefer parsed_url.deinit();

        // Step 3: Initialize this with parsedURL
        return try initializeWithURLRecord(allocator, parsed_url);
    
    }

    /// Initialize a URL object with a URLRecord
    /// Spec: https://url.spec.whatwg.org/#concept-url-initialize (lines 1782-1793)
    /// 
    /// Algorithm:
    /// 1. Let query be urlRecord's query, if that is non-null; otherwise the empty string.
    /// 2. Set url's URL to urlRecord.
    /// 3. Set url's query object to a new URLSearchParams object.
    /// 4. Initialize url's query object with query.
    /// 5. Set url's query object's URL object to url.
    /// 
    /// This creates the bidirectional link between URL and URLSearchParams.
    fn initializeWithURLRecord(allocator: std.mem.Allocator, url_record: URLRecord) !URL {

        // Step 1: Let query be urlRecord's query, if non-null; otherwise empty string
        const query = url_record.query() orelse "";

        // Step 3: Create new URLSearchParams object
        // Step 4: Initialize it with query string
        var query_impl = try allocator.create(URLSearchParamsImpl);
        errdefer allocator.destroy(query_impl);

        query_impl.* = try URLSearchParamsImpl.initFromString(allocator, query);
        errdefer query_impl.deinit();

        // Step 2: Create URL with url_record
        var url = URL{
            .url_record = url_record,
            .query_impl = query_impl,
            .allocator = allocator,
        };

        // Step 5: Set query object's URL object to this URL
        // We set it to point back to this URL object for bidirectional sync
        query_impl.url_object = @ptrCast(&url);

        return url;
    
    }

    pub fn deinit(self: *URL) void {

        self.query_impl.deinit();
        self.allocator.destroy(self.query_impl);
        self.url_record.deinit();
    
    }

    /// URL.parse(url, base) static method
    /// Spec: https://url.spec.whatwg.org/#dom-url-parse (lines 1835-1845)
    /// 
    /// Steps:
    /// 1. Let parsedURL be the result of running the API URL parser on url with base, if given.
    /// 2. If parsedURL is failure, then return null.
    /// 3. Return the result of creating a new URL object, with parsedURL,
    /// in the current realm.
    /// 
    /// Unlike the constructor, this returns null instead of throwing on parse failure.
    pub fn parse(allocator: std.mem.Allocator, url: []const u8, base: ?[]const u8) ?URL {

        return init(allocator, url, base) catch null;
    
    }

    /// URL.canParse(url, base) static method
    /// Spec: https://url.spec.whatwg.org/#dom-url-canparse (lines 1847-1853)
    /// 
    /// Steps:
    /// 1. Let parsedURL be the result of running the API URL parser on url with base, if given.
    /// 2. If parsedURL is failure, then return false.
    /// 3. Return true.
    pub fn canParse(allocator: std.mem.Allocator, url: []const u8, base: ?[]const u8) bool {

        // Parse base URL if provided
        var base_record: ?URLRecord = null;
        if (base) |base_str| {
            base_record = api_parser.parseURL(allocator, base_str, null) catch return false;
        }
        defer if (base_record) |*br| br.deinit();

        // Try to parse URL
        var parsed = api_parser.parseURL(
            allocator,
            url,
            if (base_record) |*br| br else null,
        ) catch return false;

        parsed.deinit();
        return true;
    
    }

    /// href getter (also used by toJSON)
    /// Spec: https://url.spec.whatwg.org/#dom-url-href (line 1855)
    /// Returns the serialization of this's URL
    pub fn get_href(self: *const URL) ![]const u8 {

        return url_serializer.serialize(self.allocator, &self.url_record, false);
    
    }

    /// origin getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-origin (line 1871)
    /// Returns serialization of this's URL's origin
    pub fn get_origin(self: *const URL) ![]const u8 {

        const origin_module = @import("origin");
        const url_origin = try origin_module.getOrigin(self.allocator, &self.url_record);
        defer url_origin.deinit(self.allocator);
        return url_origin.serialize(self.allocator);
    
    }

    /// protocol getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-protocol (line 1873)
    /// Returns scheme + ":"
    pub fn get_protocol(self: *const URL) ![]const u8 {

        const scheme = self.url_record.scheme();
        const result = try self.allocator.alloc(u8, scheme.len + 1);
        @memcpy(result[0..scheme.len], scheme);
        result[scheme.len] = ':';
        return result;
    
    }

    /// username getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-username (line 1877)
    /// Returns this's URL's username
    pub fn get_username(self: *const URL) []const u8 {

        return self.url_record.username();
    
    }

    /// password getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-password (line 1885)
    /// Returns this's URL's password
    pub fn get_password(self: *const URL) []const u8 {

        return self.url_record.password();
    
    }

    /// host getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-host (lines 1893-1901)
    /// Returns serialized host with port if present
    pub fn get_host(self: *const URL) ![]const u8 {

        const host_serializer = @import("host_serializer");

        // Step 2: If url's host is null, return empty string
        const h = self.url_record.host orelse return try self.allocator.dupe(u8, "");

        // Step 3: If url's port is null, return serialized host
        const p = self.url_record.port orelse {
            return host_serializer.serializeHost(self.allocator, h);
        };

        // Step 4: Return host:port
        const host_str = try host_serializer.serializeHost(self.allocator, h);
        defer self.allocator.free(host_str);

        const port_str = try std.fmt.allocPrint(self.allocator, "{d}", .{p});
        defer self.allocator.free(port_str);

        return std.fmt.allocPrint(self.allocator, "{s}:{s}", .{ host_str, port_str });
    
    }

    /// hostname getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-hostname (lines 1911-1915)
    /// Returns serialized host without port
    pub fn get_hostname(self: *const URL) ![]const u8 {

        const host_serializer = @import("host_serializer");

        // Step 1: If url's host is null, return empty string
        const h = self.url_record.host orelse return try self.allocator.dupe(u8, "");

        // Step 2: Return serialized host
        return host_serializer.serializeHost(self.allocator, h);
    
    }

    /// port getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-port (lines 1923-1927)
    /// Returns serialized port or empty string if null
    pub fn get_port(self: *const URL) ![]const u8 {

        // Step 1: If port is null, return empty string
        const p = self.url_record.port orelse return try self.allocator.dupe(u8, "");

        // Step 2: Return port serialized
        return std.fmt.allocPrint(self.allocator, "{d}", .{p});
    
    }

    /// pathname getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-pathname (line 1937)
    /// Returns URL path serialized
    pub fn get_pathname(self: *const URL) ![]const u8 {

        const path_serializer = @import("path_serializer");
        return path_serializer.serializePath(self.allocator, &self.url_record);
    
    }

    /// search getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-search (lines 1947-1951)
    /// Returns "?" + query or empty string
    pub fn get_search(self: *const URL) ![]const u8 {

        const q = self.url_record.query();

        // Step 1: If query is null or empty, return empty string
        if (q == null or q.?.len == 0) {
            return try self.allocator.dupe(u8, "");
        }

        // Step 2: Return "?" + query
        return std.fmt.allocPrint(self.allocator, "?{s}", .{q.?});
    
    }

    /// searchParams getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-searchparams (line 1967)
    /// Returns this's query object (via implementation wrapper)
    /// [SameObject] - must return same instance each time
    /// Note: Returns pointer to implementation for now - will wrap in URLSearchParams type later
    pub fn get_searchParams(self: *const URL) *URLSearchParamsImpl {

        return self.query_impl;
    
    }

    /// hash getter
    /// Spec: https://url.spec.whatwg.org/#dom-url-hash (lines 1969-1973)
    /// Returns "#" + fragment or empty string
    pub fn get_hash(self: *const URL) ![]const u8 {

        const f = self.url_record.fragment();

        // Step 1: If fragment is null or empty, return empty string
        if (f == null or f.?.len == 0) {
            return try self.allocator.dupe(u8, "");
        }

        // Step 2: Return "#" + fragment
        return std.fmt.allocPrint(self.allocator, "#{s}", .{f.?});
    
    }

    /// href setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-href (lines 1855-1870)
    /// Parse value, throw TypeError on failure, update URL and query object
    pub fn set_href(self: *URL, value: []const u8) !void {

        // Parse the new URL
        const parsed = api_parser.parseURL(self.allocator, value, null) catch {
            return error.TypeError;
        };

        // Replace current URL record
        self.url_record.deinit();
        self.url_record = parsed;

        // Update query object
        const query = self.url_record.query() orelse "";

        // Re-initialize query object with new query
        self.query_impl.deinit();
        self.query_impl.* = try URLSearchParamsImpl.initFromString(self.allocator, query);
        self.query_impl.url_object = @ptrCast(self);
    
    }

    /// protocol setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-protocol (line 1875)
    /// Basic URL parse with scheme start state override
    pub fn set_protocol(self: *URL, value: []const u8) !void {

        const basic_parser = @import("basic_parser");
        const ParserState = @import("parser_state").ParserState;

        // Append ":" to value per spec
        const input = try std.fmt.allocPrint(self.allocator, "{s}:", .{value});
        defer self.allocator.free(input);

        // Parse with scheme start state override
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            input,
            null,
            ParserState.scheme_start,
            &self.url_record,
        ) catch {
            // Parsing failure is silently ignored per spec behavior
            return;
        };
    
    }

    /// username setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-username (lines 1879-1883)
    /// Check cannotHaveUsernamePasswordPort, call set the username
    pub fn set_username(self: *URL, value: []const u8) !void {

        const percent_encoding = @import("percent_encoding");
        const EncodeSet = @import("encode_sets").EncodeSet;
        const form_urlencoded = @import("form_urlencoded");

        // Step 1: If cannot have username/password/port, return
        if (self.url_record.cannotHaveUsernamePasswordPort()) return;

        // Step 2: Set the username (spec line 1534)
        // "Set the username": set url's username to the result of running
        // UTF-8 percent-encode on username using the userinfo percent-encode set.

        // Percent-encode the new username
        const encoded_username = try percent_encoding.utf8PercentEncode(
            self.allocator,
            value,
            EncodeSet.userinfo,
        );
        defer self.allocator.free(encoded_username);

        // Rebuild URL with new username using string manipulation
        // (avoids complex buffer offset recalculation)
        const old_href = try url_serializer.serialize(self.allocator, &self.url_record, false);
        defer self.allocator.free(old_href);

        // Parse URL structure: scheme://[username[:password]@]host...
        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse return;
        const after_scheme = scheme_end + 3;

        // Find where authority ends (at /, ?, #, or end)
        var authority_end = old_href.len;
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '/' or c == '?' or c == '#') {
                authority_end = after_scheme + i;
                break;
            }
        }

        // Check if there's an @ (credentials separator)
        const at_pos = std.mem.indexOf(u8, old_href[after_scheme..authority_end], "@");

        const new_href = if (at_pos) |at_offset| blk: {
            // Has existing credentials: replace username part
            const at_abs = after_scheme + at_offset;
            const colon_in_creds = std.mem.indexOf(u8, old_href[after_scheme..at_abs], ":");

            if (colon_in_creds) |colon_offset| {
                // Has password: scheme://NEW_USERNAME:password@host...
                const colon_abs = after_scheme + colon_offset;
                break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{
                    old_href[0..after_scheme],
                    encoded_username,
                    old_href[colon_abs..],
                });
            } else {
                // No password: scheme://NEW_USERNAME@host...
                break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}{s}", .{
                    old_href[0..after_scheme],
                    encoded_username,
                    old_href[at_abs..],
                });
            }
        } else blk: {
            // No existing credentials: insert username@
            break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}@{s}", .{
                old_href[0..after_scheme],
                encoded_username,
                old_href[after_scheme..],
            });
        };
        defer self.allocator.free(new_href);

        // Re-parse the modified URL
        const parsed_url = api_parser.parseURL(self.allocator, new_href, null) catch return;

        // Replace internal URLRecord
        self.url_record.deinit();
        self.url_record = parsed_url;

        // Update search params (in case query changed, though unlikely here)
        const query_str = self.url_record.query() orelse "";
        self.query_impl.list.clearRetainingCapacity();
        const parsed_list = form_urlencoded.parser.parse(self.allocator, query_str) catch return;
        defer self.allocator.free(parsed_list);
        for (parsed_list) |item| {
            try self.query_impl.list.append(.{
                .name = try self.allocator.dupe(u8, item.name),
                .value = try self.allocator.dupe(u8, item.value),
            });
        }
    
    }

    /// password setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-password (lines 1887-1891)
    /// Check cannotHaveUsernamePasswordPort, call set the password
    pub fn set_password(self: *URL, value: []const u8) !void {

        const percent_encoding = @import("percent_encoding");
        const EncodeSet = @import("encode_sets").EncodeSet;
        const form_urlencoded = @import("form_urlencoded");

        // Step 1: If cannot have username/password/port, return
        if (self.url_record.cannotHaveUsernamePasswordPort()) return;

        // Step 2: Set the password (spec line 1536)
        // "Set the password": set url's password to the result of running
        // UTF-8 percent-encode on password using the userinfo percent-encode set.

        // Percent-encode the new password
        const encoded_password = try percent_encoding.utf8PercentEncode(
            self.allocator,
            value,
            EncodeSet.userinfo,
        );
        defer self.allocator.free(encoded_password);

        // Rebuild URL with new password using string manipulation
        const old_href = try url_serializer.serialize(self.allocator, &self.url_record, false);
        defer self.allocator.free(old_href);

        // Parse URL structure: scheme://[username[:password]@]host...
        const scheme_end = std.mem.indexOf(u8, old_href, "://") orelse return;
        const after_scheme = scheme_end + 3;

        // Find where authority ends (at /, ?, #, or end)
        var authority_end = old_href.len;
        for (old_href[after_scheme..], 0..) |c, i| {
            if (c == '/' or c == '?' or c == '#') {
                authority_end = after_scheme + i;
                break;
            }
        }

        // Check if there's an @ (credentials separator)
        const at_pos = std.mem.indexOf(u8, old_href[after_scheme..authority_end], "@");

        const new_href = if (at_pos) |at_offset| blk: {
            // Has existing credentials
            const at_abs = after_scheme + at_offset;
            const username_part = self.url_record.username();

            // scheme://username:NEW_PASSWORD@host...
            break :blk try std.fmt.allocPrint(self.allocator, "{s}{s}:{s}{s}", .{
                old_href[0..after_scheme],
                username_part,
                encoded_password,
                old_href[at_abs..],
            });
        } else blk: {
            // No existing credentials: insert :password@ (with empty username)
            break :blk try std.fmt.allocPrint(self.allocator, "{s}:{s}@{s}", .{
                old_href[0..after_scheme],
                encoded_password,
                old_href[after_scheme..],
            });
        };
        defer self.allocator.free(new_href);

        // Re-parse the modified URL
        const parsed_url = api_parser.parseURL(self.allocator, new_href, null) catch return;

        // Replace internal URLRecord
        self.url_record.deinit();
        self.url_record = parsed_url;

        // Update search params
        const query_str = self.url_record.query() orelse "";
        self.query_impl.list.clearRetainingCapacity();
        const parsed_list = form_urlencoded.parser.parse(self.allocator, query_str) catch return;
        defer self.allocator.free(parsed_list);
        for (parsed_list) |item| {
            try self.query_impl.list.append(.{
                .name = try self.allocator.dupe(u8, item.name),
                .value = try self.allocator.dupe(u8, item.value),
            });
        }
    
    }

    /// host setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-host (lines 1903-1907)
    /// Check opaque path, parse with host state override
    pub fn set_host(self: *URL, value: []const u8) !void {

        const basic_parser = @import("basic_parser");
        const ParserState = @import("parser_state").ParserState;

        // Step 1: If has opaque path, return
        if (self.url_record.hasOpaquePath()) return;

        // Step 2: Basic URL parse with host state override
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            value,
            null,
            ParserState.host,
            &self.url_record,
        ) catch {
            // Parsing failure is silently ignored
            return;
        };
    
    }

    /// hostname setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-hostname (lines 1917-1921)
    /// Check opaque path, parse with hostname state override
    pub fn set_hostname(self: *URL, value: []const u8) !void {

        const basic_parser = @import("basic_parser");
        const ParserState = @import("parser_state").ParserState;

        // Step 1: If has opaque path, return
        if (self.url_record.hasOpaquePath()) return;

        // Step 2: Basic URL parse with hostname state override
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            value,
            null,
            ParserState.hostname,
            &self.url_record,
        ) catch {
            // Parsing failure is silently ignored
            return;
        };
    
    }

    /// port setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-port (lines 1929-1935)
    /// Check cannotHaveUsernamePasswordPort, handle empty string, parse with port state
    pub fn set_port(self: *URL, value: []const u8) !void {

        const basic_parser = @import("basic_parser");
        const ParserState = @import("parser_state").ParserState;

        // Step 1: If cannot have username/password/port, return
        if (self.url_record.cannotHaveUsernamePasswordPort()) return;

        // Step 2: If empty string, set port to null
        if (value.len == 0) {
            self.url_record.port = null;
            return;
        }

        // Step 3: Parse with port state override
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            value,
            null,
            ParserState.port,
            &self.url_record,
        ) catch {
            // Parsing failure is silently ignored
            return;
        };
    
    }

    /// pathname setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-pathname (lines 1939-1945)
    /// Check opaque path, empty path, parse with path start state
    pub fn set_pathname(self: *URL, value: []const u8) !void {

        const basic_parser = @import("basic_parser");
        const ParserState = @import("parser_state").ParserState;

        // Step 1: If has opaque path, return
        if (self.url_record.hasOpaquePath()) return;

        // Step 2: Empty this URL's path
        // Will be handled by parser

        // Step 3: Parse with path start state override
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            value,
            null,
            ParserState.path_start,
            &self.url_record,
        ) catch {
            // Parsing failure is silently ignored
            return;
        };
    
    }

    /// search setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-search (lines 1953-1965)
    /// Handle empty, remove leading "?", parse, update query object
    pub fn set_search(self: *URL, value: []const u8) !void {

        const basic_parser = @import("basic_parser");
        const ParserState = @import("parser_state").ParserState;
        const form_parser = @import("form_parser");

        // Step 2: If empty, set query to null, empty query object list
        if (value.len == 0) {
            self.url_record.query_len = 0;
            self.query_impl.list.clearRetainingCapacity();
            return;
        }

        // Step 3: Remove leading "?" if any
        const input = if (std.mem.startsWith(u8, value, "?"))
            value[1..]
        else
            value;

        // Step 4-5: Set query to empty, parse with query state override
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            input,
            null,
            ParserState.query,
            &self.url_record,
        ) catch {
            // Parsing failure is silently ignored
            return;
        };

        // Step 6: Set query object's list to result of parsing input
        self.query_impl.list.clearRetainingCapacity();
        const tuples = try form_parser.parse(self.allocator, input);
        for (tuples) |tuple| {
            try self.query_impl.list.append(tuple);
        }
        self.allocator.free(tuples);
    
    }

    /// hash setter
    /// Spec: https://url.spec.whatwg.org/#dom-url-hash (lines 1975-1983)
    /// Handle empty, remove leading "#", parse with fragment state
    pub fn set_hash(self: *URL, value: []const u8) !void {

        const basic_parser = @import("basic_parser");
        const ParserState = @import("parser_state").ParserState;

        // Step 1: If empty, set fragment to null
        if (value.len == 0) {
            self.url_record.fragment_len = 0;
            return;
        }

        // Step 2: Remove leading "#" if any
        const input = if (std.mem.startsWith(u8, value, "#"))
            value[1..]
        else
            value;

        // Step 3-4: Set fragment to empty, parse with fragment state override
        _ = basic_parser.parseWithStateOverride(
            self.allocator,
            input,
            null,
            ParserState.fragment,
            &self.url_record,
        ) catch {
            // Parsing failure is silently ignored
            return;
        };
    
    }

    /// toJSON() method
    /// Spec: https://url.spec.whatwg.org/#dom-url-tojson (line 1855)
    /// Returns the result of running the href getter on this
    pub fn call_toJSON(self: *const URL) ![]const u8 {

        return self.get_href();
    
    }

};


