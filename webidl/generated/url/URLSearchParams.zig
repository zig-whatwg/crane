// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const URLSearchParamsImpl = @import("url_search_params_impl").URLSearchParamsImpl;
const std = @import("std");
const webidl = @import("webidl");


pub const URLSearchParams = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    impl: URLSearchParamsImpl,

    // ========================================================================
    // Constants
    // ========================================================================

    pub const Entry = struct {
        name: []const u8,
        value: []const u8,
    };
    pub const EntriesIterator = struct {
        params: *const URLSearchParams,
        index: usize,

        pub fn next(self: *EntriesIterator) ?Entry {
            if (self.index >= self.params.impl.list.items.len) return null;
            const tuple = self.params.impl.list.items[self.index];
            self.index += 1;
            return Entry{
                .name = tuple.name,
                .value = tuple.value,
            };
        }
    };
    pub const KeysIterator = struct {
        params: *const URLSearchParams,
        index: usize,

        pub fn next(self: *KeysIterator) ?[]const u8 {
            if (self.index >= self.params.impl.list.items.len) return null;
            const tuple = self.params.impl.list.items[self.index];
            self.index += 1;
            return tuple.name;
        }
    };
    pub const ValuesIterator = struct {
        params: *const URLSearchParams,
        index: usize,

        pub fn next(self: *ValuesIterator) ?[]const u8 {
            if (self.index >= self.params.impl.list.items.len) return null;
            const tuple = self.params.impl.list.items[self.index];
            self.index += 1;
            return tuple.value;
        }
    };
    pub const ForEachCallback = *const fn (value: []const u8, name: []const u8, params: *const URLSearchParams) void;

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !URLSearchParams {

        return .{
            .impl = URLSearchParamsImpl.init(allocator),
        };
    
    }

    pub fn initWithString(allocator: std.mem.Allocator, query: []const u8) !URLSearchParams {

        return .{
            .impl = try URLSearchParamsImpl.initFromString(allocator, query),
        };
    
    }

    pub fn initWithSequence(allocator: std.mem.Allocator, sequence: []const [2][]const u8) !URLSearchParams {

        return .{
            .impl = try URLSearchParamsImpl.initFromSequence(allocator, sequence),
        };
    
    }

    pub fn initWithRecord(allocator: std.mem.Allocator, record: []const URLSearchParamsImpl.RecordEntry) !URLSearchParams {

        return .{
            .impl = try URLSearchParamsImpl.initFromRecord(allocator, record),
        };
    
    }

    pub fn deinit(self: *URLSearchParams) void {

        self.impl.deinit();
    
    }

    pub fn updateSteps(self: *URLSearchParams) !void {

        try self.impl.update();
    
    }

    pub fn size(self: *const URLSearchParams) usize {

        return self.impl.list.items.len;
    
    }

    pub fn append(self: *URLSearchParams, name: []const u8, value: []const u8) !void {

        try self.impl.append(name, value);
    
    }

    pub fn delete(self: *URLSearchParams, name: []const u8, value: ?[]const u8) !void {

        try self.impl.delete(name, value);
    
    }

    pub fn get(self: *const URLSearchParams, name: []const u8) ?[]const u8 {

        return self.impl.get(name);
    
    }

    pub fn getAll(self: *const URLSearchParams, allocator: std.mem.Allocator, name: []const u8) ![][]const u8 {

        return self.impl.getAll(allocator, name);
    
    }

    pub fn has(self: *const URLSearchParams, name: []const u8, value: ?[]const u8) bool {

        return self.impl.has(name, value);
    
    }

    pub fn set(self: *URLSearchParams, name: []const u8, value: []const u8) !void {

        try self.impl.set(name, value);
    
    }

    pub fn sort(self: *URLSearchParams) !void {

        try self.impl.sort();
    
    }

    pub fn toString(self: *const URLSearchParams, allocator: std.mem.Allocator) ![]u8 {

        return self.impl.toString(allocator);
    
    }

    pub fn entries(self: *const URLSearchParams) EntriesIterator {

        return .{ .params = self, .index = 0 };
    
    }

    pub fn keys(self: *const URLSearchParams) KeysIterator {

        return .{ .params = self, .index = 0 };
    
    }

    pub fn values(self: *const URLSearchParams) ValuesIterator {

        return .{ .params = self, .index = 0 };
    
    }

    pub fn iterator(self: *const URLSearchParams) EntriesIterator {

        return self.entries();
    
    }

    pub fn forEach(self: *const URLSearchParams, callback: ForEachCallback) void {

        for (self.impl.list.items) |tuple| {
            callback(tuple.value, tuple.name, self);
        }
    
    }

};


