// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! WebIDL URLSearchParams Interface (WebIDL Source)
//!
//! WHATWG URL Standard: https://url.spec.whatwg.org/#interface-urlsearchparams
//! WebIDL: specs/url.idl lines 28-45
//!
//! This file will be processed by webidl-codegen to generate src/url_search_params.zig

const std = @import("std");

const webidl = @import("webidl");
const infra = @import("infra");

// Internal imports (using named modules)
const url_search_params_impl = @import("url_search_params_impl");
const URLSearchParamsImpl = url_search_params_impl.URLSearchParamsImpl;
const RecordEntry = url_search_params_impl.RecordEntry;
const form_serializer = @import("form_serializer");

/// Entry for URLSearchParams iterator
///
/// **WebIDL Compliance**: Uses webidl.USVString for string fields
///
/// IDL: iterable<USVString, USVString>
pub const URLSearchParamsEntry = struct {
    name: webidl.USVString, // []const u16 (UTF-16)
    value: webidl.USVString, // []const u16 (UTF-16)
};

/// Iterator for URLSearchParams
pub const URLSearchParamsIterator = struct {
    params: *const URLSearchParams,
    index: usize,

    pub fn next(self: *URLSearchParamsIterator) ?URLSearchParamsEntry {
        if (self.index >= self.params.internal.list.items.len) return null;
        const tuple = self.params.internal.list.items[self.index];
        self.index += 1;
        return URLSearchParamsEntry{ .name = tuple.name, .value = tuple.value };
    }
};

/// Union type for URLSearchParams constructor init parameter
///
/// **WebIDL Compliance**: Uses webidl.USVString for all string fields
///
/// IDL:
/// ```
/// constructor(optional (sequence<sequence<USVString>> or
///                       record<USVString, USVString> or
///                       USVString) init = "");
/// ```
pub const URLSearchParamsInit = union(enum) {
    /// Empty initialization (default)
    empty: void,
    /// String initialization (query string) - USVString
    string: webidl.USVString, // []const u16 (UTF-16)
    /// Sequence of [name, value] pairs - sequence<sequence<USVString>>
    sequence: []const [2]webidl.USVString, // Array of [USVString, USVString]
    /// Record (dictionary) of name -> value pairs - record<USVString, USVString>
    record: []const struct {
        name: webidl.USVString, // []const u16 (UTF-16)
        value: webidl.USVString, // []const u16 (UTF-16)
    },
};
/// URLSearchParams class per WebIDL spec (specs/url.idl lines 28-45)
/// 
/// interface URLSearchParams {
/// constructor(optional (sequence<sequence<USVString>> or record<USVString, USVString> or USVString) init = "");
/// readonly attribute unsigned long size;
/// undefined append(USVString name, USVString value);
/// undefined delete(USVString name, optional USVString value);
/// USVString? get(USVString name);
/// sequence<USVString> getAll(USVString name);
/// boolean has(USVString name, optional USVString value);
/// undefined set(USVString name, USVString value);
/// undefined sort();
/// iterable<USVString, USVString>;
/// stringifier;
/// };
pub const URLSearchParams = struct {
    internal: URLSearchParamsImpl,

    /// Unified constructor (spec lines 2067-2071)
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// constructor(optional (sequence<sequence<USVString>> or
    /// record<USVString, USVString> or
    /// USVString) init = "");
    /// ```
    pub fn init(allocator: std.mem.Allocator, init_param: URLSearchParamsInit) !URLSearchParams {
        const internal = switch (init_param) {
            .empty => URLSearchParamsImpl.init(allocator),

            .string => |usv_string| blk: {
                // Convert UTF-16 → UTF-8 for internal parsing
                const utf8_string = try infra.string.utf16ToUtf8(allocator, usv_string);
                defer allocator.free(utf8_string);
                break :blk try URLSearchParamsImpl.initFromString(allocator, utf8_string);
            },

            .sequence => |usv_seq| blk: {
                // Convert each [name, value] pair from UTF-16 → UTF-8
                var utf8_seq = try allocator.alloc([2][]const u8, usv_seq.len);
                defer {
                    for (utf8_seq) |pair| {
                        allocator.free(pair[0]);
                        allocator.free(pair[1]);
                    }
                    allocator.free(utf8_seq);
                }

                for (usv_seq, 0..) |pair, i| {
                    utf8_seq[i][0] = try infra.string.utf16ToUtf8(allocator, pair[0]);
                    utf8_seq[i][1] = try infra.string.utf16ToUtf8(allocator, pair[1]);
                }

                break :blk try URLSearchParamsImpl.initFromSequence(allocator, utf8_seq);
            },

            .record => |usv_rec| blk: {
                // Convert record entries from UTF-16 → UTF-8
                var utf8_rec = try allocator.alloc(RecordEntry, usv_rec.len);
                defer {
                    for (utf8_rec) |entry| {
                        allocator.free(entry.name);
                        allocator.free(entry.value);
                    }
                    allocator.free(utf8_rec);
                }

                for (usv_rec, 0..) |entry, i| {
                    utf8_rec[i].name = try infra.string.utf16ToUtf8(allocator, entry.name);
                    utf8_rec[i].value = try infra.string.utf16ToUtf8(allocator, entry.value);
                }

                break :blk try URLSearchParamsImpl.initFromRecord(allocator, utf8_rec);
            },
        };

        return .{ .internal = internal };
    }
    pub fn deinit(self: *URLSearchParams) void {
        self.internal.deinit();
    }
    /// Initialize from string (convenience wrapper for internal use, accepts UTF-8)
    pub fn initFromString(allocator: std.mem.Allocator, query: []const u8) !URLSearchParams {
        const query_utf16 = try infra.string.utf8ToUtf16(allocator, query);
        defer allocator.free(query_utf16);
        return init(allocator, .{ .string = query_utf16 });
    }
    /// Initialize from sequence (convenience wrapper)
    pub fn initFromSequence(allocator: std.mem.Allocator, seq: []const [2][]const u8) !URLSearchParams {
        return init(allocator, .{ .sequence = seq });
    }
    /// Initialize from record (convenience wrapper)
    pub fn initFromRecord(allocator: std.mem.Allocator, record: []const RecordEntry) !URLSearchParams {
        return init(allocator, .{ .record = record });
    }
    /// Link this URLSearchParams to a URL object
    pub fn linkToURL(self: *URLSearchParams, url: anytype) void {
        self.internal.url_object = @ptrCast(url);
    }
    /// Update from a new query string
    pub fn updateFromString(self: *URLSearchParams, query_str: []const u8) !void {
        // Clear existing list
        for (self.internal.list.items) |tuple| {
            tuple.deinit(self.internal.allocator);
        }
        self.internal.list.clearRetainingCapacity();

        // Parse new query string
        const tuples = try @import("form_parser").parse(self.internal.allocator, query_str);
        defer self.internal.allocator.free(tuples);

        for (tuples) |tuple| {
            try self.internal.list.append(self.internal.allocator, tuple);
        }
    }
    /// readonly attribute unsigned long size
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// readonly attribute unsigned long size;
    /// ```
    pub fn get_size(self: *const URLSearchParams) webidl.@"unsigned long" {
        return @intCast(self.internal.size());
    }
    /// undefined append(USVString name, USVString value)
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// undefined append(USVString name, USVString value);
    /// ```
    pub fn call_append(self: *URLSearchParams, name: webidl.USVString, value: webidl.USVString) !void {
        // Convert UTF-16 → UTF-8
        const name_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, name);
        defer self.internal.allocator.free(name_utf8);

        const value_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, value);
        defer self.internal.allocator.free(value_utf8);

        // Call internal implementation (UTF-8)
        try self.internal.append(name_utf8, value_utf8);
    }
    /// undefined delete(USVString name, optional USVString value)
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// undefined delete(USVString name, optional USVString value);
    /// ```
    pub fn call_delete(self: *URLSearchParams, name: webidl.USVString, opt_value: ?webidl.USVString) !void {
        const name_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, name);
        defer self.internal.allocator.free(name_utf8);

        var value_utf8: ?[]const u8 = null;
        defer if (value_utf8) |v| self.internal.allocator.free(v);

        if (opt_value) |val| {
            value_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, val);
        }

        try self.internal.delete(name_utf8, value_utf8);
    }
    /// USVString? get(USVString name)
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// USVString? get(USVString name);
    /// ```
    pub fn call_get(self: *const URLSearchParams, name: webidl.USVString) !?webidl.USVString {
        // Convert input: UTF-16 → UTF-8
        const name_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, name);
        defer self.internal.allocator.free(name_utf8);

        // Call internal implementation
        const result_utf8 = self.internal.get(name_utf8) orelse return null;

        // Convert output: UTF-8 → UTF-16
        return try infra.string.utf8ToUtf16(self.internal.allocator, result_utf8);
    }
    /// sequence<USVString> getAll(USVString name)
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// sequence<USVString> getAll(USVString name);
    /// ```
    pub fn call_getAll(self: *const URLSearchParams, name: webidl.USVString) !webidl.Sequence(webidl.USVString) {
        // Convert input: UTF-16 → UTF-8
        const name_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, name);
        defer self.internal.allocator.free(name_utf8);

        // Call internal implementation
        const results_utf8 = try self.internal.getAll(name_utf8);
        defer self.internal.allocator.free(results_utf8);

        // Convert output: Each UTF-8 string → UTF-16
        var results_utf16 = try self.internal.allocator.alloc(webidl.USVString, results_utf8.len);
        errdefer self.internal.allocator.free(results_utf16);

        for (results_utf8, 0..) |result_utf8, i| {
            results_utf16[i] = try infra.string.utf8ToUtf16(self.internal.allocator, result_utf8);
        }

        return results_utf16;
    }
    /// boolean has(USVString name, optional USVString value)
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// boolean has(USVString name, optional USVString value);
    /// ```
    pub fn call_has(self: *const URLSearchParams, name: webidl.USVString, opt_value: ?webidl.USVString) !webidl.boolean {
        const name_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, name);
        defer self.internal.allocator.free(name_utf8);

        var value_utf8: ?[]const u8 = null;
        defer if (value_utf8) |v| self.internal.allocator.free(v);

        if (opt_value) |val| {
            value_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, val);
        }

        return self.internal.has(name_utf8, value_utf8);
    }
    /// undefined set(USVString name, USVString value)
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// undefined set(USVString name, USVString value);
    /// ```
    pub fn call_set(self: *URLSearchParams, name: webidl.USVString, value: webidl.USVString) !void {
        const name_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, name);
        defer self.internal.allocator.free(name_utf8);

        const value_utf8 = try infra.string.utf16ToUtf8(self.internal.allocator, value);
        defer self.internal.allocator.free(value_utf8);

        try self.internal.set(name_utf8, value_utf8);
    }
    /// undefined sort()
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// undefined sort();
    /// ```
    pub fn call_sort(self: *URLSearchParams) void {
        self.internal.sort();
    }
    /// stringifier
    /// 
    /// **WebIDL Compliance**: Public interface matching IDL specification
    /// 
    /// IDL:
    /// ```
    /// stringifier;
    /// ```
    pub fn call_toString(self: *const URLSearchParams) !webidl.USVString {
        const utf8_result = try form_serializer.serialize(self.internal.allocator, self.internal.list.items);
        defer self.internal.allocator.free(utf8_result);

        return try infra.string.utf8ToUtf16(self.internal.allocator, utf8_result);
    }
    /// Iterator support (for iterable<USVString, USVString>)
    pub fn call_iterator(self: *const URLSearchParams) URLSearchParamsIterator {
        return .{ .params = self, .index = 0 };
    }
};

