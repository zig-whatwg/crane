// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = @import("std.mem").Allocator;
const GenericTransformStream = @import("../streams/GenericTransformStream.zig").GenericTransformStream;
const Text = @import("text").Text;
const TextEncoderCommon = @import("TextEncoderCommon.zig").TextEncoderCommon;
const TransformStream = @import("transform_stream").TransformStream;
const TransformStreamDefaultController = @import("transform_stream_default_controller").TransformStreamDefaultController;
const infra = @import("infra").infra;
const std = @import("std");
const webidl = @import("webidl");


/// TextEncoderStream - encodes a stream of strings to a stream of UTF-8 bytes
///
/// WHATWG Encoding Standard ยง 5.3
/// https://encoding.spec.whatwg.org/#interface-textencoderstream
///
/// IDL:
/// ```
/// [Exposed=*]
/// interface TextEncoderStream {
///   constructor();
/// };
/// TextEncoderStream includes TextEncoderCommon;
/// TextEncoderStream includes GenericTransformStream;
/// ```

pub const TextEncoderStream = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    allocator: std.mem.Allocator,
    encoding: []const u8,
    transform: *TransformStream,
    leadingSurrogate: ?u16,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) !TextEncoderStream {

        // Allocate stream on heap for context pointer
        const stream_ptr = try allocator.create(TextEncoderStream);
        errdefer allocator.destroy(stream_ptr);

        // Initialize with temporary values
        stream_ptr.* = .{
            .allocator = allocator,
            .encoding = "utf-8",
            .transform = undefined, // Will be set below
            .leadingSurrogate = null,
        };

        // Step 2-3: Create transform algorithms
        const Transformer = struct {
            pub fn transform(
                controller: *TransformStreamDefaultController,
                chunk: webidl.JSValue,
                ctx: *anyopaque,
            ) !void {
                const self: *TextEncoderStream = @ptrCast(@alignCast(ctx));
                try self.encodeAndEnqueue(controller, chunk);
            }

            pub fn flush(
                controller: *TransformStreamDefaultController,
                ctx: *anyopaque,
            ) !void {
                const self: *TextEncoderStream = @ptrCast(@alignCast(ctx));
                try self.flushAndEnqueue(controller);
            }
        };

        // Step 4-5: Create TransformStream
        const transform = try allocator.create(TransformStream);
        errdefer allocator.destroy(transform);

        transform.* = try TransformStream.initWithCallbacks(
            allocator,
            Transformer.transform,
            Transformer.flush,
            stream_ptr,
        );

        // Step 6: Set transform
        stream_ptr.transform = transform;

        return stream_ptr.*;
    
    }

    pub fn deinit(self: *TextEncoderStream) void {

        self.transform.deinit();
        self.allocator.destroy(self.transform);
    
    }

    pub fn get_encoding(self: *const TextEncoderStream) []const u8 {

        return self.encoding;
    
    }

    pub fn get_readable(self: *const TextEncoderStream) *@import("readable_stream").ReadableStream {

        return self.transform.readableStream;
    
    }

    pub fn get_writable(self: *const TextEncoderStream) *@import("writable_stream").WritableStream {

        return self.transform.writableStream;
    
    }

};


