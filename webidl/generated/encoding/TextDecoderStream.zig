// Auto-generated by webidl-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

//! TextDecoderStream WebIDL Interface
//!
//! WHATWG Encoding Standard § 6.3
//! https://encoding.spec.whatwg.org/#interface-textdecoderstream
//!
//! TextDecoderStream decodes a stream of bytes into a stream of strings using character encodings.

const std = @import("std");
const webidl = @import("webidl");

// Import mixins

// Import dictionaries
pub const TextDecoderOptions = @import("TextDecoderOptions.zig").TextDecoderOptions;

// Import streams
pub const streams = @import("streams");
const TransformStream = streams.TransformStream;
const ReadableStream = streams.ReadableStream;
const WritableStream = streams.WritableStream;

// Import encoding infrastructure
pub const encoding_mod = @import("encoding");
const Encoding = encoding_mod.Encoding;
const Decoder = encoding_mod.Decoder;
/// TextDecoderStream - decodes a stream of bytes to a stream of strings
/// 
/// WHATWG Encoding Standard § 6.3
/// https://encoding.spec.whatwg.org/#interface-textdecoderstream
/// 
/// IDL:
/// ```
/// [Exposed=*]
/// interface TextDecoderStream {
/// constructor(optional DOMString label = "utf-8", optional TextDecoderOptions options = {});
/// };
/// TextDecoderStream includes TextDecoderCommon;
/// TextDecoderStream includes GenericTransformStream;
/// ```
const TextDecoderCommon = @import("text_decoder_common").TextDecoderCommon;
const GenericTransformStream = @import("generic_transform_stream").GenericTransformStream;
const Allocator = std.mem.Allocator;
pub const TextDecoderStream = struct {
    // ========================================================================
    // Fields from TextDecoderCommon mixin
    // ========================================================================
    /// The encoding name (WHATWG canonical name, lowercase ASCII)
    /// 
    /// Examples: "utf-8", "windows-1252", "iso-8859-1"
    /// 
    /// This is a readonly attribute - set during construction and never changes.
    encoding: []const u8,
    /// Fatal error mode flag
    /// 
    /// - `true`: Throw TypeError on invalid byte sequences
    /// - `false`: Use U+FFFD replacement character (default)
    /// 
    /// This is a readonly attribute - set during construction and never changes.
    fatal: webidl.boolean,
    /// Byte Order Mark (BOM) handling flag
    /// 
    /// - `true`: Keep BOM in output as U+FEFF (ZERO WIDTH NO-BREAK SPACE)
    /// - `false`: Strip BOM from output (default)
    /// 
    /// This is a readonly attribute - set during construction and never changes.
    ignoreBOM: webidl.boolean,

    // ========================================================================
    // Fields from GenericTransformStream mixin
    // ========================================================================
    /// [[transform]]: The actual TransformStream backing this object
    /// 
    /// Spec: "Any platform object that includes the GenericTransformStream
    /// mixin has an associated transform, which is an actual TransformStream."
    transform: *TransformStream,

    // ========================================================================
    // TextDecoderStream fields
    // ========================================================================
    allocator: std.mem.Allocator,
    /// The encoding used by this stream decoder
    enc: *const Encoding,
    /// Internal decoder instance
    decoder: *Decoder,

    pub const includes = .{

    /// Constructor - creates a new TextDecoderStream
    /// 
    /// WHATWG Encoding Standard § 6.3.1
    /// https://encoding.spec.whatwg.org/#dom-textdecoderstream
    pub fn init(
        allocator: std.mem.Allocator,
        label: []const u8,
        options: TextDecoderOptions,
    ) !TextDecoderStream {
        // Get encoding from label
        const enc = encoding_mod.getEncoding(label) orelse {
            return error.InvalidEncoding;
        };

        // Reject replacement encoding
        if (std.mem.eql(u8, enc.whatwg_name, "replacement")) {
            return error.ReplacementEncoding;
        }

        // Create transform stream
        const transform = try allocator.create(TransformStream);
        errdefer allocator.destroy(transform);

        transform.* = try TransformStream.init(allocator, .{
            .transform = transformAlgorithm,
            .flush = flushAlgorithm,
        });

        // Create decoder instance
        const decoder = try allocator.create(Decoder);
        errdefer allocator.destroy(decoder);
        decoder.* = enc.newDecoder();

        return .{
            .encoding = enc.whatwg_name,
            .fatal = options.fatal,
            .ignoreBOM = options.ignoreBOM,
            .transform = transform,
            .allocator = allocator,
            .enc = enc,
            .decoder = decoder,
        };
    }
    /// Cleanup resources
    pub fn deinit(self: *TextDecoderStream) void {
        self.allocator.destroy(self.decoder);
        self.transform.deinit();
        self.allocator.destroy(self.transform);
    }

    // ========================================================================
    // Methods from GenericTransformStream mixin
    // ========================================================================

    /// readable attribute getter
    /// 
    /// IDL: readonly attribute ReadableStream readable;
    /// 
    /// Spec: § 6.4.3.3 "The readable getter steps are to return
    /// this's transform.[[readable]]."
    /// (Included from GenericTransformStream mixin)
    pub fn get_readable(self: *const TextDecoderStream) *ReadableStream {
        return self.transform.readableStream;
    }
    /// writable attribute getter
    /// 
    /// IDL: readonly attribute WritableStream writable;
    /// 
    /// Spec: § 6.4.3.3 "The writable getter steps are to return
    /// this's transform.[[writable]]."
    /// (Included from GenericTransformStream mixin)
    pub fn get_writable(self: *const TextDecoderStream) *WritableStream {
        return self.transform.writableStream;
    }
    // ========================================================================
    // TextDecoderStream methods
    // ========================================================================

    /// Transform algorithm - decode chunk and enqueue
    /// 
    /// WHATWG Encoding Standard § 6.3.2
    /// "decode and enqueue a chunk"
    fn transformAlgorithm(chunk: []const u8, controller: *TransformStream.Controller) !void {
        // TODO: Implement decode and enqueue algorithm
        // This requires:
        // 1. Run decoder on chunk (streaming mode)
        // 2. Enqueue decoded string to readable side
        // 3. Handle fatal errors
        _ = chunk;
        _ = controller;
    }
    /// Flush algorithm - flush decoder
    /// 
    /// WHATWG Encoding Standard § 6.3.2
    /// "flush and enqueue"
    fn flushAlgorithm(controller: *TransformStream.Controller) !void {
        // TODO: Implement flush and enqueue algorithm
        // This requires:
        // 1. Flush decoder (finalize any pending bytes)
        // 2. Enqueue final decoded string (if any)
        // 3. Handle fatal errors
        _ = controller;
    }

    // WebIDL extended attributes metadata
    pub const __webidl__ = .{
        .name = "TextDecoderStream",
        .kind = .interface,
        .exposed = &.{.global},
        .transferable = false,
        .serializable = false,
        .secure_context = false,
        .cross_origin_isolated = false,
    };
};

