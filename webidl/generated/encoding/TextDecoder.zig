// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const ASCII = @import("a_s_c_i_i").ASCII;
const Accumulates = @import("accumulates").Accumulates;
const Algorithm = @import("algorithm").Algorithm;
const Allocate = @import("allocate").Allocate;
const Allocation = @import("allocation").Allocation;
const Allocator = @import("std.mem").Allocator;
const AllowSharedBufferSource = @import("allow_shared_buffer_source").AllowSharedBufferSource;
const Ascii = @import("ascii").Ascii;
const BOM = @import("b_o_m").BOM;
const Basic = @import("basic").Basic;
const Behavior = @import("behavior").Behavior;
const Buffer = @import("buffer").Buffer;
const By = @import("by").By;
const Byte = @import("byte").Byte;
const C = @import("c").C;
const Caller = @import("caller").Caller;
const Convert = @import("convert").Convert;
const Create = @import("create").Create;
const Decode = @import("decode").Decode;
const Decoded = @import("decoded").Decoded;
const Decoder = @import("decoder").Decoder;
const Decodes = @import("decodes").Decodes;
const DecodingError = @import("decoding_error").DecodingError;
const Direct = @import("direct").Direct;
const Empty = @import("empty").Empty;
const Encoding = @import("encoding").Encoding;
const Errors = @import("errors").Errors;
const Examples = @import("examples").Examples;
const F = @import("f").F;
const FAST = @import("f_a_s_t").FAST;
const FE = @import("f_e").FE;
const FEFF = @import("f_e_f_f").FEFF;
const FF = @import("f_f").FF;
const FFFD = @import("f_f_f_d").FFFD;
const Fatal = @import("fatal").Fatal;
const Final = @import("final").Final;
const Flush = @import("flush").Flush;
const Flushes = @import("flushes").Flushes;
const For = @import("for").For;
const Free = @import("free").Free;
const GENERAL = @import("g_e_n_e_r_a_l").GENERAL;
const Get = @import("get").Get;
const Handle = @import("handle").Handle;
const Handling = @import("handling").Handling;
const Hello = @import("hello").Hello;
const I = @import("i").I;
const IDL = @import("i_d_l").IDL;
const If = @import("if").If;
const Implementation = @import("implementation").Implementation;
const Internal = @import("internal").Internal;
const Invalid = @import("invalid").Invalid;
const InvalidEncoding = @import("invalid_encoding").InvalidEncoding;
const JavaScript = @import("java_script").JavaScript;
const Keeps = @import("keeps").Keeps;
const Let = @import("let").Let;
const Mode = @import("mode").Mode;
const Non = @import("non").Non;
const NotFlush = @import("not_flush").NotFlush;
const Note = @import("note").Note;
const Notes = @import("notes").Notes;
const O = @import("o").O;
const OrAllocUtf16Buffer = @import("or_alloc_utf16_buffer").OrAllocUtf16Buffer;
const OutOfMemory = @import("out_of_memory").OutOfMemory;
const PATH = @import("p_a_t_h").PATH;
const Parameters = @import("parameters").Parameters;
const Performance = @import("performance").Performance;
const Preserves = @import("preserves").Preserves;
const Process = @import("process").Process;
const Processes = @import("processes").Processes;
const RangeError = @import("range_error").RangeError;
const Replacement = @import("replacement").Replacement;
const ReplacementEncoding = @import("replacement_encoding").ReplacementEncoding;
const Resets = @import("resets").Resets;
const Return = @import("return").Return;
const Returns = @import("returns").Returns;
const Seen = @import("seen").Seen;
const Set = @import("set").Set;
const Spec = @import("spec").Spec;
const Standard = @import("standard").Standard;
const Step = @import("step").Step;
const Store = @import("store").Store;
const Streaming = @import("streaming").Streaming;
const Strips = @import("strips").Strips;
const Substitutes = @import("substitutes").Substitutes;
const TextDecodeOptions = @import("TextDecodeOptions.zig").TextDecodeOptions;
const TextDecoderCommon = @import("TextDecoderCommon.zig").TextDecoderCommon;
const TextDecoderError = @import("text_decoder_error").TextDecoderError;
const TextDecoderOptions = @import("TextDecoderOptions.zig").TextDecoderOptions;
const The = @import("the").The;
const This = @import("this").This;
const Throws = @import("throws").Throws;
const ToUtf8 = @import("to_utf8").ToUtf8;
const TypeError = @import("type_error").TypeError;
const U = @import("u").U;
const USVString = @import("u_s_v_string").USVString;
const UTF = @import("u_t_f").UTF;
const Use = @import("use").Use;
const Utf16Buffer = @import("utf16_buffer").Utf16Buffer;
const Utf16Length = @import("utf16_length").Utf16Length;
const Utf8 = @import("utf8").Utf8;
const Utf8Buffer = @import("utf8_buffer").Utf8Buffer;
const Validation = @import("validation").Validation;
const WHATWG = @import("w_h_a_t_w_g").WHATWG;
const WebIDL = @import("web_i_d_l").WebIDL;
const With = @import("with").With;
const Zig = @import("zig").Zig;
const ]const u8 = @import("]const u8").]const u8;
const encoding_mod = @import("encoding");
const infra = @import("infra").infra;
const std = @import("std");
const webidl = @import("webidl");
const webidl.boolean = @import("webidl.boolean").webidl.boolean;


const Encoding = encoding_mod.Encoding;
const Decoder = encoding_mod.Decoder;
// ============================================================================
// Helper Functions (Module-Level)
// ============================================================================
/// Check if byte slice is ASCII-only (fast path optimization)
fn isAscii(bytes: []const u8) bool {
for (bytes) |byte| {
if (byte > 0x7F) return false;
}
return true;
}
/// TextDecoder errors map to WebIDL simple exceptions per WHATWG Encoding Standard
///
/// Error Mapping (for JavaScript bindings):
/// - error.InvalidEncoding → RangeError (invalid encoding label)
/// - error.ReplacementEncoding → RangeError (replacement encoding not allowed)
/// - error.DecodingError → TypeError (fatal mode encountered invalid sequence)
pub const TextDecoderError = error{
/// Invalid encoding label → WebIDL RangeError
InvalidEncoding,
/// Replacement encoding not supported → WebIDL RangeError
ReplacementEncoding,
/// Fatal decoding error → WebIDL TypeError
DecodingError,
/// Out of memory
OutOfMemory,
};
/// TextDecoder - decodes bytes to strings using various character encodings
///
/// WHATWG Encoding Standard § 5
/// https://encoding.spec.whatwg.org/#interface-textdecoder
///
/// IDL:
/// ```
/// [Exposed=*]
/// interface TextDecoder {
///   constructor(optional DOMString label = "utf-8", optional TextDecoderOptions options = {});
///   USVString decode(optional AllowSharedBufferSource input, optional TextDecodeOptions options = {});
/// };
/// TextDecoder includes TextDecoderCommon;
///
/// interface mixin TextDecoderCommon {
///   readonly attribute DOMString encoding;
///   readonly attribute boolean fatal;
///   readonly attribute boolean ignoreBOM;
/// };
/// ```

pub const TextDecoder = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    encoding: []const u8,
    fatal: webidl.boolean,
    ignoreBOM: webidl.boolean,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(
        allocator: std.mem.Allocator,
        label: []const u8,
        options: TextDecoderOptions,
    ) TextDecoderError!TextDecoder {

        // Step 1: Get encoding from label (§4.2 get an encoding)
        // https://encoding.spec.whatwg.org/#concept-encoding-get
        const enc = encoding_mod.getEncoding(label) orelse {
            // Step 2: If encoding is failure, throw RangeError
            return error.InvalidEncoding;
        };

        // Step 2: If encoding is replacement, throw RangeError
        if (std.mem.eql(u8, enc.whatwg_name, "replacement")) {
            return error.ReplacementEncoding;
        }

        // Store encoding name (no allocation - just reference the static string)
        const encoding_name = enc.whatwg_name;

        // Step 3-5: Set properties
        return .{
            .encoding = encoding_name,
            .fatal = options.fatal,
            .ignoreBOM = options.ignoreBOM,
            .allocator = allocator,
            .enc = enc,
            .doNotFlush = false,
            .bomSeen = false,
            .reusableUtf16Buffer = null,
            .reusableUtf8Buffer = null,
        };
    
    }

    pub fn deinit(self: *TextDecoder) void {

        // Free reusable buffers
        if (self.reusableUtf16Buffer) |buf| {
            self.allocator.free(buf);
        }
        if (self.reusableUtf8Buffer) |buf| {
            self.allocator.free(buf);
        }
    
    }

    pub inline fn get_encoding(self: *const TextDecoder) []const u8 {
        return self.encoding;
    }

    /// Get the fatal flag
    ///
    /// WHATWG Encoding Standard § 5.1.1
    /// TextDecoderCommon.fatal getter
    ///
    /// IDL:
    /// ```
    /// readonly attribute boolean fatal;
    /// ```
    pub inline fn get_fatal(self: *const TextDecoder) webidl.boolean {
        return self.fatal;
    }

    /// Get the ignoreBOM flag
    ///
    /// WHATWG Encoding Standard § 5.1.1
    /// TextDecoderCommon.ignoreBOM getter
    ///
    /// IDL:
    /// ```
    /// readonly attribute boolean ignoreBOM;
    /// ```
    pub inline fn get_ignoreBOM(self: *const TextDecoder) webidl.boolean {
        return self.ignoreBOM;
    }

    /// decode() - Decodes bytes to a string
    ///
    /// WHATWG Encoding Standard § 5.1.4
    /// https://encoding.spec.whatwg.org/#dom-textdecoder-decode
    ///
    /// Decodes a byte sequence using the configured encoding and returns a UTF-8 string.
    ///
    /// ## Parameters
    ///
    /// - `input`: Byte sequence to decode
    ///   - Empty slice is valid (useful for flushing in streaming mode)
    ///   - For JavaScript bindings: extract bytes from AllowSharedBufferSource
    /// - `options`: Decode options (see `TextDecodeOptions`)
    ///   - `stream`: If true, additional data expected; if false, flush decoder (default: false)
    ///
    /// ## Returns
    ///
    /// Decoded string as UTF-8 bytes. **Caller owns the returned memory** and must free it.
    ///
    /// ## Errors
    ///
    /// - `error.DecodingError`: Fatal mode encountered invalid byte sequence (maps to WebIDL TypeError)
    /// - `error.OutOfMemory`: Allocation failed
    ///
    /// ## Behavior
    ///
    /// ### Non-Streaming Mode (stream: false, default)
    /// - Resets decoder state before processing
    /// - Processes complete input
    /// - Flushes any pending data
    ///
    /// ### Streaming Mode (stream: true)
    /// - Preserves decoder state between calls
    /// - Accumulates partial multi-byte sequences
    /// - Final call with stream:false flushes remaining data
    ///
    /// ### BOM Handling
    /// - By default (ignoreBOM: false): Strips BOM on first decode
    /// - With ignoreBOM: true: Keeps BOM in output as U+FEFF
    /// - BOM only stripped once per decoder instance
    ///
    /// ### Error Handling
    /// - **Fatal mode** (fatal: true): Throws `error.DecodingError` on invalid sequences
    /// - **Replacement mode** (fatal: false, default): Substitutes U+FFFD for invalid sequences
    ///
    /// ## Examples
    ///
    /// ### Basic Decode
    /// ```zig
    /// var decoder = try TextDecoder.init(allocator, "utf-8", .{});
    /// defer decoder.deinit();
    ///
    /// const bytes = [_]u8{ 0x48, 0x65, 0x6C, 0x6C, 0x6F }; // "Hello"
    /// const text = try decoder.decode(&bytes, .{});
    /// defer allocator.free(text);
    /// // text is "Hello"
    /// ```
    ///
    /// ### Streaming Decode
    /// ```zig
    /// // Process fragmented input
    /// const chunk1 = try decoder.decode(bytes1, .{ .stream = true });
    /// defer allocator.free(chunk1);
    ///
    /// const chunk2 = try decoder.decode(bytes2, .{ .stream = true });
    /// defer allocator.free(chunk2);
    ///
    /// // Flush remaining data
    /// const final = try decoder.decode(&[_]u8{}, .{ .stream = false });
    /// defer allocator.free(final);
    /// ```
    ///
    /// ### Fatal Mode
    /// ```zig
    /// var decoder = try TextDecoder.init(allocator, "utf-8", .{ .fatal = true });
    /// defer decoder.deinit();
    ///
    /// const invalid = [_]u8{ 0xFF, 0xFE }; // Invalid UTF-8
    /// const result = decoder.decode(&invalid, .{});
    /// // Returns error.DecodingError
    /// ```
    ///
    /// ## Performance
    ///
    /// - **ASCII fast path**: Direct passthrough for ASCII-only input (~10x faster)
    /// - **UTF-8 fast path**: Validation-only for UTF-8 encoding (~5x faster)
    /// - **Buffer reuse**: Internal buffers reused for reduced allocations
    ///
    /// ## Spec Algorithm
    ///
    /// The decode(input, options) method steps are:
    /// 1. If this's do not flush is false, reset decoder state
    /// 2. Set this's do not flush to options["stream"]
    /// 3. If input is given, push a copy to I/O queue
    /// 4. Let output be the I/O queue of scalar values
    /// 5. Process the queue with encoding's decoder
    /// 6. Return serialized output
    ///
    /// ## Implementation Notes
    ///
    /// This implementation uses UTF-8 strings for I/O (Zig native format).
    /// For JavaScript bindings:
    /// - Convert AllowSharedBufferSource → []const u8 before calling
    /// - Convert returned []const u8 → USVString (UTF-16) after calling
    pub fn call_decode(
        self: *TextDecoder,
        input: []const u8,
        options: TextDecodeOptions,
    ) TextDecoderError![]const u8 {

        // Step 1: If do not flush is false, reset decoder state
        if (!self.doNotFlush) {
            self.bomSeen = false;
            // Note: Decoder is recreated for each call, so no explicit reset needed
        }

        // Step 2: Set do not flush to options["stream"]
        self.doNotFlush = options.stream;

        // Handle empty input (common case for final flush)
        if (input.len == 0) {
            // Return empty string (no work to do)
            return &[_]u8{};
        }

        // Step 3-6: Process input bytes
        var bytes = input;

        // ASCII FAST PATH: For ASCII-only input, return as-is (ASCII is valid UTF-8)
        if (isAscii(bytes)) {
            // Allocate and copy (caller owns the result)
            return self.allocator.dupe(u8, bytes);
        }

        // Step 4: Handle BOM (if not ignoreBOM and not seen yet)
        if (!self.ignoreBOM and !self.bomSeen) {
            bytes = self.stripBOM(bytes);
        }

        // UTF-8 FAST PATH: For UTF-8 encoding, validate and return
        if (std.mem.eql(u8, self.enc.whatwg_name, "utf-8")) {
            return try self.decodeUtf8(bytes);
        }

        // GENERAL PATH: Use encoding infrastructure to decode
        // Step 5: Create decoder instance and decode
        var decoder = self.enc.newDecoder();

        // Allocate UTF-16 output buffer
        const max_utf16_len = self.enc.maxUtf16Length(bytes.len);
        const utf16_buf = try self.getOrAllocUtf16Buffer(max_utf16_len);

        // Decode bytes → UTF-16
        const result = decoder.decode(bytes, utf16_buf, !self.doNotFlush);

        // Handle decoding errors in fatal mode
        if (self.fatal and result.had_errors) {
            return error.DecodingError;
        }

        // Convert UTF-16 → UTF-8 for output
        const utf16_output = utf16_buf[0..result.output_written];
        const utf8_output = try infra.string.utf16ToUtf8(self.allocator, utf16_output);

        return utf8_output;
    
    }

};


