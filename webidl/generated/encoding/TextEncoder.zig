// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const Allocator = std.mem.Allocator;
const TextEncoderCommon = @import("TextEncoderCommon.zig").TextEncoderCommon;
const TextEncoderEncodeIntoResult = @import("TextEncoderEncodeIntoResult.zig").TextEncoderEncodeIntoResult;
const infra = @import("infra");
const std = @import("std");
const webidl = @import("webidl");


// ============================================================================
// Helper Functions (Module-Level)
// ============================================================================

/// Check if byte slice is ASCII-only (fast path optimization)
fn isAscii(bytes: []const u8) bool {
    for (bytes) |byte| {
        if (byte > 0x7F) return false;
    }
    return true;
}

/// Replace invalid UTF-8 sequences with U+FFFD REPLACEMENT CHARACTER
fn replaceInvalidUtf8(allocator: std.mem.Allocator, input: []const u8) ![]const u8 {
    // Allocate output buffer (worst case: 3 bytes per input byte for U+FFFD)
    var output = std.ArrayList(u8).init(allocator);
    errdefer output.deinit();

    const replacement = "\u{FFFD}"; // U+FFFD in UTF-8 (3 bytes: EF BF BD)

    var i: usize = 0;
    while (i < input.len) {
        const cp_len = std.unicode.utf8ByteSequenceLength(input[i]) catch {
            // Invalid start byte - replace with U+FFFD
            try output.appendSlice(replacement);
            i += 1;
            continue;
        };

        if (i + cp_len > input.len) {
            // Incomplete code point at end - replace with U+FFFD
            try output.appendSlice(replacement);
            break;
        }

        // Validate code point
        const cp = std.unicode.utf8Decode(input[i .. i + cp_len]) catch {
            // Invalid code point - replace with U+FFFD
            try output.appendSlice(replacement);
            i += cp_len;
            continue;
        };

        // Valid code point - encode back to UTF-8
        var buf: [4]u8 = undefined;
        const out_len = std.unicode.utf8Encode(cp, &buf) catch unreachable;
        try output.appendSlice(buf[0..out_len]);
        i += cp_len;
    }

    return output.toOwnedSlice();
}

/// TextEncoder - encodes strings to UTF-8 bytes
///
/// WHATWG Encoding Standard ยง 5.2
/// https://encoding.spec.whatwg.org/#interface-textencoder
///
/// IDL:
/// ```
/// [Exposed=*]
/// interface TextEncoder {
///   constructor();
///   [NewObject] Uint8Array encode(optional USVString input = "");
///   TextEncoderEncodeIntoResult encodeInto(USVString source, [AllowShared] Uint8Array destination);
/// };
/// TextEncoder includes TextEncoderCommon;
///
/// interface mixin TextEncoderCommon {
///   readonly attribute DOMString encoding;
/// };
/// ```
///
/// Note: TextEncoder only supports UTF-8 encoding (no label argument).
/// Note: TextEncoder offers no stream option (no buffering needed).

pub const TextEncoder = struct {
    // ========================================================================
    // Fields
    // ========================================================================

    encoding: []const u8,
    allocator: std.mem.Allocator,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) TextEncoder {

        return .{
            .encoding = "utf-8",
            .allocator = allocator,
        };
    
    }

    pub fn deinit(self: *TextEncoder) void {

        _ = self;
        // No resources to clean up (stateless)
    
    }

    pub inline fn get_encoding(self: *const TextEncoder) []const u8 {

        return self.encoding;
    
    }

    pub fn call_encode(
        self: *TextEncoder,
        input: []const u8,
    ) ![]const u8 {

        // Handle empty input (common case)
        if (input.len == 0) {
            return &[_]u8{};
        }

        // ASCII FAST PATH: For ASCII-only input, return as-is
        // ASCII is valid UTF-8, no conversion needed
        if (isAscii(input)) {
            return self.allocator.dupe(u8, input);
        }

        // GENERAL PATH: Validate and encode UTF-8
        // Note: If input is already valid UTF-8, we just copy it
        // The spec says to encode scalar values with UTF-8 encoder
        // Since our input is UTF-8, we validate and copy
        if (!std.unicode.utf8ValidateSlice(input)) {
            // Invalid UTF-8 - replace invalid sequences with U+FFFD
            // This shouldn't happen with USVString input, but handle it gracefully
            return try replaceInvalidUtf8(self.allocator, input);
        }

        // Valid UTF-8 - just duplicate
        return self.allocator.dupe(u8, input);
    
    }

    pub fn call_encodeInto(
        self: *TextEncoder,
        source: []const u8,
        destination: []u8,
    ) !TextEncoderEncodeIntoResult {

        _ = self;

        var read: u64 = 0;
        var written: u64 = 0;

        // Process UTF-8 input
        var i: usize = 0;
        while (i < source.len and written < destination.len) {
            // Get UTF-8 code point length
            const cp_len = std.unicode.utf8ByteSequenceLength(source[i]) catch {
                // Invalid UTF-8 - skip byte
                i += 1;
                read += 1;
                continue;
            };

            // Check if we have enough space
            if (written + cp_len > destination.len) {
                // Not enough space for this code point
                break;
            }

            // Check if we have enough input bytes
            if (i + cp_len > source.len) {
                // Incomplete code point at end of input
                break;
            }

            // Copy code point bytes
            @memcpy(destination[written .. written + cp_len], source[i .. i + cp_len]);

            written += cp_len;
            read += cp_len;
            i += cp_len;
        }

        return .{
            .read = read,
            .written = written,
        };
    
    }

};


