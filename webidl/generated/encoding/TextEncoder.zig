// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const ASCII = @import("a_s_c_i_i").ASCII;
const Algorithm = @import("algorithm").Algorithm;
const Allocation = @import("allocation").Allocation;
const Allocator = @import("std.mem").Allocator;
const Always = @import("always").Always;
const Ascii = @import("ascii").Ascii;
const Basic = @import("basic").Basic;
const Behavior = @import("behavior").Behavior;
const ByteSequenceLength = @import("byte_sequence_length").ByteSequenceLength;
const C = @import("c").C;
const Caller = @import("caller").Caller;
const Characters = @import("characters").Characters;
const Check = @import("check").Check;
const Chinese = @import("chinese").Chinese;
const Convert = @import("convert").Convert;
const Copy = @import("copy").Copy;
const DOMString = @import("d_o_m_string").DOMString;
const Empty = @import("empty").Empty;
const Encode = @import("encode").Encode;
const Encodes = @import("encodes").Encodes;
const Encoding = @import("encoding").Encoding;
const Errors = @import("errors").Errors;
const Examples = @import("examples").Examples;
const F = @import("f").F;
const FAST = @import("f_a_s_t").FAST;
const FFFD = @import("f_f_f_d").FFFD;
const Fast = @import("fast").Fast;
const For = @import("for").For;
const GENERAL = @import("g_e_n_e_r_a_l").GENERAL;
const Get = @import("get").Get;
const Handle = @import("handle").Handle;
const Hello = @import("hello").Hello;
const I = @import("i").I;
const IDL = @import("i_d_l").IDL;
const If = @import("if").If;
const Implementation = @import("implementation").Implementation;
const Incomplete = @import("incomplete").Incomplete;
const Into = @import("into").Into;
const Invalid = @import("invalid").Invalid;
const InvalidUtf8 = @import("invalid_utf8").InvalidUtf8;
const JavaScript = @import("java_script").JavaScript;
const Let = @import("let").Let;
const Multibyte = @import("multibyte").Multibyte;
const Newly = @import("newly").Newly;
const No = @import("no").No;
const Not = @import("not").Not;
const Note = @import("note").Note;
const Notes = @import("notes").Notes;
const O = @import("o").O;
const OutOfMemory = @import("out_of_memory").OutOfMemory;
const PATH = @import("p_a_t_h").PATH;
const Parameters = @import("parameters").Parameters;
const Path = @import("path").Path;
const Per = @import("per").Per;
const Performance = @import("performance").Performance;
const Process = @import("process").Process;
const Return = @import("return").Return;
const Returns = @import("returns").Returns;
const Since = @import("since").Since;
const Spec = @import("spec").Spec;
const Standard = @import("standard").Standard;
const TextEncoderCommon = @import("TextEncoderCommon.zig").TextEncoderCommon;
const TextEncoderEncodeIntoResult = @import("TextEncoderEncodeIntoResult.zig").TextEncoderEncodeIntoResult;
const The = @import("the").The;
const This = @import("this").This;
const U = @import("u").U;
const USVString = @import("u_s_v_string").USVString;
const UTF = @import("u_t_f").UTF;
const Uint8Array = @import("uint8_array").Uint8Array;
const Valid = @import("valid").Valid;
const Validate = @import("validate").Validate;
const ValidateSlice = @import("validate_slice").ValidateSlice;
const Validation = @import("validation").Validation;
const WHATWG = @import("w_h_a_t_w_g").WHATWG;
const Wrap = @import("wrap").Wrap;
const Zig = @import("zig").Zig;
const ]const u8 = @import("]const u8").]const u8;
const infra = @import("infra").infra;
const std = @import("std");
const webidl = @import("webidl");


// ============================================================================
// Helper Functions (Module-Level)
// ============================================================================
/// Check if byte slice is ASCII-only (fast path optimization)
fn isAscii(bytes: []const u8) bool {
for (bytes) |byte| {
if (byte > 0x7F) return false;
}
return true;
}
/// Replace invalid UTF-8 sequences with U+FFFD REPLACEMENT CHARACTER
fn replaceInvalidUtf8(allocator: std.mem.Allocator, input: []const u8) ![]const u8 {
// Allocate output buffer (worst case: 3 bytes per input byte for U+FFFD)
var output = std.ArrayList(u8).init(allocator);
errdefer output.deinit();
const replacement = "\u{FFFD}";
// U+FFFD in UTF-8 (3 bytes: EF BF BD)
var i: usize = 0;
while (i < input.len) {
const cp_len = std.unicode.utf8ByteSequenceLength(input[i]) catch {
// Invalid start byte - replace with U+FFFD
try output.appendSlice(replacement);
i += 1;
continue;
};
if (i + cp_len > input.len) {
// Incomplete code point at end - replace with U+FFFD
try output.appendSlice(replacement);
break;
}
// Validate code point
const cp = std.unicode.utf8Decode(input[i .. i + cp_len]) catch {
// Invalid code point - replace with U+FFFD
try output.appendSlice(replacement);
i += cp_len;
continue;
};
// Valid code point - encode back to UTF-8
var buf: [4]u8 = undefined;
const out_len = std.unicode.utf8Encode(cp, &buf) catch unreachable;
try output.appendSlice(buf[0..out_len]);
i += cp_len;
}
return output.toOwnedSlice();
}
/// TextEncoder - encodes strings to UTF-8 bytes
///
/// WHATWG Encoding Standard § 5.2
/// https://encoding.spec.whatwg.org/#interface-textencoder
///
/// IDL:
/// ```
/// [Exposed=*]
/// interface TextEncoder {
///   constructor();
///   [NewObject] Uint8Array encode(optional USVString input = "");
///   TextEncoderEncodeIntoResult encodeInto(USVString source, [AllowShared] Uint8Array destination);
/// };
/// TextEncoder includes TextEncoderCommon;
///
/// interface mixin TextEncoderCommon {
///   readonly attribute DOMString encoding;
/// };
/// ```
///
/// Note: TextEncoder only supports UTF-8 encoding (no label argument).
/// Note: TextEncoder offers no stream option (no buffering needed).

pub const TextEncoder = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    encoding: []const u8,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) TextEncoder {

        return .{
            .encoding = "utf-8",
            .allocator = allocator,
        };
    
    }

    pub fn deinit(self: *TextEncoder) void {
        _ = self;
        // No resources to clean up (stateless)
    }

    /// Get the encoding name (always "utf-8")
    ///
    /// WHATWG Encoding Standard § 5.2.1
    /// TextEncoderCommon.encoding getter
    ///
    /// IDL:
    /// ```
    /// readonly attribute DOMString encoding;
    /// ```
    ///
    /// Note: Returns UTF-8 string. For JavaScript bindings, convert to DOMString (UTF-16).
    pub inline fn get_encoding(self: *const TextEncoder) []const u8 {
        return self.encoding;
    }

    /// encode() - Encodes a string into UTF-8 bytes
    ///
    /// WHATWG Encoding Standard § 5.2.2
    /// https://encoding.spec.whatwg.org/#dom-textencoder-encode
    ///
    /// Encodes the input string to UTF-8 and returns a newly allocated byte buffer.
    ///
    /// ## Parameters
    ///
    /// - `input`: String to encode (UTF-8)
    ///   - For JavaScript bindings: convert USVString (UTF-16) → UTF-8 first
    ///
    /// ## Returns
    ///
    /// Newly allocated UTF-8 byte buffer. **Caller owns the returned memory** and must free it.
    ///
    /// ## Errors
    ///
    /// - `error.OutOfMemory`: Allocation failed
    ///
    /// Note: Per WHATWG spec, UTF-8 encoder cannot fail (invalid sequences replaced with U+FFFD).
    ///
    /// ## Behavior
    ///
    /// - **ASCII Fast Path**: For ASCII-only input, direct copy (~10x faster)
    /// - **UTF-8 Validation**: Invalid sequences replaced with U+FFFD (shouldn't happen with valid input)
    /// - **Allocation**: Always allocates new buffer (use `encodeInto()` for zero-copy)
    ///
    /// ## Examples
    ///
    /// ### Basic Encode
    /// ```zig
    /// var encoder = TextEncoder.init(allocator);
    /// defer encoder.deinit();
    ///
    /// const bytes = try encoder.encode("Hello");
    /// defer allocator.free(bytes);
    /// // bytes is [_]u8{ 0x48, 0x65, 0x6C, 0x6C, 0x6F }
    /// ```
    ///
    /// ### Multibyte Characters
    /// ```zig
    /// const bytes = try encoder.encode("世界");
    /// defer allocator.free(bytes);
    /// // bytes contains UTF-8 encoding of Chinese characters (6 bytes)
    /// ```
    ///
    /// ### Empty String
    /// ```zig
    /// const bytes = try encoder.encode("");
    /// defer allocator.free(bytes);
    /// // bytes.len == 0
    /// ```
    ///
    /// ## Performance
    ///
    /// - ASCII-only: O(n) copy
    /// - Multibyte: O(n) with validation
    /// - No reallocation (size known upfront)
    ///
    /// ## Spec Algorithm
    ///
    /// The encode(input) method steps are:
    /// 1. Convert input to an I/O queue of scalar values
    /// 2. Let output be the I/O queue of bytes
    /// 3. Process with UTF-8 encoder
    /// 4. Return Uint8Array
    ///
    /// ## Implementation Notes
    ///
    /// This implementation uses UTF-8 strings for I/O (Zig native).
    /// For JavaScript bindings:
    /// - Convert USVString (UTF-16) → UTF-8 before calling
    /// - Wrap returned []const u8 in Uint8Array after calling
    pub fn call_encode(
        self: *TextEncoder,
        input: []const u8,
    ) ![]const u8 {

        // Handle empty input (common case)
        if (input.len == 0) {
            return &[_]u8{};
        }

        // ASCII FAST PATH: For ASCII-only input, return as-is
        // ASCII is valid UTF-8, no conversion needed
        if (isAscii(input)) {
            return self.allocator.dupe(u8, input);
        }

        // GENERAL PATH: Validate and encode UTF-8
        // Note: If input is already valid UTF-8, we just copy it
        // The spec says to encode scalar values with UTF-8 encoder
        // Since our input is UTF-8, we validate and copy
        if (!std.unicode.utf8ValidateSlice(input)) {
            // Invalid UTF-8 - replace invalid sequences with U+FFFD
            // This shouldn't happen with USVString input, but handle it gracefully
            return try replaceInvalidUtf8(self.allocator, input);
        }

        // Valid UTF-8 - just duplicate
        return self.allocator.dupe(u8, input);
    
    }

    pub fn call_encodeInto(
        self: *TextEncoder,
        source: []const u8,
        destination: []u8,
    ) !TextEncoderEncodeIntoResult {

        _ = self;

        var read: u64 = 0;
        var written: u64 = 0;

        // Process UTF-8 input
        var i: usize = 0;
        while (i < source.len and written < destination.len) {
            // Get UTF-8 code point length
            const cp_len = std.unicode.utf8ByteSequenceLength(source[i]) catch {
                // Invalid UTF-8 - skip byte
                i += 1;
                read += 1;
                continue;
            };

            // Check if we have enough space
            if (written + cp_len > destination.len) {
                // Not enough space for this code point
                break;
            }

            // Check if we have enough input bytes
            if (i + cp_len > source.len) {
                // Incomplete code point at end of input
                break;
            }

            // Copy code point bytes
            @memcpy(destination[written .. written + cp_len], source[i .. i + cp_len]);

            written += cp_len;
            read += cp_len;
            i += cp_len;
        }

        return .{
            .read = read,
            .written = written,
        };
    
    }

};


