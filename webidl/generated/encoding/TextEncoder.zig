// Auto-generated by webidl-codegen (AST/IR-based)
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts
//   - Automatic import resolution

const std = @import("std");
const webidl = @import("webidl");
const Allocator = @import("std.mem").Allocator;
const Text = @import("text").Text;
const std = @import("std");
const webidl = @import("webidl");

pub const TextEncoder = struct {

    // ========================================================================
    // Fields
    // ========================================================================

    encoding: []const u8,

    // ========================================================================
    // Methods
    // ========================================================================

    pub fn init(allocator: std.mem.Allocator) TextEncoder {

        return .{
            .encoding = "utf-8",
            .allocator = allocator,
        };
    
    }

    pub fn deinit(self: *TextEncoder) void {

        _ = self;
        // No resources to clean up (stateless)
    
    }

    pub fn call_encode(
        self: *TextEncoder,
        input: []const u8,
    ) ![]const u8 {

        // Handle empty input (common case)
        if (input.len == 0) {
            return &[_]u8{};
        }

        // ASCII FAST PATH: For ASCII-only input, return as-is
        // ASCII is valid UTF-8, no conversion needed
        if (isAscii(input)) {
            return self.allocator.dupe(u8, input);
        }

        // GENERAL PATH: Validate and encode UTF-8
        // Note: If input is already valid UTF-8, we just copy it
        // The spec says to encode scalar values with UTF-8 encoder
        // Since our input is UTF-8, we validate and copy
        if (!std.unicode.utf8ValidateSlice(input)) {
            // Invalid UTF-8 - replace invalid sequences with U+FFFD
            // This shouldn't happen with USVString input, but handle it gracefully
            return try replaceInvalidUtf8(self.allocator, input);
        }

        // Valid UTF-8 - just duplicate
        return self.allocator.dupe(u8, input);
    
    }

    pub fn call_encodeInto(
        self: *TextEncoder,
        source: []const u8,
        destination: []u8,
    ) !TextEncoderEncodeIntoResult {

        _ = self;

        var read: u64 = 0;
        var written: u64 = 0;

        // Process UTF-8 input
        var i: usize = 0;
        while (i < source.len and written < destination.len) {
            // Get UTF-8 code point length
            const cp_len = std.unicode.utf8ByteSequenceLength(source[i]) catch {
                // Invalid UTF-8 - skip byte
                i += 1;
                read += 1;
                continue;
            };

            // Check if we have enough space
            if (written + cp_len > destination.len) {
                // Not enough space for this code point
                break;
            }

            // Check if we have enough input bytes
            if (i + cp_len > source.len) {
                // Incomplete code point at end of input
                break;
            }

            // Copy code point bytes
            @memcpy(destination[written .. written + cp_len], source[i .. i + cp_len]);

            written += cp_len;
            read += cp_len;
            i += cp_len;
        }

        return .{
            .read = read,
            .written = written,
        };
    
    }

};


